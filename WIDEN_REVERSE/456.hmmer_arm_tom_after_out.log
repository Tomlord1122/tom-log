/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o alphabet.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                alphabet.c
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 36 -> VectorType: <8 x float> -> ttilog -> MaskedMemoryOpCost(36)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 36 -> VectorType: <8 x float> -> ttilog -> MaskedMemoryOpCost(36)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 72 -> VectorType: <16 x float> -> ttilog -> MaskedMemoryOpCost(72)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 72 -> VectorType: <16 x float> -> ttilog -> MaskedMemoryOpCost(72)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 8 -> VectorType: <2 x float> -> ttilog -> MaskedMemoryOpCost(8)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 8 -> VectorType: <2 x float> -> ttilog -> MaskedMemoryOpCost(8)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 18 -> VectorType: <4 x float> -> ttilog -> MaskedMemoryOpCost(18)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 18 -> VectorType: <4 x float> -> ttilog -> MaskedMemoryOpCost(18)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 36 -> VectorType: <8 x float> -> ttilog -> MaskedMemoryOpCost(36)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 36 -> VectorType: <8 x float> -> ttilog -> MaskedMemoryOpCost(36)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 72 -> VectorType: <16 x float> -> ttilog -> MaskedMemoryOpCost(72)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 72 -> VectorType: <16 x float> -> ttilog -> MaskedMemoryOpCost(72)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store float %add17, ptr %arrayidx16, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: P7CountSymbol' from alphabet.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@Degenerate>, ir<0>, ir<%idxprom6>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx9>
    CLONE ir<%tobool.not> = icmp eq ir<%2>, ir<0>
  Successor(s): if.then10

  if.then10:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%3> = load ir<%arrayidx13>, vp<%4>
    CLONE ir<%conv14> = sitofp ir<%3>
    CLONE ir<%div> = fdiv ir<%wt>, ir<%conv14>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%counters>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx16>, vp<%4>
    CLONE ir<%add17> = fadd ir<%4>, ir<%div>
    CLONE store ir<%add17>, ir<%arrayidx16>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%tobool.not>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end18.loopexit>, scalar.ph

ir-bb<if.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7CountSymbol' from alphabet.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@Degenerate>, ir<0>, ir<%idxprom6>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<0>
  Successor(s): if.then10

  if.then10:
    EMIT vp<%5> = not ir<%tobool.not>
    REPLICATE ir<%3> = load ir<%arrayidx13>, vp<%5>
    WIDEN-CAST ir<%conv14> = sitofp  ir<%3> to float
    WIDEN ir<%div> = fdiv ir<%wt>, ir<%conv14>
    CLONE ir<%arrayidx16> = getelementptr ir<%counters>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%4> = load vp<%6>, vp<%5>
    WIDEN ir<%add17> = fadd ir<%4>, ir<%div>
    vp<%7> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%7>, ir<%add17>, vp<%5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = or ir<%tobool.not>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end18.loopexit>, scalar.ph

ir-bb<if.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7CountSymbol' from alphabet.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@Degenerate>, ir<0>, ir<%idxprom6>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<0>
  Successor(s): if.then10

  if.then10:
    EMIT vp<%5> = not ir<%tobool.not>
    REPLICATE ir<%3> = load ir<%arrayidx13>, vp<%5>
    WIDEN-CAST ir<%conv14> = sitofp  ir<%3> to float
    WIDEN ir<%div> = fdiv ir<%wt>, ir<%conv14>
    CLONE ir<%arrayidx16> = getelementptr ir<%counters>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%4> = load vp<%6>, vp<%5>
    WIDEN ir<%add17> = fadd ir<%4>, ir<%div>
    vp<%7> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%7>, ir<%add17>, vp<%5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = or ir<%tobool.not>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end18.loopexit>, scalar.ph

ir-bb<if.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7CountSymbol' from alphabet.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@Degenerate>, ir<0>, ir<%idxprom6>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<0>
  Successor(s): if.then10

  if.then10:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%3> = load ir<%arrayidx13>, vp<%5>
    WIDEN-CAST ir<%conv14> = sitofp  ir<%3> to float
    WIDEN ir<%div> = fdiv ir<%wt>, ir<%conv14>
    CLONE ir<%arrayidx16> = getelementptr ir<%counters>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%4> = load vp<%6>, vp<%5>
    WIDEN ir<%add17> = fadd ir<%4>, ir<%div>
    vp<%7> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%7>, ir<%add17>, vp<%5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = or ir<%tobool.not>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end18.loopexit>, scalar.ph

ir-bb<if.end18.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 8 for VF 2 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 8 for VF 2 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1500015
A is not scalable.	B is not scalable.	
RTCostA: 381003947, RTCostB: 2550
A is not scalable.	B is not scalable.	
RTCostA: 381003947, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 18 for VF 4 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 18 for VF 4 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 750013
A is not scalable.	B is not scalable.	
RTCostA: 189003369, RTCostB: 2550
A is not scalable.	B is not scalable.	
RTCostA: 189003369, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 16 for VF 8 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 8 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 36 for VF 8 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 36 for VF 8 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 375012
A is not scalable.	B is not scalable.	
RTCostA: 93003170, RTCostB: 2550
A is not scalable.	B is not scalable.	
RTCostA: 93003170, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 32 for VF 16 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 16 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 8 for VF 16 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 72 for VF 16 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 72 for VF 16 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 187512
A is not scalable.	B is not scalable.	
RTCostA: 45003090, RTCostB: 2550
A is not scalable.	B is not scalable.	
RTCostA: 45003090, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 3243, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: 3243, RTCostB: 2550

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds [24 x [20 x i8]], ptr @Degenerate, i64 0, i64 %idxprom6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i8 %2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %for.inc, label %if.then10 of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %3 = load i32, ptr %arrayidx13, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv14 = sitofp i32 %3 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div = fdiv float %wt, %conv14 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %counters, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load float, ptr %arrayidx16, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add17 = fadd float %4, %div of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %add17, ptr %arrayidx16, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'P7CountSymbol' from alphabet.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end18.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 2891, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: 2891, RTCostB: 2550
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o core_algorithms.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                core_algorithms.c
MVT: v4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 6 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: v8i8
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 12 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(8) = LT.first(4) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v2i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i16
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 6 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: v8i8
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 12 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(8) = LT.first(4) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 1, ptr %arrayidx93, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 5, ptr %arrayidx95, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %8 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv702 = phi %indvars.iv.next703, %idxprom35, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<%call>, ir<%indvars.iv702>
    CLONE store ir<1>, ir<%arrayidx93>
    CLONE ir<%arrayidx95> = getelementptr inbounds ir<%call4>, ir<%indvars.iv702>
    CLONE store ir<5>, ir<%arrayidx95>
    CLONE ir<%indvars.iv.next703> = add nsw ir<%indvars.iv702>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv702>, ir<%idxprom24>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end114.loopexit.loopexit>, scalar.ph

ir-bb<if.end114.loopexit.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next703.lcssa = ir<%indvars.iv.next703>
}

========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %8 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv702 = phi %indvars.iv.next703, %idxprom35, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<%call>, ir<%indvars.iv702>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx93>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx95> = getelementptr inbounds ir<%call4>, ir<%indvars.iv702>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx95>
    WIDEN store vp<%5>, ir<5>
    CLONE ir<%indvars.iv.next703> = add nsw ir<%indvars.iv702>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv702>, ir<%idxprom24>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end114.loopexit.loopexit>, scalar.ph

ir-bb<if.end114.loopexit.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next703.lcssa = ir<%indvars.iv.next703>
}

========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %8 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv702 = phi %indvars.iv.next703, %idxprom35, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<%call>, ir<%indvars.iv702>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx93>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx95> = getelementptr inbounds ir<%call4>, ir<%indvars.iv702>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx95>
    WIDEN store vp<%5>, ir<5>
    CLONE ir<%indvars.iv.next703> = add nsw ir<%indvars.iv702>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv702>, ir<%idxprom24>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end114.loopexit.loopexit>, scalar.ph

ir-bb<if.end114.loopexit.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next703.lcssa = ir<%indvars.iv.next703>
}


-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 6 for VF 8 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 12 for VF 16 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 17
B VF: 8, EstimatedWidthB: 8, CostB: 10
CostA * EstimatedWidthB: 136, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 17
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 34

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 17
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 68

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv702 = phi i64 [ %indvars.iv.next703, %for.body ], [ %idxprom35, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx93 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 1, ptr %arrayidx93, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx95 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv702 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 5, ptr %arrayidx95, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next703 = add nsw i64 %indvars.iv702, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv702, %idxprom24 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %if.end114.loopexit.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 17
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 136
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7WeeViterbi at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %8 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom35> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx93>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx95> = getelementptr inbounds ir<%call4>, vp<%5>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx95>
    WIDEN store vp<%7>, ir<5>
    CLONE ir<%indvars.iv.next703> = add nsw vp<%5>, ir<-1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end114.loopexit.loopexit>, scalar.ph

ir-bb<if.end114.loopexit.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next703.lcssa = ir<%indvars.iv.next703>
}
================ Final VPlan ================

@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 8, ptr %arrayidx110, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body105.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %8) + %4) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom35, %indvars.iv.next, ir<1>
    CLONE ir<%58> = load ir<%M>
    CLONE ir<%arrayidx108> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%58>, ir<%arrayidx108>
    CLONE ir<%arrayidx110> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    CLONE store ir<8>, ir<%arrayidx110>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end114.loopexit668.loopexit>, scalar.ph

ir-bb<if.end114.loopexit668.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body105.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %8) + %4) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom35, %indvars.iv.next, ir<1>
    CLONE ir<%58> = load ir<%M>
    CLONE ir<%arrayidx108> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx108>
    WIDEN store vp<%4>, ir<%58>
    CLONE ir<%arrayidx110> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx110>
    WIDEN store vp<%5>, ir<8>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end114.loopexit668.loopexit>, scalar.ph

ir-bb<if.end114.loopexit668.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7WeeViterbi' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body105.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %8) + %4) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom35, %indvars.iv.next, ir<1>
    CLONE ir<%58> = load ir<%M>
    CLONE ir<%arrayidx108> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx108>
    WIDEN store vp<%4>, ir<%58>
    CLONE ir<%arrayidx110> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx110>
    WIDEN store vp<%5>, ir<8>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end114.loopexit668.loopexit>, scalar.ph

ir-bb<if.end114.loopexit668.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF 8 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF 16 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'P7WeeViterbi' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %idxprom35, %for.body105.preheader ], [ %indvars.iv.next, %for.body105 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %58 = load i32, ptr %M, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx108 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %58, ptr %arrayidx108, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx110 = getelementptr inbounds i8, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 8, ptr %arrayidx110, align 1, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end114.loopexit668.loopexit, label %for.body105 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 72
LV: Selecting VF: 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 56
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: P7WeeViterbi at line: core_algorithms.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=16, UF=2 at function: P7WeeViterbi at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body105.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %8) + %4) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom35> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%64> = load ir<%M>
    CLONE ir<%arrayidx108> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx108>
    WIDEN store vp<%6>, ir<%64>
    CLONE ir<%arrayidx110> = getelementptr inbounds ir<%call4>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx110>
    WIDEN store vp<%7>, ir<8>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end114.loopexit668.loopexit>, scalar.ph

ir-bb<if.end114.loopexit668.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: P7WeeViterbi at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%13> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%idxprom35> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%81> = load ir<%M>
    CLONE ir<%arrayidx108> = getelementptr inbounds ir<%call>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx108>
    WIDEN store vp<%5>, ir<%81>
    CLONE ir<%arrayidx110> = getelementptr inbounds ir<%call4>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx110>
    WIDEN store vp<%6>, ir<8>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%13>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end114.loopexit668.loopexit>, scalar.ph

ir-bb<if.end114.loopexit668.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 25
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %k1) + %k3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%4>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx31>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx35>
    CLONE ir<%arrayidx39> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx39>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %k1) + %k3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx39> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx39>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %k1) + %k3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx39> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx39>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%10>, ir<%lftr.wideiv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %9, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx31, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx35, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx39 = getelementptr inbounds i32, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx39, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i32 %10, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: get_wee_midpt at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %k1) + %k3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%12> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%4>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%7>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%7>, ir<-987654321>
    CLONE ir<%arrayidx39> = getelementptr inbounds ir<%10>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx39>
    WIDEN store vp<%8>, ir<-987654321>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body682.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 %k1 to i64))<nsw> + ((sext i32 %k1 to i64) smax (1 + (sext i32 %k3 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1793 = phi %186, %indvars.iv.next1794, ir<1>
    CLONE ir<%arrayidx686> = getelementptr inbounds ir<%183>, ir<%indvars.iv1793>
    CLONE store ir<-987654321>, ir<%arrayidx686>
    CLONE ir<%arrayidx690> = getelementptr inbounds ir<%184>, ir<%indvars.iv1793>
    CLONE store ir<-987654321>, ir<%arrayidx690>
    CLONE ir<%arrayidx694> = getelementptr inbounds ir<%185>, ir<%indvars.iv1793>
    CLONE store ir<-987654321>, ir<%arrayidx694>
    CLONE ir<%indvars.iv.next1794> = add nsw ir<%indvars.iv1793>, ir<1>
    CLONE ir<%cmp680.not> = icmp sgt ir<%indvars.iv1793>, ir<%187>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end697.loopexit>, scalar.ph

ir-bb<for.end697.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body682.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 %k1 to i64))<nsw> + ((sext i32 %k1 to i64) smax (1 + (sext i32 %k3 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1793 = phi %186, %indvars.iv.next1794, ir<1>
    CLONE ir<%arrayidx686> = getelementptr inbounds ir<%183>, ir<%indvars.iv1793>
    vp<%4> = vector-pointer ir<%arrayidx686>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx690> = getelementptr inbounds ir<%184>, ir<%indvars.iv1793>
    vp<%5> = vector-pointer ir<%arrayidx690>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx694> = getelementptr inbounds ir<%185>, ir<%indvars.iv1793>
    vp<%6> = vector-pointer ir<%arrayidx694>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next1794> = add nsw ir<%indvars.iv1793>, ir<1>
    CLONE ir<%cmp680.not> = icmp sgt ir<%indvars.iv1793>, ir<%187>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end697.loopexit>, scalar.ph

ir-bb<for.end697.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body682.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 %k1 to i64))<nsw> + ((sext i32 %k1 to i64) smax (1 + (sext i32 %k3 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1793 = phi %186, %indvars.iv.next1794, ir<1>
    CLONE ir<%arrayidx686> = getelementptr inbounds ir<%183>, ir<%indvars.iv1793>
    vp<%4> = vector-pointer ir<%arrayidx686>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx690> = getelementptr inbounds ir<%184>, ir<%indvars.iv1793>
    vp<%5> = vector-pointer ir<%arrayidx690>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx694> = getelementptr inbounds ir<%185>, ir<%indvars.iv1793>
    vp<%6> = vector-pointer ir<%arrayidx694>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next1794> = add nsw ir<%indvars.iv1793>, ir<1>
    CLONE ir<%cmp680.not> = icmp sgt ir<%indvars.iv1793>, ir<%187>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end697.loopexit>, scalar.ph

ir-bb<for.end697.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1793 = phi i64 [ %186, %for.body682.lr.ph ], [ %indvars.iv.next1794, %for.body682 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx686 = getelementptr inbounds i32, ptr %183, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx686, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx690 = getelementptr inbounds i32, ptr %184, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx690, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx694 = getelementptr inbounds i32, ptr %185, i64 %indvars.iv1793 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx694, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1794 = add nsw i64 %indvars.iv1793, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp680.not = icmp sgt i64 %indvars.iv1793, %187 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp680.not, label %for.end697.loopexit, label %for.body682 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: get_wee_midpt at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body682.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 %k1 to i64))<nsw> + ((sext i32 %k1 to i64) smax (1 + (sext i32 %k3 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%189> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx686> = getelementptr inbounds ir<%183>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx686>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%arrayidx690> = getelementptr inbounds ir<%185>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx690>
    WIDEN store vp<%7>, ir<-987654321>
    CLONE ir<%arrayidx694> = getelementptr inbounds ir<%187>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx694>
    WIDEN store vp<%8>, ir<-987654321>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end697.loopexit>, scalar.ph

ir-bb<for.end697.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body762.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %k3 to i64) + (-1 * (sext i32 %k1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1799 = phi %243, %indvars.iv.next1800, ir<-1>
    CLONE ir<%245> = load ir<%arrayidx677>
    CLONE ir<%arrayidx768.us> = getelementptr inbounds ir<%241>, ir<%indvars.iv1799>
    CLONE ir<%246> = load ir<%arrayidx768.us>
    CLONE ir<%add769.us> = add nsw ir<%246>, ir<%245>
    CLONE ir<%arrayidx773.us> = getelementptr inbounds ir<%242>, ir<%indvars.iv1799>
    CLONE store ir<%add769.us>, ir<%arrayidx773.us>
    CLONE ir<%indvars.iv.next1800> = add nsw ir<%indvars.iv1799>, ir<-1>
    CLONE ir<%cmp760.not.us.not> = icmp sgt ir<%indvars.iv1799>, ir<%244>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end793.loopexit>, scalar.ph

ir-bb<if.end793.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body762.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %k3 to i64) + (-1 * (sext i32 %k1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1799 = phi %243, %indvars.iv.next1800, ir<-1>
    CLONE ir<%245> = load ir<%arrayidx677>
    CLONE ir<%arrayidx768.us> = getelementptr inbounds ir<%241>, ir<%indvars.iv1799>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx768.us>
    WIDEN ir<%246> = load vp<%4>
    WIDEN ir<%add769.us> = add nsw ir<%246>, ir<%245>
    CLONE ir<%arrayidx773.us> = getelementptr inbounds ir<%242>, ir<%indvars.iv1799>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx773.us>
    WIDEN store vp<%5>, ir<%add769.us>
    CLONE ir<%indvars.iv.next1800> = add nsw ir<%indvars.iv1799>, ir<-1>
    CLONE ir<%cmp760.not.us.not> = icmp sgt ir<%indvars.iv1799>, ir<%244>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end793.loopexit>, scalar.ph

ir-bb<if.end793.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: get_wee_midpt' from core_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body762.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %k3 to i64) + (-1 * (sext i32 %k1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1799 = phi %243, %indvars.iv.next1800, ir<-1>
    CLONE ir<%245> = load ir<%arrayidx677>
    CLONE ir<%arrayidx768.us> = getelementptr inbounds ir<%241>, ir<%indvars.iv1799>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx768.us>
    WIDEN ir<%246> = load vp<%4>
    WIDEN ir<%add769.us> = add nsw ir<%246>, ir<%245>
    CLONE ir<%arrayidx773.us> = getelementptr inbounds ir<%242>, ir<%indvars.iv1799>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx773.us>
    WIDEN store vp<%5>, ir<%add769.us>
    CLONE ir<%indvars.iv.next1800> = add nsw ir<%indvars.iv1799>, ir<-1>
    CLONE ir<%cmp760.not.us.not> = icmp sgt ir<%indvars.iv1799>, ir<%244>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end793.loopexit>, scalar.ph

ir-bb<if.end793.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'get_wee_midpt' from core_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1799 = phi i64 [ %243, %for.body762.us.preheader ], [ %indvars.iv.next1800, %for.body762.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %245 = load i32, ptr %arrayidx677, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx768.us = getelementptr inbounds i32, ptr %241, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %246 = load i32, ptr %arrayidx768.us, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add769.us = add nsw i32 %246, %245 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx773.us = getelementptr inbounds i32, ptr %242, i64 %indvars.iv1799 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add769.us, ptr %arrayidx773.us, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1800 = add nsw i64 %indvars.iv1799, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp760.not.us.not = icmp sgt i64 %indvars.iv1799, %244 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp760.not.us.not, label %for.body762.us, label %if.end793.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: get_wee_midpt at line: core_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body762.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 %k3 to i64) + (-1 * (sext i32 %k1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%243> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%248> = load ir<%arrayidx677>
    CLONE ir<%arrayidx768.us> = getelementptr inbounds ir<%241>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx768.us>
    WIDEN ir<%249> = load vp<%6>
    WIDEN ir<%add769.us> = add nsw ir<%249>, ir<%248>
    CLONE ir<%arrayidx773.us> = getelementptr inbounds ir<%242>, vp<%5>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx773.us>
    WIDEN store vp<%7>, ir<%add769.us>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end793.loopexit>, scalar.ph

ir-bb<if.end793.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 35
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o debug.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                debug.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o display.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                display.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o emit.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                emit.c
@@ Instruction =>  %4 = load float, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 -> Cost: 18 -> VectorType: <4 x float> -> ttilog -> MaskedMemoryOpCost(18)
@@ Instruction =>  %4 = load float, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 -> Cost: 8 -> VectorType: <2 x float> -> ttilog -> MaskedMemoryOpCost(8)
@@ Instruction =>  %4 = load float, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 -> Cost: 18 -> VectorType: <4 x float> -> ttilog -> MaskedMemoryOpCost(18)
@@ Instruction =>  %4 = load float, ptr %arrayidx, align 4, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %4 = load float, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: EmitConsensusSequence' from emit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nmat.0234> = phi ir<0>, ir<%nmat.1>
    WIDEN-REDUCTION-PHI ir<%ndel.0233> = phi ir<0>, ir<%ndel.1>
    WIDEN-REDUCTION-PHI ir<%nins.0231> = phi ir<0>, ir<%nins.1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre257.pre>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%cmp2> = fcmp ult ir<%4>, ir<5.000000e-01>
    CLONE ir<%inc6> = zext ir<%cmp2>
    CLONE ir<%ndel.1> = add ir<%ndel.0233>, ir<%inc6>
    CLONE ir<%not.cmp2> = xor ir<%cmp2>, ir<true>
    CLONE ir<%inc> = zext ir<%not.cmp2>
    CLONE ir<%nmat.1> = add ir<%nmat.0234>, ir<%inc>
    CLONE ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<%2>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%.pre258.pre>, ir<%indvars.iv>
    CLONE ir<%5> = load ir<%arrayidx12>, ir<%cmp9>
    CLONE ir<%cmp14> = fcmp ult ir<%5>, ir<5.000000e-01>
  Successor(s): if.then16

  if.then16:
    EMIT vp<%4> = not ir<%cmp14>
    EMIT vp<%5> = logical-and ir<%cmp9>, vp<%4>
    CLONE ir<%6> = load ir<%t>, vp<%5>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE ir<%7> = load ir<%arrayidx18>, vp<%5>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%7>, ir<16>
    CLONE ir<%8> = load ir<%arrayidx19>, vp<%5>
    CLONE ir<%sub> = fsub ir<1.000000e+00>, ir<%8>
    CLONE ir<%div> = fdiv ir<1.000000e+00>, ir<%sub>
    CLONE ir<%conv20> = fptosi ir<%div>
    CLONE ir<%add> = add ir<%nins.0231>, ir<%conv20>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp9>
    EMIT vp<%7> = logical-and ir<%cmp9>, ir<%cmp14>
    EMIT vp<%8> = or vp<%6>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%5>
    BLEND ir<%nins.1> = ir<%add> ir<%nins.0231>/vp<%7> ir<%nins.0231>/vp<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%nmat.0234>, ir<%nmat.1>
  EMIT vp<%13> = compute-reduction-result ir<%ndel.0233>, ir<%ndel.1>
  EMIT vp<%14> = compute-reduction-result ir<%nins.0231>, ir<%nins.1>
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %nins.1.lcssa = vp<%14>
Live-out i32 %ndel.1.lcssa = vp<%13>
Live-out i32 %nmat.1.lcssa = vp<%12>
}

========== Loop: EmitConsensusSequence' from emit.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nmat.0234> = phi ir<0>, ir<%nmat.1>
    WIDEN-REDUCTION-PHI ir<%ndel.0233> = phi ir<0>, ir<%ndel.1>
    WIDEN-REDUCTION-PHI ir<%nins.0231> = phi ir<0>, ir<%nins.1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre257.pre>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%cmp2> = fcmp ult ir<%4>, ir<5.000000e-01>
    WIDEN-CAST ir<%inc6> = zext  ir<%cmp2> to i32
    WIDEN ir<%ndel.1> = add ir<%ndel.0233>, ir<%inc6>
    WIDEN ir<%not.cmp2> = xor ir<%cmp2>, ir<true>
    WIDEN-CAST ir<%inc> = zext  ir<%not.cmp2> to i32
    WIDEN ir<%nmat.1> = add ir<%nmat.0234>, ir<%inc>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<%2>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx12> = getelementptr ir<%.pre258.pre>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%5> = load vp<%5>, ir<%cmp9>
    WIDEN ir<%cmp14> = fcmp ult ir<%5>, ir<5.000000e-01>
  Successor(s): if.then16

  if.then16:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = logical-and ir<%cmp9>, vp<%6>
    REPLICATE ir<%6> = load ir<%t>, vp<%7>
    REPLICATE ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE ir<%7> = load ir<%arrayidx18>, vp<%7>
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%7>, ir<16>
    REPLICATE ir<%8> = load ir<%arrayidx19>, vp<%7>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%8>
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%sub>
    WIDEN-CAST ir<%conv20> = fptosi  ir<%div> to i32
    WIDEN ir<%add> = add ir<%nins.0231>, ir<%conv20>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = not ir<%cmp9>
    EMIT vp<%9> = logical-and ir<%cmp9>, ir<%cmp14>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%7>
    BLEND ir<%nins.1> = ir<%add> ir<%nins.0231>/vp<%9> ir<%nins.0231>/vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%nmat.0234>, ir<%nmat.1>
  EMIT vp<%15> = compute-reduction-result ir<%ndel.0233>, ir<%ndel.1>
  EMIT vp<%16> = compute-reduction-result ir<%nins.0231>, ir<%nins.1>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %nins.1.lcssa = vp<%16>
Live-out i32 %ndel.1.lcssa = vp<%15>
Live-out i32 %nmat.1.lcssa = vp<%14>
}

========== Loop: EmitConsensusSequence' from emit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nmat.0234> = phi ir<0>, ir<%nmat.1>
    WIDEN-REDUCTION-PHI ir<%ndel.0233> = phi ir<0>, ir<%ndel.1>
    WIDEN-REDUCTION-PHI ir<%nins.0231> = phi ir<0>, ir<%nins.1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre257.pre>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%cmp2> = fcmp ult ir<%4>, ir<5.000000e-01>
    WIDEN-CAST ir<%inc6> = zext  ir<%cmp2> to i32
    WIDEN ir<%ndel.1> = add ir<%ndel.0233>, ir<%inc6>
    WIDEN ir<%not.cmp2> = xor ir<%cmp2>, ir<true>
    WIDEN-CAST ir<%inc> = zext  ir<%not.cmp2> to i32
    WIDEN ir<%nmat.1> = add ir<%nmat.0234>, ir<%inc>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<%2>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx12> = getelementptr ir<%.pre258.pre>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%5> = load vp<%5>, ir<%cmp9>
    WIDEN ir<%cmp14> = fcmp ult ir<%5>, ir<5.000000e-01>
  Successor(s): if.then16

  if.then16:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = logical-and ir<%cmp9>, vp<%6>
    REPLICATE ir<%6> = load ir<%t>, vp<%7>
    WIDEN-GEP Var[Var] ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE ir<%7> = load ir<%arrayidx18>, vp<%7>
    WIDEN-GEP Var[Inv] ir<%arrayidx19> = getelementptr inbounds ir<%7>, ir<16>
    REPLICATE ir<%8> = load ir<%arrayidx19>, vp<%7>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%8>
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%sub>
    WIDEN-CAST ir<%conv20> = fptosi  ir<%div> to i32
    WIDEN ir<%add> = add ir<%nins.0231>, ir<%conv20>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = not ir<%cmp9>
    EMIT vp<%9> = logical-and ir<%cmp9>, ir<%cmp14>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%7>
    BLEND ir<%nins.1> = ir<%add> ir<%nins.0231>/vp<%9> ir<%nins.0231>/vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%nmat.0234>, ir<%nmat.1>
  EMIT vp<%15> = compute-reduction-result ir<%ndel.0233>, ir<%ndel.1>
  EMIT vp<%16> = compute-reduction-result ir<%nins.0231>, ir<%nins.1>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %nins.1.lcssa = vp<%16>
Live-out i32 %ndel.1.lcssa = vp<%15>
Live-out i32 %nmat.1.lcssa = vp<%14>
}

========== Loop: EmitConsensusSequence' from emit.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nmat.0234> = phi ir<0>, ir<%nmat.1>
    WIDEN-REDUCTION-PHI ir<%ndel.0233> = phi ir<0>, ir<%ndel.1>
    WIDEN-REDUCTION-PHI ir<%nins.0231> = phi ir<0>, ir<%nins.1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre257.pre>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%cmp2> = fcmp ult ir<%4>, ir<5.000000e-01>
    WIDEN-CAST ir<%inc6> = zext  ir<%cmp2> to i32
    WIDEN ir<%ndel.1> = add ir<%ndel.0233>, ir<%inc6>
    WIDEN ir<%not.cmp2> = xor ir<%cmp2>, ir<true>
    WIDEN-CAST ir<%inc> = zext  ir<%not.cmp2> to i32
    WIDEN ir<%nmat.1> = add ir<%nmat.0234>, ir<%inc>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<%2>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx12> = getelementptr ir<%.pre258.pre>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%5> = load vp<%5>, ir<%cmp9>
    WIDEN ir<%cmp14> = fcmp ult ir<%5>, ir<5.000000e-01>
  Successor(s): if.then16

  if.then16:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = logical-and ir<%cmp9>, vp<%6>
    WIDEN ir<%6> = load ir<%t>, vp<%7>
    WIDEN-GEP Var[Var] ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    WIDEN ir<%7> = load ir<%arrayidx18>, vp<%7>
    WIDEN-GEP Var[Inv] ir<%arrayidx19> = getelementptr inbounds ir<%7>, ir<16>
    WIDEN ir<%8> = load ir<%arrayidx19>, vp<%7>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%8>
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%sub>
    WIDEN-CAST ir<%conv20> = fptosi  ir<%div> to i32
    WIDEN ir<%add> = add ir<%nins.0231>, ir<%conv20>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%8> = not ir<%cmp9>
    EMIT vp<%9> = logical-and ir<%cmp9>, ir<%cmp14>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%7>
    BLEND ir<%nins.1> = ir<%add> ir<%nins.0231>/vp<%9> ir<%nins.0231>/vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%nmat.0234>, ir<%nmat.1>
  EMIT vp<%15> = compute-reduction-result ir<%ndel.0233>, ir<%ndel.1>
  EMIT vp<%16> = compute-reduction-result ir<%nins.0231>, ir<%nins.1>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %nins.1.lcssa = vp<%16>
Live-out i32 %ndel.1.lcssa = vp<%15>
Live-out i32 %nmat.1.lcssa = vp<%14>
}


-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nmat.0234 = phi i32 [ 0, %for.body.lr.ph ], [ %nmat.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ndel.0233 = phi i32 [ 0, %for.body.lr.ph ], [ %ndel.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nins.0231 = phi i32 [ 0, %for.body.lr.ph ], [ %nins.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %.pre257.pre, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load float, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2 = fcmp ult float %4, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc6 = zext i1 %cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %ndel.1 = add nuw nsw i32 %ndel.0233, %inc6 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not.cmp2 = xor i1 %cmp2, true of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext i1 %not.cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %nmat.1 = add nuw nsw i32 %nmat.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp9, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx12 = getelementptr inbounds float, ptr %.pre258.pre, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp14 = fcmp ult float %5, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp14, label %for.inc, label %if.then16 of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load ptr, ptr %t, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx18 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %arrayidx18, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds i8, ptr %7, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %8 = load float, ptr %arrayidx19, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub float 1.000000e+00, %8 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv float 1.000000e+00, %sub of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv20 = fptosi float %div to i32 of type:fptosi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = add nsw i32 %nins.0231, %conv20 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nins.1 = phi i32 [ %add, %if.then16 ], [ %nins.0231, %land.lhs.true ], [ %nins.0231, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 17.
-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nmat.0234 = phi i32 [ 0, %for.body.lr.ph ], [ %nmat.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ndel.0233 = phi i32 [ 0, %for.body.lr.ph ], [ %ndel.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nins.0231 = phi i32 [ 0, %for.body.lr.ph ], [ %nins.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %.pre257.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load float, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2 = fcmp ult float %4, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc6 = zext i1 %cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %ndel.1 = add nuw nsw i32 %ndel.0233, %inc6 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not.cmp2 = xor i1 %cmp2, true of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext i1 %not.cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %nmat.1 = add nuw nsw i32 %nmat.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp9, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx12 = getelementptr inbounds float, ptr %.pre258.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 8 for VF 2 For instruction:   %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp14 = fcmp ult float %5, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp14, label %for.inc, label %if.then16 of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %6 = load ptr, ptr %t, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx18 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %7 = load ptr, ptr %arrayidx18, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds i8, ptr %7, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %8 = load float, ptr %arrayidx19, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub float 1.000000e+00, %8 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv float 1.000000e+00, %sub of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv20 = fptosi float %div to i32 of type:fptosi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = add nsw i32 %nins.0231, %conv20 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %nins.1 = phi i32 [ %add, %if.then16 ], [ %nins.0231, %land.lhs.true ], [ %nins.0231, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 4500020
A is not scalable.	B is not scalable.	
RTCostA: 9663719356672937, RTCostB: 36507221999
A is not scalable.	B is not scalable.	
RTCostA: 9663719356672937, RTCostB: 36507221999

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nmat.0234 = phi i32 [ 0, %for.body.lr.ph ], [ %nmat.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ndel.0233 = phi i32 [ 0, %for.body.lr.ph ], [ %ndel.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nins.0231 = phi i32 [ 0, %for.body.lr.ph ], [ %nins.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %.pre257.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load float, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2 = fcmp ult float %4, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc6 = zext i1 %cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %ndel.1 = add nuw nsw i32 %ndel.0233, %inc6 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not.cmp2 = xor i1 %cmp2, true of type:xor
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = zext i1 %not.cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %nmat.1 = add nuw nsw i32 %nmat.0234, %inc of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp9, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx12 = getelementptr inbounds float, ptr %.pre258.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 18 for VF 4 For instruction:   %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp14 = fcmp ult float %5, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp14, label %for.inc, label %if.then16 of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %6 = load ptr, ptr %t, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx18 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %7 = load ptr, ptr %arrayidx18, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds i8, ptr %7, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %8 = load float, ptr %arrayidx19, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = fsub float 1.000000e+00, %8 of type:fsub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div = fdiv float 1.000000e+00, %sub of type:fdiv
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv20 = fptosi float %div to i32 of type:fptosi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add = add nsw i32 %nins.0231, %conv20 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %nins.1 = phi i32 [ %add, %if.then16 ], [ %nins.0231, %land.lhs.true ], [ %nins.0231, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2250017
A is not scalable.	B is not scalable.	
RTCostA: 4831874706221999, RTCostB: 36507221999
A is not scalable.	B is not scalable.	
RTCostA: 4831874706221999, RTCostB: 36507221999

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nmat.0234 = phi i32 [ 0, %for.body.lr.ph ], [ %nmat.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ndel.0233 = phi i32 [ 0, %for.body.lr.ph ], [ %ndel.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nins.0231 = phi i32 [ 0, %for.body.lr.ph ], [ %nins.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %.pre257.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load float, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2 = fcmp ult float %4, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc6 = zext i1 %cmp2 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %ndel.1 = add nuw nsw i32 %ndel.0233, %inc6 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not.cmp2 = xor i1 %cmp2, true of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext i1 %not.cmp2 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %nmat.1 = add nuw nsw i32 %nmat.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp9, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx12 = getelementptr inbounds float, ptr %.pre258.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp14 = fcmp ult float %5, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp14, label %for.inc, label %if.then16 of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load ptr, ptr %t, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx18 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %arrayidx18, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds i8, ptr %7, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = load float, ptr %arrayidx19, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub float 1.000000e+00, %8 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv float 1.000000e+00, %sub of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv20 = fptosi float %div to i32 of type:fptosi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = add nsw i32 %nins.0231, %conv20 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %nins.1 = phi i32 [ %add, %if.then16 ], [ %nins.0231, %land.lhs.true ], [ %nins.0231, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 36507221999
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 36507221999

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nmat.0234 = phi i32 [ 0, %for.body.lr.ph ], [ %nmat.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ndel.0233 = phi i32 [ 0, %for.body.lr.ph ], [ %ndel.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nins.0231 = phi i32 [ 0, %for.body.lr.ph ], [ %nins.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %.pre257.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load float, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2 = fcmp ult float %4, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc6 = zext i1 %cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %ndel.1 = add nuw nsw i32 %ndel.0233, %inc6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not.cmp2 = xor i1 %cmp2, true of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext i1 %not.cmp2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %nmat.1 = add nuw nsw i32 %nmat.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp9, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx12 = getelementptr inbounds float, ptr %.pre258.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load float, ptr %arrayidx12, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp14 = fcmp ult float %5, 5.000000e-01 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp14, label %for.inc, label %if.then16 of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %6 = load ptr, ptr %t, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx18 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %arrayidx18, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds i8, ptr %7, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %8 = load float, ptr %arrayidx19, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub float 1.000000e+00, %8 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv float 1.000000e+00, %sub of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv20 = fptosi float %div to i32 of type:fptosi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = add nsw i32 %nins.0231, %conv20 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'EmitConsensusSequence' from emit.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %nins.1 = phi i32 [ %add, %if.then16 ], [ %nins.0231, %land.lhs.true ], [ %nins.0231, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 35
A is scalable.	B is not scalable.	
RTCostA: 76235669413, RTCostB: 36507221999
A is scalable.	B is not scalable.	
RTCostA: 76235669413, RTCostB: 36507221999
LV: Selecting VF: 1 With Cost: 17.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o emulation.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                emulation.c
@@ Instruction =>  %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: WriteProfile' from emulation.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body213.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %71) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi 1, %indvars.iv.next392, ir<1>
    WIDEN-REDUCTION-PHI ir<%nx.0377> = phi ir<0.000000e+00>, ir<%add219>.1
    CLONE ir<%arrayidx216> = getelementptr inbounds ir<%72>, ir<%indvars.iv391>
    CLONE ir<%76> = load ir<%arrayidx216>
    CLONE ir<%arrayidx218> = getelementptr inbounds ir<%76>, ir<%indvars.iv394>
    CLONE ir<%77> = load ir<%arrayidx218>
    CLONE ir<%add219> = fadd ir<%nx.0377>, ir<%77>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count>
    REDUCE ir<%add219>.1 = ir<%nx.0377> + reduce.fadd (ir<%77>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%nx.0377>, ir<%add219>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end222.loopexit>, scalar.ph

ir-bb<for.end222.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add219.lcssa = vp<%6>
}

========== Loop: WriteProfile' from emulation.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body213.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %71) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv391 = phi 1, %indvars.iv.next392, ir<1>
    WIDEN-REDUCTION-PHI ir<%nx.0377> = phi ir<0.000000e+00>, ir<%add219>.1
    CLONE ir<%arrayidx216> = getelementptr inbounds ir<%72>, ir<%indvars.iv391>
    vp<%4> = vector-pointer ir<%arrayidx216>
    WIDEN ir<%76> = load vp<%4>
    REPLICATE ir<%arrayidx218> = getelementptr inbounds ir<%76>, ir<%indvars.iv394>
    REPLICATE ir<%77> = load ir<%arrayidx218>
    WIDEN ir<%add219> = fadd ir<%nx.0377>, ir<%77>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count>
    REDUCE ir<%add219>.1 = ir<%nx.0377> + reduce.fadd (ir<%77>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nx.0377>, ir<%add219>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end222.loopexit>, scalar.ph

ir-bb<for.end222.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add219.lcssa = vp<%7>
}

========== Loop: WriteProfile' from emulation.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body213.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %71) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv391 = phi 1, %indvars.iv.next392, ir<1>
    WIDEN-REDUCTION-PHI ir<%nx.0377> = phi ir<0.000000e+00>, ir<%add219>.1
    CLONE ir<%arrayidx216> = getelementptr inbounds ir<%72>, ir<%indvars.iv391>
    vp<%4> = vector-pointer ir<%arrayidx216>
    WIDEN ir<%76> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%arrayidx218> = getelementptr inbounds ir<%76>, ir<%indvars.iv394>
    REPLICATE ir<%77> = load ir<%arrayidx218>
    WIDEN ir<%add219> = fadd ir<%nx.0377>, ir<%77>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count>
    REDUCE ir<%add219>.1 = ir<%nx.0377> + reduce.fadd (ir<%77>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nx.0377>, ir<%add219>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end222.loopexit>, scalar.ph

ir-bb<for.end222.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add219.lcssa = vp<%7>
}

========== Loop: WriteProfile' from emulation.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body213.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %71) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv391 = phi 1, %indvars.iv.next392, ir<1>
    WIDEN-REDUCTION-PHI ir<%nx.0377> = phi ir<0.000000e+00>, ir<%add219>.1
    CLONE ir<%arrayidx216> = getelementptr inbounds ir<%72>, ir<%indvars.iv391>
    vp<%4> = vector-pointer ir<%arrayidx216>
    WIDEN ir<%76> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%arrayidx218> = getelementptr inbounds ir<%76>, ir<%indvars.iv394>
    WIDEN ir<%77> = load ir<%arrayidx218>
    WIDEN ir<%add219> = fadd ir<%nx.0377>, ir<%77>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count>
    REDUCE ir<%add219>.1 = ir<%nx.0377> + reduce.fadd (ir<%77>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nx.0377>, ir<%add219>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end222.loopexit>, scalar.ph

ir-bb<for.end222.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add219.lcssa = vp<%7>
}


-----------------Function that is being costed:'WriteProfile' from emulation.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv391 = phi i64 [ 1, %for.body213.lr.ph ], [ %indvars.iv.next392, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nx.0377 = phi float [ 0.000000e+00, %for.body213.lr.ph ], [ %add219, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx216 = getelementptr inbounds ptr, ptr %72, i64 %indvars.iv391 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx218 = getelementptr inbounds float, ptr %76, i64 %indvars.iv394 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %77 = load float, ptr %arrayidx218, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add219 = fadd float %nx.0377, %77 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end222.loopexit, label %for.body213 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'WriteProfile' from emulation.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv391 = phi i64 [ 1, %for.body213.lr.ph ], [ %indvars.iv.next392, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nx.0377 = phi float [ 0.000000e+00, %for.body213.lr.ph ], [ %add219, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx216 = getelementptr inbounds ptr, ptr %72, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx218 = getelementptr inbounds float, ptr %76, i64 %indvars.iv394 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %77 = load float, ptr %arrayidx218, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add219 = fadd float %nx.0377, %77 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end222.loopexit, label %for.body213 of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 39728447458, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 39728447458, RTCostB: 15032385529

-----------------Function that is being costed:'WriteProfile' from emulation.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv391 = phi i64 [ 1, %for.body213.lr.ph ], [ %indvars.iv.next392, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nx.0377 = phi float [ 0.000000e+00, %for.body213.lr.ph ], [ %add219, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx216 = getelementptr inbounds ptr, ptr %72, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx218 = getelementptr inbounds float, ptr %76, i64 %indvars.iv394 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 58 for VF 4 For instruction:   %77 = load float, ptr %arrayidx218, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add219 = fadd float %nx.0377, %77 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end222.loopexit, label %for.body213 of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 40802189257, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 40802189257, RTCostB: 15032385529

-----------------Function that is being costed:'WriteProfile' from emulation.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv391 = phi i64 [ 1, %for.body213.lr.ph ], [ %indvars.iv.next392, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nx.0377 = phi float [ 0.000000e+00, %for.body213.lr.ph ], [ %add219, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx216 = getelementptr inbounds ptr, ptr %72, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx218 = getelementptr inbounds float, ptr %76, i64 %indvars.iv394 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %77 = load float, ptr %arrayidx218, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add219 = fadd float %nx.0377, %77 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end222.loopexit, label %for.body213 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529

-----------------Function that is being costed:'WriteProfile' from emulation.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv391 = phi i64 [ 1, %for.body213.lr.ph ], [ %indvars.iv.next392, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nx.0377 = phi float [ 0.000000e+00, %for.body213.lr.ph ], [ %add219, %for.body213 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx216 = getelementptr inbounds ptr, ptr %72, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %76 = load ptr, ptr %arrayidx216, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx218 = getelementptr inbounds float, ptr %76, i64 %indvars.iv394 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %77 = load float, ptr %arrayidx218, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add219 = fadd float %nx.0377, %77 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end222.loopexit, label %for.body213 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 25769803749, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: 25769803749, RTCostB: 15032385529
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fast_algorithms.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                fast_algorithms.c
@@ Instruction =>  %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: P7Viterbi' from fast_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body229.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %69) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv545 = phi 1, %indvars.iv.next546, ir<1>
    WIDEN-REDUCTION-PHI ir<%xme.0531> = phi ir<-987654321>, ir<%spec.select517>
    CLONE ir<%arrayidx231> = getelementptr inbounds ir<%67>, ir<%indvars.iv545>
    CLONE ir<%71> = load ir<%arrayidx231>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%68>, ir<%indvars.iv545>
    CLONE ir<%72> = load ir<%arrayidx233>
    CLONE ir<%add234> = add nsw ir<%72>, ir<%71>
    CLONE ir<%spec.select517> = call @llvm.smax.i32(ir<%add234>, ir<%xme.0531>)
    CLONE ir<%indvars.iv.next546> = add nuw nsw ir<%indvars.iv545>, ir<1>
    CLONE ir<%exitcond549.not> = icmp eq ir<%indvars.iv.next546>, ir<%wide.trip.count548>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%xme.0531>, ir<%spec.select517>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select517.lcssa = vp<%6>
}

========== Loop: P7Viterbi' from fast_algorithms.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body229.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %69) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv545 = phi 1, %indvars.iv.next546, ir<1>
    WIDEN-REDUCTION-PHI ir<%xme.0531> = phi ir<-987654321>, ir<%spec.select517>
    CLONE ir<%arrayidx231> = getelementptr inbounds ir<%67>, ir<%indvars.iv545>
    vp<%4> = vector-pointer ir<%arrayidx231>
    WIDEN ir<%71> = load vp<%4>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%68>, ir<%indvars.iv545>
    vp<%5> = vector-pointer ir<%arrayidx233>
    WIDEN ir<%72> = load vp<%5>
    WIDEN ir<%add234> = add nsw ir<%72>, ir<%71>
    WIDEN-CALL ir<%spec.select517> = call @llvm.smax.i32(ir<%add234>, ir<%xme.0531>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next546> = add nuw nsw ir<%indvars.iv545>, ir<1>
    CLONE ir<%exitcond549.not> = icmp eq ir<%indvars.iv.next546>, ir<%wide.trip.count548>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%xme.0531>, ir<%spec.select517>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select517.lcssa = vp<%8>
}

========== Loop: P7Viterbi' from fast_algorithms.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body229.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %69) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv545 = phi 1, %indvars.iv.next546, ir<1>
    WIDEN-REDUCTION-PHI ir<%xme.0531> = phi ir<-987654321>, ir<%spec.select517>
    CLONE ir<%arrayidx231> = getelementptr inbounds ir<%67>, ir<%indvars.iv545>
    vp<%4> = vector-pointer ir<%arrayidx231>
    WIDEN ir<%71> = load vp<%4>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%68>, ir<%indvars.iv545>
    vp<%5> = vector-pointer ir<%arrayidx233>
    WIDEN ir<%72> = load vp<%5>
    WIDEN ir<%add234> = add nsw ir<%72>, ir<%71>
    WIDEN-CALL ir<%spec.select517> = call @llvm.smax.i32(ir<%add234>, ir<%xme.0531>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next546> = add nuw nsw ir<%indvars.iv545>, ir<1>
    CLONE ir<%exitcond549.not> = icmp eq ir<%indvars.iv.next546>, ir<%wide.trip.count548>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%xme.0531>, ir<%spec.select517>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select517.lcssa = vp<%8>
}


-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225493

-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7Viterbi' from fast_algorithms.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv545 = phi i64 [ 1, %for.body229.preheader ], [ %indvars.iv.next546, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %xme.0531 = phi i32 [ -987654321, %for.body229.preheader ], [ %spec.select517, %for.body229 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx231 = getelementptr inbounds i32, ptr %67, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %71 = load i32, ptr %arrayidx231, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx233 = getelementptr inbounds i32, ptr %68, i64 %indvars.iv545 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %72 = load i32, ptr %arrayidx233, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add234 = add nsw i32 %72, %71 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select517 = call i32 @llvm.smax.i32(i32 %add234, i32 %xme.0531) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next546 = add nuw nsw i64 %indvars.iv545, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond549.not = icmp eq i64 %indvars.iv.next546, %wide.trip.count548 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond549.not, label %for.end241.loopexit, label %for.body229 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612793, RTCostB: 19327352823
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612793, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7Viterbi at line: fast_algorithms.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body229.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %69) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%xme.0531> = phi ir<-987654321>, ir<%spec.select517>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx231> = getelementptr inbounds ir<%67>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx231>
    WIDEN ir<%71> = load vp<%6>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%68>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx233>
    WIDEN ir<%72> = load vp<%7>
    WIDEN ir<%add234> = add nsw ir<%72>, ir<%71>
    WIDEN-CALL ir<%spec.select517> = call @llvm.smax.i32(ir<%add234>, ir<%xme.0531>) (using vector intrinsic)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%xme.0531>, ir<%spec.select517>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select517.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o histogram.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                histogram.c
@@ Instruction =>  %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body54.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 ((-1 * %1) + %0) to i64))<nsw> + ((sext i32 ((-1 * %1) + %0) to i64) smax ((sext i32 %lowbound.3471476 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv444 = phi %24, %indvars.iv.next445, ir<1>
    WIDEN-REDUCTION-PHI ir<%lowcount.0414> = phi ir<0>, ir<%add58>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%23>, ir<%indvars.iv444>
    CLONE ir<%29> = load ir<%arrayidx57>
    CLONE ir<%add58> = add ir<%29>, ir<%lowcount.0414>
    CLONE ir<%indvars.iv.next445> = add nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%cmp53.not.not> = icmp slt ir<%indvars.iv444>, ir<%25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%lowcount.0414>, ir<%add58>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond65.preheader.loopexit>, scalar.ph

ir-bb<for.cond65.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add58.lcssa = vp<%6>
}

========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body54.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 ((-1 * %1) + %0) to i64))<nsw> + ((sext i32 ((-1 * %1) + %0) to i64) smax ((sext i32 %lowbound.3471476 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv444 = phi %24, %indvars.iv.next445, ir<1>
    WIDEN-REDUCTION-PHI ir<%lowcount.0414> = phi ir<0>, ir<%add58>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%23>, ir<%indvars.iv444>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN ir<%29> = load vp<%4>
    WIDEN ir<%add58> = add ir<%29>, ir<%lowcount.0414>
    CLONE ir<%indvars.iv.next445> = add nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%cmp53.not.not> = icmp slt ir<%indvars.iv444>, ir<%25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%lowcount.0414>, ir<%add58>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond65.preheader.loopexit>, scalar.ph

ir-bb<for.cond65.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add58.lcssa = vp<%7>
}

========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body54.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 ((-1 * %1) + %0) to i64))<nsw> + ((sext i32 ((-1 * %1) + %0) to i64) smax ((sext i32 %lowbound.3471476 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv444 = phi %24, %indvars.iv.next445, ir<1>
    WIDEN-REDUCTION-PHI ir<%lowcount.0414> = phi ir<0>, ir<%add58>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%23>, ir<%indvars.iv444>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN ir<%29> = load vp<%4>
    WIDEN ir<%add58> = add ir<%29>, ir<%lowcount.0414>
    CLONE ir<%indvars.iv.next445> = add nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%cmp53.not.not> = icmp slt ir<%indvars.iv444>, ir<%25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%lowcount.0414>, ir<%add58>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond65.preheader.loopexit>, scalar.ph

ir-bb<for.cond65.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add58.lcssa = vp<%7>
}


-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv444 = phi i64 [ %24, %for.body54.lr.ph ], [ %indvars.iv.next445, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lowcount.0414 = phi i32 [ 0, %for.body54.lr.ph ], [ %add58, %for.body54 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx57 = getelementptr inbounds i32, ptr %23, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %29 = load i32, ptr %arrayidx57, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add58 = add nsw i32 %29, %lowcount.0414 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next445 = add nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp53.not.not = icmp slt i64 %indvars.iv444, %25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp53.not.not, label %for.body54, label %for.cond65.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: PrintASCIIHistogram at line: histogram.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body54.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (sext i32 ((-1 * %1) + %0) to i64))<nsw> + ((sext i32 ((-1 * %1) + %0) to i64) smax ((sext i32 %lowbound.3471476 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%lowcount.0414> = phi ir<0>, ir<%add58>
    vp<%4>    = DERIVED-IV ir<%24> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%23>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx57>
    WIDEN ir<%29> = load vp<%6>
    WIDEN ir<%add58> = add ir<%29>, ir<%lowcount.0414>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%lowcount.0414>, ir<%add58>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond65.preheader.loopexit>, scalar.ph

ir-bb<for.cond65.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add58.lcssa = vp<%9>
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 ((-1 * %1) + %2) to i64) + (-1 * ((sext i32 ((-1 * %1) + %2) to i64) smin ((sext i32 %highbound.1481 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv447 = phi %51, %indvars.iv.next448, ir<-1>
    WIDEN-REDUCTION-PHI ir<%highcount.0418> = phi ir<0>, ir<%add73>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%50>, ir<%indvars.iv447>
    CLONE ir<%54> = load ir<%arrayidx72>
    CLONE ir<%add73> = add ir<%54>, ir<%highcount.0418>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<-1>
    CLONE ir<%cmp68.not.not> = icmp sgt ir<%indvars.iv447>, ir<%52>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%highcount.0418>, ir<%add73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end76.loopexit>, scalar.ph

ir-bb<for.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add73.lcssa = vp<%6>
}

========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 ((-1 * %1) + %2) to i64) + (-1 * ((sext i32 ((-1 * %1) + %2) to i64) smin ((sext i32 %highbound.1481 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv447 = phi %51, %indvars.iv.next448, ir<-1>
    WIDEN-REDUCTION-PHI ir<%highcount.0418> = phi ir<0>, ir<%add73>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%50>, ir<%indvars.iv447>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx72>
    WIDEN ir<%54> = load vp<%4>
    WIDEN ir<%add73> = add ir<%54>, ir<%highcount.0418>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<-1>
    CLONE ir<%cmp68.not.not> = icmp sgt ir<%indvars.iv447>, ir<%52>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%highcount.0418>, ir<%add73>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end76.loopexit>, scalar.ph

ir-bb<for.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add73.lcssa = vp<%7>
}

========== Loop: PrintASCIIHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 ((-1 * %1) + %2) to i64) + (-1 * ((sext i32 ((-1 * %1) + %2) to i64) smin ((sext i32 %highbound.1481 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv447 = phi %51, %indvars.iv.next448, ir<-1>
    WIDEN-REDUCTION-PHI ir<%highcount.0418> = phi ir<0>, ir<%add73>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%50>, ir<%indvars.iv447>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx72>
    WIDEN ir<%54> = load vp<%4>
    WIDEN ir<%add73> = add ir<%54>, ir<%highcount.0418>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<-1>
    CLONE ir<%cmp68.not.not> = icmp sgt ir<%indvars.iv447>, ir<%52>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%highcount.0418>, ir<%add73>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end76.loopexit>, scalar.ph

ir-bb<for.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add73.lcssa = vp<%7>
}


-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'PrintASCIIHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv447 = phi i64 [ %51, %for.body69.lr.ph ], [ %indvars.iv.next448, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %highcount.0418 = phi i32 [ 0, %for.body69.lr.ph ], [ %add73, %for.body69 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %50, i64 %indvars.iv447 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %54 = load i32, ptr %arrayidx72, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add73 = add nsw i32 %54, %highcount.0418 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp68.not.not = icmp sgt i64 %indvars.iv447, %52 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp68.not.not, label %for.body69, label %for.end76.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: PrintASCIIHistogram at line: histogram.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 ((-1 * %1) + %2) to i64) + (-1 * ((sext i32 ((-1 * %1) + %2) to i64) smin ((sext i32 %highbound.1481 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)<nsw>))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%highcount.0418> = phi ir<0>, ir<%add73>
    vp<%4>    = DERIVED-IV ir<%51> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%50>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx72>
    WIDEN ir<%54> = load vp<%6>
    WIDEN ir<%add73> = add ir<%54>, ir<%highcount.0418>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%highcount.0418>, ir<%add73>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end76.loopexit>, scalar.ph

ir-bb<for.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add73.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: EVDBasicFit' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %1) + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call3>, ir<%indvars.iv>
    CLONE store ir<0.000000e+00>, ir<%arrayidx>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<0.000000e+00>, ir<%arrayidx6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: EVDBasicFit' from histogram.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %1) + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: EVDBasicFit' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %1) + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'EVDBasicFit' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %call3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx6 = getelementptr inbounds float, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx6, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: EVDBasicFit at line: histogram.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %1) + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call3>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%call>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%6>, ir<0.000000e+00>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: GaussianFitHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %1) + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sqsum.0236> = phi ir<0.000000e+00>, ir<%12>.1
    WIDEN-REDUCTION-PHI ir<%sum.0235> = phi ir<0.000000e+00>, ir<%11>.1
    CLONE ir<%8> = trunc ir<%indvars.iv>
    CLONE ir<%conv> = sitofp ir<%8>
    CLONE ir<%conv3> = fadd ir<%conv>, ir<5.000000e-01>
    CLONE ir<%9> = sub nsw ir<%indvars.iv>, ir<%6>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%9>
    CLONE ir<%10> = load ir<%arrayidx>
    CLONE ir<%conv4> = sitofp ir<%10>
    EMIT vp<%4> = fmul ir<%conv4>, ir<%conv3>
    CLONE ir<%11> = call @llvm.fmuladd.f32(ir<%conv4>, ir<%conv3>, ir<%sum.0235>)
    CLONE ir<%mul> = fmul ir<%conv3>, ir<%conv4>
    EMIT vp<%5> = fmul ir<%mul>, ir<%conv3>
    CLONE ir<%12> = call @llvm.fmuladd.f32(ir<%mul>, ir<%conv3>, ir<%sqsum.0236>)
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%7>, ir<%lftr.wideiv>
    REDUCE ir<%12>.1 = ir<%sqsum.0236> + reduce.fadd (vp<%5>)
    REDUCE ir<%11>.1 = ir<%sum.0235> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sqsum.0236>, ir<%12>.1
  EMIT vp<%9> = compute-reduction-result ir<%sum.0235>, ir<%11>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa269 = vp<%9>
Live-out float %.lcssa268 = vp<%8>
}

========== Loop: GaussianFitHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %1) + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sqsum.0236> = phi ir<0.000000e+00>, ir<%12>.1
    WIDEN-REDUCTION-PHI ir<%sum.0235> = phi ir<0.000000e+00>, ir<%11>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %5, %indvars.iv.next\l" +
    "  ir<%8>, ir<1>
    WIDEN-CAST ir<%conv> = sitofp  ir<%8> to float
    WIDEN ir<%conv3> = fadd ir<%conv>, ir<5.000000e-01>
    CLONE ir<%9> = sub nsw ir<%indvars.iv>, ir<%6>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%9>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%conv4> = sitofp  ir<%10> to float
    EMIT vp<%5> = fmul ir<%conv4>, ir<%conv3>
    WIDEN-CALL ir<%11> = call @llvm.fmuladd.f32(ir<%conv4>, ir<%conv3>, ir<%sum.0235>) (using vector intrinsic)
    WIDEN ir<%mul> = fmul ir<%conv3>, ir<%conv4>
    EMIT vp<%6> = fmul ir<%mul>, ir<%conv3>
    WIDEN-CALL ir<%12> = call @llvm.fmuladd.f32(ir<%mul>, ir<%conv3>, ir<%sqsum.0236>) (using vector intrinsic)
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%7>, ir<%lftr.wideiv>
    REDUCE ir<%12>.1 = ir<%sqsum.0236> + reduce.fadd (vp<%6>)
    REDUCE ir<%11>.1 = ir<%sum.0235> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sqsum.0236>, ir<%12>.1
  EMIT vp<%10> = compute-reduction-result ir<%sum.0235>, ir<%11>.1
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa269 = vp<%10>
Live-out float %.lcssa268 = vp<%9>
}

========== Loop: GaussianFitHistogram' from histogram.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %1) + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sqsum.0236> = phi ir<0.000000e+00>, ir<%12>.1
    WIDEN-REDUCTION-PHI ir<%sum.0235> = phi ir<0.000000e+00>, ir<%11>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %5, %indvars.iv.next\l" +
    "  ir<%8>, ir<1>
    WIDEN-CAST ir<%conv> = sitofp  ir<%8> to float
    WIDEN ir<%conv3> = fadd ir<%conv>, ir<5.000000e-01>
    CLONE ir<%9> = sub nsw ir<%indvars.iv>, ir<%6>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%9>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%conv4> = sitofp  ir<%10> to float
    EMIT vp<%5> = fmul ir<%conv4>, ir<%conv3>
    WIDEN-CALL ir<%11> = call @llvm.fmuladd.f32(ir<%conv4>, ir<%conv3>, ir<%sum.0235>) (using vector intrinsic)
    WIDEN ir<%mul> = fmul ir<%conv3>, ir<%conv4>
    EMIT vp<%6> = fmul ir<%mul>, ir<%conv3>
    WIDEN-CALL ir<%12> = call @llvm.fmuladd.f32(ir<%mul>, ir<%conv3>, ir<%sqsum.0236>) (using vector intrinsic)
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%lftr.wideiv> = trunc ir<%indvars.iv.next>
    CLONE ir<%exitcond.not> = icmp eq ir<%7>, ir<%lftr.wideiv>
    REDUCE ir<%12>.1 = ir<%sqsum.0236> + reduce.fadd (vp<%6>)
    REDUCE ir<%11>.1 = ir<%sum.0235> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sqsum.0236>, ir<%12>.1
  EMIT vp<%10> = compute-reduction-result ir<%sum.0235>, ir<%11>.1
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa269 = vp<%10>
Live-out float %.lcssa268 = vp<%9>
}


-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of 8 for VF 2 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of 8 for VF 2 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of 16 for VF 4 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of 16 for VF 4 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 10
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 42
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 42, CostB * EstimatedWidthA: 48
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 42
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 42, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 42
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 84

-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 21
B VF: 4, EstimatedWidthB: 4, CostB: 42
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'GaussianFitHistogram' from histogram.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sqsum.0236 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %12, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sum.0235 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %11, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %8 = trunc nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv3 = fadd float %conv, 5.000000e-01 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %9 = sub nsw i64 %indvars.iv, %6 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %9 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %10 = load i32, ptr %arrayidx, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv4 = sitofp i32 %10 to float of type:sitofp
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %11 = tail call float @llvm.fmuladd.f32(float %conv4, float %conv3, float %sum.0235) of type:call
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul = fmul float %conv3, %conv4 of type:fmul
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %12 = tail call float @llvm.fmuladd.f32(float %mul, float %conv3, float %sqsum.0236) of type:call
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lftr.wideiv = trunc i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i32 %7, %lftr.wideiv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 30
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 30
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 21
CostA * EstimatedWidthB: 120, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: GaussianFitHistogram at line: histogram.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %1) + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-REDUCTION-PHI ir<%sqsum.0236> = phi ir<0.000000e+00>, ir<%12>
    WIDEN-REDUCTION-PHI ir<%sum.0235> = phi ir<0.000000e+00>, ir<%11>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %5, %indvars.iv.next\l" +
    "  ir<%8>, ir<1>
    vp<%4>    = DERIVED-IV ir<%5> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN-CAST ir<%conv> = sitofp  ir<%8> to float
    WIDEN ir<%conv3> = fadd ir<%conv>, ir<5.000000e-01>
    CLONE ir<%9> = sub nsw vp<%5>, ir<%6>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%9>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN ir<%10> = load vp<%6>
    WIDEN-CAST ir<%conv4> = sitofp  ir<%10> to float
    EMIT vp<%7> = fmul ir<%conv4>, ir<%conv3>
    WIDEN ir<%mul> = fmul ir<%conv3>, ir<%conv4>
    EMIT vp<%8> = fmul ir<%mul>, ir<%conv3>
    REDUCE ir<%12> = ir<%sqsum.0236> + reduce.fadd (vp<%8>)
    REDUCE ir<%11> = ir<%sum.0235> + reduce.fadd (vp<%7>)
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%sqsum.0236>, ir<%12>
  EMIT vp<%12> = compute-reduction-result ir<%sum.0235>, ir<%11>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa269 = vp<%12>
Live-out float %.lcssa268 = vp<%11>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 32
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hmmio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hmmio.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hmmcalibrate.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hmmcalibrate.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hmmsearch.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hmmsearch.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mathsupport.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                mathsupport.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o masks.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                masks.c
@@ Instruction =>  store i32 1, ptr %gep278, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx61.1, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.1) + %spec.select193.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %14, %indvars.iv.next.1, ir<1>
    CLONE ir<%gep278> = getelementptr ir<%invariant.gep277>, ir<%indvars.iv.1>
    CLONE store ir<1>, ir<%gep278>
    CLONE ir<%arrayidx61.1> = getelementptr inbounds ir<%call>, ir<%indvars.iv.1>
    CLONE store ir<1>, ir<%arrayidx61.1>
    CLONE ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<1>
    CLONE ir<%lftr.wideiv.1> = trunc ir<%indvars.iv.next.1>
    CLONE ir<%exitcond.1.not> = icmp eq ir<%15>, ir<%lftr.wideiv.1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end64.1.loopexit>, scalar.ph

ir-bb<for.end64.1.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.1) + %spec.select193.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv.1 = phi %14, %indvars.iv.next.1, ir<1>
    CLONE ir<%gep278> = getelementptr ir<%invariant.gep277>, ir<%indvars.iv.1>
    vp<%4> = vector-pointer ir<%gep278>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx61.1> = getelementptr inbounds ir<%call>, ir<%indvars.iv.1>
    vp<%5> = vector-pointer ir<%arrayidx61.1>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<1>
    CLONE ir<%lftr.wideiv.1> = trunc ir<%indvars.iv.next.1>
    CLONE ir<%exitcond.1.not> = icmp eq ir<%15>, ir<%lftr.wideiv.1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end64.1.loopexit>, scalar.ph

ir-bb<for.end64.1.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv.1 = phi i64 [ %14, %for.body56.preheader.1 ], [ %indvars.iv.next.1, %for.body56.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep278 = getelementptr i32, ptr %invariant.gep277, i64 %indvars.iv.1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep278, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx61.1 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx61.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv.1 = trunc i64 %indvars.iv.next.1 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.1.not = icmp eq i32 %15, %lftr.wideiv.1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.1.not, label %for.end64.1.loopexit, label %for.body56.1 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv.1 = phi i64 [ %14, %for.body56.preheader.1 ], [ %indvars.iv.next.1, %for.body56.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep278 = getelementptr i32, ptr %invariant.gep277, i64 %indvars.iv.1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep278, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx61.1 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx61.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv.1 = trunc i64 %indvars.iv.next.1 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.1.not = icmp eq i32 %15, %lftr.wideiv.1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.1.not, label %for.end64.1.loopexit, label %for.body56.1 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1
LV: Selecting VF: 2 With Cost: 2.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.1) + %spec.select193.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%14> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep278> = getelementptr ir<%invariant.gep277>, vp<%5>
    vp<%6> = vector-pointer ir<%gep278>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx61.1> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx61.1>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end64.1.loopexit>, scalar.ph

ir-bb<for.end64.1.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %gep282, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx93.1, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.1) + %end.3.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv232.1 = phi %28, %indvars.iv.next233.1, ir<1>
    CLONE ir<%gep282> = getelementptr ir<%invariant.gep281>, ir<%indvars.iv232.1>
    CLONE store ir<1>, ir<%gep282>
    CLONE ir<%arrayidx93.1> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.1>
    CLONE store ir<1>, ir<%arrayidx93.1>
    CLONE ir<%indvars.iv.next233.1> = add nsw ir<%indvars.iv232.1>, ir<1>
    CLONE ir<%lftr.wideiv236.1> = trunc ir<%indvars.iv.next233.1>
    CLONE ir<%exitcond237.1.not> = icmp eq ir<%29>, ir<%lftr.wideiv236.1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc98.1.loopexit>, scalar.ph

ir-bb<for.inc98.1.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.1) + %end.3.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv232.1 = phi %28, %indvars.iv.next233.1, ir<1>
    CLONE ir<%gep282> = getelementptr ir<%invariant.gep281>, ir<%indvars.iv232.1>
    vp<%4> = vector-pointer ir<%gep282>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx93.1> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.1>
    vp<%5> = vector-pointer ir<%arrayidx93.1>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next233.1> = add nsw ir<%indvars.iv232.1>, ir<1>
    CLONE ir<%lftr.wideiv236.1> = trunc ir<%indvars.iv.next233.1>
    CLONE ir<%exitcond237.1.not> = icmp eq ir<%29>, ir<%lftr.wideiv236.1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc98.1.loopexit>, scalar.ph

ir-bb<for.inc98.1.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv232.1 = phi i64 [ %28, %for.body88.preheader.1 ], [ %indvars.iv.next233.1, %for.body88.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep282 = getelementptr i32, ptr %invariant.gep281, i64 %indvars.iv232.1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep282, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93.1 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx93.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next233.1 = add nsw i64 %indvars.iv232.1, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv236.1 = trunc i64 %indvars.iv.next233.1 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond237.1.not = icmp eq i32 %29, %lftr.wideiv236.1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond237.1.not, label %for.inc98.1.loopexit, label %for.body88.1 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv232.1 = phi i64 [ %28, %for.body88.preheader.1 ], [ %indvars.iv.next233.1, %for.body88.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep282 = getelementptr i32, ptr %invariant.gep281, i64 %indvars.iv232.1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep282, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93.1 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx93.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next233.1 = add nsw i64 %indvars.iv232.1, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv236.1 = trunc i64 %indvars.iv.next233.1 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond237.1.not = icmp eq i32 %29, %lftr.wideiv236.1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond237.1.not, label %for.inc98.1.loopexit, label %for.body88.1 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1
LV: Selecting VF: 2 With Cost: 2.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.1) + %end.3.1) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%28> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep282> = getelementptr ir<%invariant.gep281>, vp<%5>
    vp<%6> = vector-pointer ir<%gep282>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx93.1> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx93.1>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc98.1.loopexit>, scalar.ph

ir-bb<for.inc98.1.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %gep284, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx61.2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.2) + %spec.select193.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.2 = phi %42, %indvars.iv.next.2, ir<1>
    CLONE ir<%gep284> = getelementptr ir<%invariant.gep283>, ir<%indvars.iv.2>
    CLONE store ir<1>, ir<%gep284>
    CLONE ir<%arrayidx61.2> = getelementptr inbounds ir<%call>, ir<%indvars.iv.2>
    CLONE store ir<1>, ir<%arrayidx61.2>
    CLONE ir<%indvars.iv.next.2> = add nsw ir<%indvars.iv.2>, ir<1>
    CLONE ir<%lftr.wideiv.2> = trunc ir<%indvars.iv.next.2>
    CLONE ir<%exitcond.2.not> = icmp eq ir<%43>, ir<%lftr.wideiv.2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end64.2.loopexit>, scalar.ph

ir-bb<for.end64.2.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.2) + %spec.select193.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv.2 = phi %42, %indvars.iv.next.2, ir<1>
    CLONE ir<%gep284> = getelementptr ir<%invariant.gep283>, ir<%indvars.iv.2>
    vp<%4> = vector-pointer ir<%gep284>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx61.2> = getelementptr inbounds ir<%call>, ir<%indvars.iv.2>
    vp<%5> = vector-pointer ir<%arrayidx61.2>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next.2> = add nsw ir<%indvars.iv.2>, ir<1>
    CLONE ir<%lftr.wideiv.2> = trunc ir<%indvars.iv.next.2>
    CLONE ir<%exitcond.2.not> = icmp eq ir<%43>, ir<%lftr.wideiv.2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end64.2.loopexit>, scalar.ph

ir-bb<for.end64.2.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv.2 = phi i64 [ %42, %for.body56.preheader.2 ], [ %indvars.iv.next.2, %for.body56.2 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep284 = getelementptr i32, ptr %invariant.gep283, i64 %indvars.iv.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep284, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx61.2 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx61.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next.2 = add nsw i64 %indvars.iv.2, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv.2 = trunc i64 %indvars.iv.next.2 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.2.not = icmp eq i32 %43, %lftr.wideiv.2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.2.not, label %for.end64.2.loopexit, label %for.body56.2 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv.2 = phi i64 [ %42, %for.body56.preheader.2 ], [ %indvars.iv.next.2, %for.body56.2 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep284 = getelementptr i32, ptr %invariant.gep283, i64 %indvars.iv.2 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep284, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx61.2 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.2 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx61.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next.2 = add nsw i64 %indvars.iv.2, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv.2 = trunc i64 %indvars.iv.next.2 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.2.not = icmp eq i32 %43, %lftr.wideiv.2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.2.not, label %for.end64.2.loopexit, label %for.body56.2 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1
LV: Selecting VF: 2 With Cost: 2.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.2) + %spec.select193.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%42> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep284> = getelementptr ir<%invariant.gep283>, vp<%5>
    vp<%6> = vector-pointer ir<%gep284>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx61.2> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx61.2>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end64.2.loopexit>, scalar.ph

ir-bb<for.end64.2.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %gep288, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx93.2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.2) + %end.3.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv232.2 = phi %56, %indvars.iv.next233.2, ir<1>
    CLONE ir<%gep288> = getelementptr ir<%invariant.gep287>, ir<%indvars.iv232.2>
    CLONE store ir<1>, ir<%gep288>
    CLONE ir<%arrayidx93.2> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.2>
    CLONE store ir<1>, ir<%arrayidx93.2>
    CLONE ir<%indvars.iv.next233.2> = add nsw ir<%indvars.iv232.2>, ir<1>
    CLONE ir<%lftr.wideiv236.2> = trunc ir<%indvars.iv.next233.2>
    CLONE ir<%exitcond237.2.not> = icmp eq ir<%57>, ir<%lftr.wideiv236.2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc98.2.loopexit>, scalar.ph

ir-bb<for.inc98.2.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.2) + %end.3.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv232.2 = phi %56, %indvars.iv.next233.2, ir<1>
    CLONE ir<%gep288> = getelementptr ir<%invariant.gep287>, ir<%indvars.iv232.2>
    vp<%4> = vector-pointer ir<%gep288>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx93.2> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.2>
    vp<%5> = vector-pointer ir<%arrayidx93.2>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next233.2> = add nsw ir<%indvars.iv232.2>, ir<1>
    CLONE ir<%lftr.wideiv236.2> = trunc ir<%indvars.iv.next233.2>
    CLONE ir<%exitcond237.2.not> = icmp eq ir<%57>, ir<%lftr.wideiv236.2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc98.2.loopexit>, scalar.ph

ir-bb<for.inc98.2.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv232.2 = phi i64 [ %56, %for.body88.preheader.2 ], [ %indvars.iv.next233.2, %for.body88.2 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep288 = getelementptr i32, ptr %invariant.gep287, i64 %indvars.iv232.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep288, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93.2 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx93.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next233.2 = add nsw i64 %indvars.iv232.2, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv236.2 = trunc i64 %indvars.iv.next233.2 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond237.2.not = icmp eq i32 %57, %lftr.wideiv236.2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond237.2.not, label %for.inc98.2.loopexit, label %for.body88.2 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv232.2 = phi i64 [ %56, %for.body88.preheader.2 ], [ %indvars.iv.next233.2, %for.body88.2 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep288 = getelementptr i32, ptr %invariant.gep287, i64 %indvars.iv232.2 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep288, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93.2 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.2 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx93.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next233.2 = add nsw i64 %indvars.iv232.2, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv236.2 = trunc i64 %indvars.iv.next233.2 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond237.2.not = icmp eq i32 %57, %lftr.wideiv236.2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond237.2.not, label %for.inc98.2.loopexit, label %for.body88.2 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1
LV: Selecting VF: 2 With Cost: 2.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.2>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.2) + %end.3.2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%56> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep288> = getelementptr ir<%invariant.gep287>, vp<%5>
    vp<%6> = vector-pointer ir<%gep288>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx93.2> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx93.2>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc98.2.loopexit>, scalar.ph

ir-bb<for.inc98.2.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %gep290, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx61.3, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %gep290, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx61.3, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.3) + %spec.select193.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.3 = phi %70, %indvars.iv.next.3, ir<1>
    CLONE ir<%gep290> = getelementptr ir<%invariant.gep289>, ir<%indvars.iv.3>
    CLONE store ir<1>, ir<%gep290>
    CLONE ir<%arrayidx61.3> = getelementptr inbounds ir<%call>, ir<%indvars.iv.3>
    CLONE store ir<1>, ir<%arrayidx61.3>
    CLONE ir<%indvars.iv.next.3> = add nsw ir<%indvars.iv.3>, ir<1>
    CLONE ir<%lftr.wideiv.3> = trunc ir<%indvars.iv.next.3>
    CLONE ir<%exitcond.3.not> = icmp eq ir<%71>, ir<%lftr.wideiv.3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end64.3.loopexit>, scalar.ph

ir-bb<for.end64.3.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.3) + %spec.select193.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv.3 = phi %70, %indvars.iv.next.3, ir<1>
    CLONE ir<%gep290> = getelementptr ir<%invariant.gep289>, ir<%indvars.iv.3>
    vp<%4> = vector-pointer ir<%gep290>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx61.3> = getelementptr inbounds ir<%call>, ir<%indvars.iv.3>
    vp<%5> = vector-pointer ir<%arrayidx61.3>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next.3> = add nsw ir<%indvars.iv.3>, ir<1>
    CLONE ir<%lftr.wideiv.3> = trunc ir<%indvars.iv.next.3>
    CLONE ir<%exitcond.3.not> = icmp eq ir<%71>, ir<%lftr.wideiv.3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end64.3.loopexit>, scalar.ph

ir-bb<for.end64.3.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv.3 = phi i64 [ %70, %for.body56.preheader.3 ], [ %indvars.iv.next.3, %for.body56.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep290 = getelementptr i32, ptr %invariant.gep289, i64 %indvars.iv.3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep290, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx61.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx61.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next.3 = add nsw i64 %indvars.iv.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv.3 = trunc i64 %indvars.iv.next.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.3.not = icmp eq i32 %71, %lftr.wideiv.3 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.3.not, label %for.end64.3.loopexit, label %for.body56.3 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv.3 = phi i64 [ %70, %for.body56.preheader.3 ], [ %indvars.iv.next.3, %for.body56.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep290 = getelementptr i32, ptr %invariant.gep289, i64 %indvars.iv.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep290, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx61.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx61.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next.3 = add nsw i64 %indvars.iv.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv.3 = trunc i64 %indvars.iv.next.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.3.not = icmp eq i32 %71, %lftr.wideiv.3 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.3.not, label %for.end64.3.loopexit, label %for.body56.3 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv.3 = phi i64 [ %70, %for.body56.preheader.3 ], [ %indvars.iv.next.3, %for.body56.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep290 = getelementptr i32, ptr %invariant.gep289, i64 %indvars.iv.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %gep290, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx61.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %arrayidx61.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next.3 = add nsw i64 %indvars.iv.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv.3 = trunc i64 %indvars.iv.next.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.3.not = icmp eq i32 %71, %lftr.wideiv.3 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.3.not, label %for.end64.3.loopexit, label %for.body56.3 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2
LV: Selecting VF: 4 With Cost: 1.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.0206.3) + %spec.select193.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%70> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep290> = getelementptr ir<%invariant.gep289>, vp<%5>
    vp<%6> = vector-pointer ir<%gep290>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx61.3> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx61.3>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end64.3.loopexit>, scalar.ph

ir-bb<for.end64.3.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %gep294, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx93.3, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %gep294, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx93.3, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.3) + %end.3.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv232.3 = phi %84, %indvars.iv.next233.3, ir<1>
    CLONE ir<%gep294> = getelementptr ir<%invariant.gep293>, ir<%indvars.iv232.3>
    CLONE store ir<1>, ir<%gep294>
    CLONE ir<%arrayidx93.3> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.3>
    CLONE store ir<1>, ir<%arrayidx93.3>
    CLONE ir<%indvars.iv.next233.3> = add nsw ir<%indvars.iv232.3>, ir<1>
    CLONE ir<%lftr.wideiv236.3> = trunc ir<%indvars.iv.next233.3>
    CLONE ir<%exitcond237.3.not> = icmp eq ir<%85>, ir<%lftr.wideiv236.3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc98.3.loopexit>, scalar.ph

ir-bb<for.inc98.3.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.3) + %end.3.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv232.3 = phi %84, %indvars.iv.next233.3, ir<1>
    CLONE ir<%gep294> = getelementptr ir<%invariant.gep293>, ir<%indvars.iv232.3>
    vp<%4> = vector-pointer ir<%gep294>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%arrayidx93.3> = getelementptr inbounds ir<%call>, ir<%indvars.iv232.3>
    vp<%5> = vector-pointer ir<%arrayidx93.3>
    WIDEN store vp<%5>, ir<1>
    CLONE ir<%indvars.iv.next233.3> = add nsw ir<%indvars.iv232.3>, ir<1>
    CLONE ir<%lftr.wideiv236.3> = trunc ir<%indvars.iv.next233.3>
    CLONE ir<%exitcond237.3.not> = icmp eq ir<%85>, ir<%lftr.wideiv236.3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc98.3.loopexit>, scalar.ph

ir-bb<for.inc98.3.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv232.3 = phi i64 [ %84, %for.body88.preheader.3 ], [ %indvars.iv.next233.3, %for.body88.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep294 = getelementptr i32, ptr %invariant.gep293, i64 %indvars.iv232.3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %gep294, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx93.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next233.3 = add nsw i64 %indvars.iv232.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv236.3 = trunc i64 %indvars.iv.next233.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond237.3.not = icmp eq i32 %85, %lftr.wideiv236.3 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond237.3.not, label %for.inc98.3.loopexit, label %for.body88.3 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv232.3 = phi i64 [ %84, %for.body88.preheader.3 ], [ %indvars.iv.next233.3, %for.body88.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep294 = getelementptr i32, ptr %invariant.gep293, i64 %indvars.iv232.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %gep294, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx93.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next233.3 = add nsw i64 %indvars.iv232.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv236.3 = trunc i64 %indvars.iv.next233.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond237.3.not = icmp eq i32 %85, %lftr.wideiv236.3 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond237.3.not, label %for.inc98.3.loopexit, label %for.body88.3 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv232.3 = phi i64 [ %84, %for.body88.preheader.3 ], [ %indvars.iv.next233.3, %for.body88.3 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep294 = getelementptr i32, ptr %invariant.gep293, i64 %indvars.iv232.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %gep294, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx93.3 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv232.3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %arrayidx93.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next233.3 = add nsw i64 %indvars.iv232.3, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv236.3 = trunc i64 %indvars.iv.next233.3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond237.3.not = icmp eq i32 %85, %lftr.wideiv236.3 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond237.3.not, label %for.inc98.3.loopexit, label %for.body88.3 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2
LV: Selecting VF: 4 With Cost: 1.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=1 at function: XNU at line: masks.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader.3>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.2.3) + %end.3.3) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%84> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%gep294> = getelementptr ir<%invariant.gep293>, vp<%5>
    vp<%6> = vector-pointer ir<%gep294>
    WIDEN store vp<%6>, ir<1>
    CLONE ir<%arrayidx93.3> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx93.3>
    WIDEN store vp<%7>, ir<1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc98.3.loopexit>, scalar.ph

ir-bb<for.inc98.3.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body104.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %len) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv242 = phi 1, %indvars.iv.next243, ir<1>
    WIDEN-REDUCTION-PHI ir<%xnum.0216> = phi ir<0>, ir<%xnum.1>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%call>, ir<%indvars.iv242>
    CLONE ir<%95> = load ir<%arrayidx106>
    CLONE ir<%tobool.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then107

  if.then107:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%inc108> = add ir<%xnum.0216>, ir<1>
    CLONE ir<%96> = load ir<@Alphabet_iupac>
    CLONE ir<%97> = trunc ir<%96>
    CLONE ir<%conv110> = add ir<%97>, ir<-1>
    CLONE ir<%arrayidx112> = getelementptr inbounds ir<%dsq>, ir<%indvars.iv242>
    CLONE store ir<%conv110>, ir<%arrayidx112>, vp<%4>
  Successor(s): for.inc114

  for.inc114:
    EMIT vp<%5> = or ir<%tobool.not>, vp<%4>
    BLEND ir<%xnum.1> = ir<%inc108> ir<%xnum.0216>/ir<%tobool.not>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%xnum.0216>, ir<%xnum.1>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end116.loopexit>, scalar.ph

ir-bb<for.end116.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %xnum.1.lcssa = vp<%8>
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body104.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %len) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv242 = phi 1, %indvars.iv.next243, ir<1>
    WIDEN-REDUCTION-PHI ir<%xnum.0216> = phi ir<0>, ir<%xnum.1>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%call>, ir<%indvars.iv242>
    vp<%4> = vector-pointer ir<%arrayidx106>
    WIDEN ir<%95> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then107

  if.then107:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%inc108> = add ir<%xnum.0216>, ir<1>
    REPLICATE ir<%96> = load ir<@Alphabet_iupac>
    WIDEN-CAST ir<%97> = trunc  ir<%96> to i8
    WIDEN ir<%conv110> = add ir<%97>, ir<-1>
    CLONE ir<%arrayidx112> = getelementptr ir<%dsq>, ir<%indvars.iv242>
    vp<%6> = vector-pointer ir<%arrayidx112>
    WIDEN store vp<%6>, ir<%conv110>, vp<%5>
  Successor(s): for.inc114

  for.inc114:
    EMIT vp<%7> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%xnum.1> = ir<%inc108> ir<%xnum.0216>/ir<%tobool.not>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%xnum.0216>, ir<%xnum.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end116.loopexit>, scalar.ph

ir-bb<for.end116.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %xnum.1.lcssa = vp<%10>
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body104.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %len) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv242 = phi 1, %indvars.iv.next243, ir<1>
    WIDEN-REDUCTION-PHI ir<%xnum.0216> = phi ir<0>, ir<%xnum.1>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%call>, ir<%indvars.iv242>
    vp<%4> = vector-pointer ir<%arrayidx106>
    WIDEN ir<%95> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then107

  if.then107:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%inc108> = add ir<%xnum.0216>, ir<1>
    REPLICATE ir<%96> = load ir<@Alphabet_iupac>
    WIDEN-CAST ir<%97> = trunc  ir<%96> to i8
    WIDEN ir<%conv110> = add ir<%97>, ir<-1>
    CLONE ir<%arrayidx112> = getelementptr ir<%dsq>, ir<%indvars.iv242>
    vp<%6> = vector-pointer ir<%arrayidx112>
    WIDEN store vp<%6>, ir<%conv110>, vp<%5>
  Successor(s): for.inc114

  for.inc114:
    EMIT vp<%7> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%xnum.1> = ir<%inc108> ir<%xnum.0216>/ir<%tobool.not>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%xnum.0216>, ir<%xnum.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end116.loopexit>, scalar.ph

ir-bb<for.end116.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %xnum.1.lcssa = vp<%10>
}

========== Loop: XNU' from masks.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body104.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %len) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv242 = phi 1, %indvars.iv.next243, ir<1>
    WIDEN-REDUCTION-PHI ir<%xnum.0216> = phi ir<0>, ir<%xnum.1>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%call>, ir<%indvars.iv242>
    vp<%4> = vector-pointer ir<%arrayidx106>
    WIDEN ir<%95> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then107

  if.then107:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%inc108> = add ir<%xnum.0216>, ir<1>
    WIDEN ir<%96> = load ir<@Alphabet_iupac>
    WIDEN-CAST ir<%97> = trunc  ir<%96> to i8
    WIDEN ir<%conv110> = add ir<%97>, ir<-1>
    CLONE ir<%arrayidx112> = getelementptr ir<%dsq>, ir<%indvars.iv242>
    vp<%6> = vector-pointer ir<%arrayidx112>
    WIDEN store vp<%6>, ir<%conv110>, vp<%5>
  Successor(s): for.inc114

  for.inc114:
    EMIT vp<%7> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%xnum.1> = ir<%inc108> ir<%xnum.0216>/ir<%tobool.not>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%xnum.0216>, ir<%xnum.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end116.loopexit>, scalar.ph

ir-bb<for.end116.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %xnum.1.lcssa = vp<%10>
}


-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width 2 costs: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 12 for VF 4 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width 4 costs: 22
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 8 for VF 8 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width 8 costs: 20
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 163
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 163, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 163
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 163, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 16 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 4 for VF 16 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 3 for VF 16 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 16 for VF 16 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width 16 costs: 20
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 322
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 322, CostB * EstimatedWidthA: 128
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 322
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 322, CostB * EstimatedWidthA: 128

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 49
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 49, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 49
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 49, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv242 = phi i64 [ 1, %for.body104.preheader ], [ %indvars.iv.next243, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %xnum.0216 = phi i32 [ 0, %for.body104.preheader ], [ %xnum.1, %for.inc114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx106 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %95 = load i32, ptr %arrayidx106, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %for.inc114, label %if.then107 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc108 = add nsw i32 %xnum.0216, 1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %96 = load i32, ptr @Alphabet_iupac, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %97 = trunc i32 %96 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv110 = add i8 %97, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx112 = getelementptr inbounds i8, ptr %dsq, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv110, ptr %arrayidx112, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc114 of type:br

-----------------Function that is being costed:'XNU' from masks.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %xnum.1 = phi i32 [ %inc108, %if.then107 ], [ %xnum.0216, %for.body104 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond246.not, label %for.end116.loopexit, label %for.body104 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 89
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 89, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 89
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 89, CostB * EstimatedWidthA: 64
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 6
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o misc.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                misc.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o modelmakers.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                modelmakers.c
@@ Instruction =>  %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: matassign2hmm' from modelmakers.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %0) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%M.0171> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%matassign>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx>
    CLONE ir<%and> = and ir<%2>, ir<1>
    CLONE ir<%spec.select> = add ir<%and>, ir<%M.0171>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%M.0171>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: matassign2hmm' from modelmakers.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %0) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%M.0171> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%matassign>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%and> = and ir<%2>, ir<1>
    WIDEN ir<%spec.select> = add ir<%and>, ir<%M.0171>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%M.0171>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: matassign2hmm' from modelmakers.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %0) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%M.0171> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%matassign>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%and> = and ir<%2>, ir<1>
    WIDEN ir<%spec.select> = add ir<%and>, ir<%M.0171>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%M.0171>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709121, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709121, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 5368709121
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354573

-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 2684354573
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'matassign2hmm' from modelmakers.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %M.0171 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %matassign, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and = and i32 %2, 1 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = add i32 %and, %M.0171 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177317, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177317, RTCostB: 2684354573
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: matassign2hmm at line: modelmakers.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %0) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%M.0171> = phi ir<0>, ir<%spec.select>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%matassign>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%6>
    WIDEN ir<%and> = and ir<%2>, ir<1>
    WIDEN ir<%spec.select> = add ir<%and>, ir<%M.0171>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%M.0171>, ir<%spec.select>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o plan7.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                plan7.c
@@ Instruction =>  %1 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %1, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan7SetNullModel' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null1>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%1>, ir<%arrayidx3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7SetNullModel' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null1>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7SetNullModel' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null1>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan7SetNullModel' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3 = getelementptr inbounds [20 x float], ptr %null1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %1, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan7SetNullModel at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%null>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%5>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null1>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%6>, ir<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan7SWConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%7> = trunc ir<%indvars.iv>
    CLONE ir<%8> = add ir<%7>, ir<-1>
    CLONE ir<%conv54> = sitofp ir<%8>
    CLONE ir<%mul55> = fmul ir<%div49>, ir<%conv54>
    CLONE ir<%conv56> = fpext ir<%mul55>
    CLONE ir<%sub57> = fsub ir<1.000000e+00>, ir<%conv56>
    CLONE ir<%div58> = fdiv ir<%conv52>, ir<%sub57>
    CLONE ir<%conv59> = fptrunc ir<%div58>
    CLONE ir<%arrayidx62> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE store ir<%conv59>, ir<%arrayidx62>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7SWConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv54> = sitofp  ir<%8> to float
    WIDEN ir<%mul55> = fmul ir<%div49>, ir<%conv54>
    WIDEN-CAST ir<%conv56> = fpext  ir<%mul55> to double
    WIDEN ir<%sub57> = fsub ir<1.000000e+00>, ir<%conv56>
    WIDEN ir<%div58> = fdiv ir<%conv52>, ir<%sub57>
    WIDEN-CAST ir<%conv59> = fptrunc  ir<%div58> to float
    CLONE ir<%arrayidx62> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx62>
    WIDEN store vp<%4>, ir<%conv59>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7SWConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv54> = sitofp  ir<%8> to float
    WIDEN ir<%mul55> = fmul ir<%div49>, ir<%conv54>
    WIDEN-CAST ir<%conv56> = fpext  ir<%mul55> to double
    WIDEN ir<%sub57> = fsub ir<1.000000e+00>, ir<%conv56>
    WIDEN ir<%div58> = fdiv ir<%conv52>, ir<%sub57>
    WIDEN-CAST ir<%conv59> = fptrunc  ir<%div58> to float
    CLONE ir<%arrayidx62> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx62>
    WIDEN store vp<%4>, ir<%conv59>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901876, RTCostB: 27917287398
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901876, RTCostB: 27917287398
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of 4 for VF 4 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418246, RTCostB: 27917287398
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418246, RTCostB: 12884901876
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 27917287398
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418246

-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450958, RTCostB: 27917287398
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450958, RTCostB: 10737418246
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan7SWConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv54 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul55 = fmul float %div49, %conv54 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv56 = fpext float %mul55 to double of type:fpext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %sub57 = fsub double 1.000000e+00, %conv56 of type:fsub
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %div58 = fdiv double %conv52, %sub57 of type:fdiv
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %conv59 = fptrunc double %div58 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx62 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %conv59, ptr %arrayidx62, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5100273723, RTCostB: 27917287398
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 5100273723, RTCostB: 6442450958
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan7SWConfig at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv54> = sitofp  ir<%8> to float
    WIDEN ir<%mul55> = fmul ir<%div49>, ir<%conv54>
    WIDEN-CAST ir<%conv56> = fpext  ir<%mul55> to double
    WIDEN ir<%sub57> = fsub ir<1.000000e+00>, ir<%conv56>
    WIDEN ir<%div58> = fdiv ir<%conv52>, ir<%sub57>
    WIDEN-CAST ir<%conv59> = fptrunc  ir<%div58> to float
    CLONE ir<%arrayidx62> = getelementptr inbounds ir<%5>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx62>
    WIDEN store vp<%6>, ir<%conv59>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan7FSConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%7> = trunc ir<%indvars.iv>
    CLONE ir<%8> = add ir<%7>, ir<-1>
    CLONE ir<%conv59> = sitofp ir<%8>
    CLONE ir<%mul60> = fmul ir<%div54>, ir<%conv59>
    CLONE ir<%conv61> = fpext ir<%mul60>
    CLONE ir<%sub62> = fsub ir<1.000000e+00>, ir<%conv61>
    CLONE ir<%div63> = fdiv ir<%conv57>, ir<%sub62>
    CLONE ir<%conv64> = fptrunc ir<%div63>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE store ir<%conv64>, ir<%arrayidx67>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7FSConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv59> = sitofp  ir<%8> to float
    WIDEN ir<%mul60> = fmul ir<%div54>, ir<%conv59>
    WIDEN-CAST ir<%conv61> = fpext  ir<%mul60> to double
    WIDEN ir<%sub62> = fsub ir<1.000000e+00>, ir<%conv61>
    WIDEN ir<%div63> = fdiv ir<%conv57>, ir<%sub62>
    WIDEN-CAST ir<%conv64> = fptrunc  ir<%div63> to float
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%conv64>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan7FSConfig' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv59> = sitofp  ir<%8> to float
    WIDEN ir<%mul60> = fmul ir<%div54>, ir<%conv59>
    WIDEN-CAST ir<%conv61> = fpext  ir<%mul60> to double
    WIDEN ir<%sub62> = fsub ir<1.000000e+00>, ir<%conv61>
    WIDEN ir<%div63> = fdiv ir<%conv57>, ir<%sub62>
    WIDEN-CAST ir<%conv64> = fptrunc  ir<%div63> to float
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%conv64>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901876, RTCostB: 27917287398
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901876, RTCostB: 27917287398
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of 4 for VF 4 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418246, RTCostB: 27917287398
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418246, RTCostB: 12884901876
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 27917287398
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418246

-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450958, RTCostB: 27917287398
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450958, RTCostB: 10737418246
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan7FSConfig' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %7 = trunc i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %8 = add i32 %7, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv59 = sitofp i32 %8 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul60 = fmul float %div54, %conv59 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv61 = fpext float %mul60 to double of type:fpext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %sub62 = fsub double 1.000000e+00, %conv61 of type:fsub
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %div63 = fdiv double %conv57, %sub62 of type:fdiv
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %conv64 = fptrunc double %div63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx67 = getelementptr inbounds float, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %conv64, ptr %arrayidx67, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5100273723, RTCostB: 27917287398
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 5100273723, RTCostB: 6442450958
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan7FSConfig at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %6 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN ir<%8> = add ir<%7>, ir<-1>
    WIDEN-CAST ir<%conv59> = sitofp  ir<%8> to float
    WIDEN ir<%mul60> = fmul ir<%div54>, ir<%conv59>
    WIDEN-CAST ir<%conv61> = fpext  ir<%mul60> to double
    WIDEN ir<%sub62> = fsub ir<1.000000e+00>, ir<%conv61>
    WIDEN ir<%div63> = fdiv ir<%conv57>, ir<%sub62>
    WIDEN-CAST ir<%conv64> = fptrunc  ir<%div63> to float
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%5>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%6>, ir<%conv64>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond63.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv242 = phi 0, %indvars.iv.next243, ir<1>
    CLONE ir<%arrayidx70.us> = getelementptr inbounds ir<%7>, ir<%indvars.iv247>, ir<1>, ir<%indvars.iv242>
    CLONE ir<%11> = load ir<%arrayidx70.us>
    CLONE ir<%arrayidx75.us> = getelementptr inbounds ir<%10>, ir<%indvars.iv242>
    CLONE store ir<%11>, ir<%arrayidx75.us>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond63.for.inc79_crit_edge.us>, scalar.ph

ir-bb<for.cond63.for.inc79_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond63.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv242 = phi 0, %indvars.iv.next243, ir<1>
    CLONE ir<%arrayidx70.us> = getelementptr inbounds ir<%7>, ir<%indvars.iv247>, ir<1>, ir<%indvars.iv242>
    vp<%4> = vector-pointer ir<%arrayidx70.us>
    WIDEN ir<%11> = load vp<%4>
    CLONE ir<%arrayidx75.us> = getelementptr inbounds ir<%10>, ir<%indvars.iv242>
    vp<%5> = vector-pointer ir<%arrayidx75.us>
    WIDEN store vp<%5>, ir<%11>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond63.for.inc79_crit_edge.us>, scalar.ph

ir-bb<for.cond63.for.inc79_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond63.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv242 = phi 0, %indvars.iv.next243, ir<1>
    CLONE ir<%arrayidx70.us> = getelementptr inbounds ir<%7>, ir<%indvars.iv247>, ir<1>, ir<%indvars.iv242>
    vp<%4> = vector-pointer ir<%arrayidx70.us>
    WIDEN ir<%11> = load vp<%4>
    CLONE ir<%arrayidx75.us> = getelementptr inbounds ir<%10>, ir<%indvars.iv242>
    vp<%5> = vector-pointer ir<%arrayidx75.us>
    WIDEN store vp<%5>, ir<%11>
    CLONE ir<%indvars.iv.next243> = add nuw nsw ir<%indvars.iv242>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%indvars.iv.next243>, ir<%wide.trip.count245>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond63.for.inc79_crit_edge.us>, scalar.ph

ir-bb<for.cond63.for.inc79_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv242 = phi i64 [ 0, %for.cond63.preheader.us ], [ %indvars.iv.next243, %for.body65.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx70.us = getelementptr inbounds %struct.basic_state, ptr %7, i64 %indvars.iv247, i32 1, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %11 = load float, ptr %arrayidx70.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx75.us = getelementptr inbounds float, ptr %10, i64 %indvars.iv242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %11, ptr %arrayidx75.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next243 = add nuw nsw i64 %indvars.iv242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond246.not = icmp eq i64 %indvars.iv.next243, %wide.trip.count245 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond246.not, label %for.cond63.for.inc79_crit_edge.us, label %for.body65.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan9toPlan7 at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond63.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx70.us> = getelementptr inbounds ir<%7>, ir<%indvars.iv247>, ir<1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx70.us>
    WIDEN ir<%20> = load vp<%5>
    CLONE ir<%arrayidx75.us> = getelementptr inbounds ir<%14>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx75.us>
    WIDEN store vp<%6>, ir<%20>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond63.for.inc79_crit_edge.us>, scalar.ph

ir-bb<for.cond63.for.inc79_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond86.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %54 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv252 = phi 0, %indvars.iv.next253, ir<1>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%55>, ir<%indvars.iv257>, ir<1>, ir<%indvars.iv252>
    CLONE ir<%58> = load ir<%arrayidx94.us>
    CLONE ir<%arrayidx99.us> = getelementptr inbounds ir<%57>, ir<%indvars.iv252>
    CLONE store ir<%58>, ir<%arrayidx99.us>
    CLONE ir<%indvars.iv.next253> = add nuw nsw ir<%indvars.iv252>, ir<1>
    CLONE ir<%exitcond256.not> = icmp eq ir<%indvars.iv.next253>, ir<%wide.trip.count255>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond86.for.inc103_crit_edge.us>, scalar.ph

ir-bb<for.cond86.for.inc103_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond86.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %54 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv252 = phi 0, %indvars.iv.next253, ir<1>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%55>, ir<%indvars.iv257>, ir<1>, ir<%indvars.iv252>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN ir<%58> = load vp<%4>
    CLONE ir<%arrayidx99.us> = getelementptr inbounds ir<%57>, ir<%indvars.iv252>
    vp<%5> = vector-pointer ir<%arrayidx99.us>
    WIDEN store vp<%5>, ir<%58>
    CLONE ir<%indvars.iv.next253> = add nuw nsw ir<%indvars.iv252>, ir<1>
    CLONE ir<%exitcond256.not> = icmp eq ir<%indvars.iv.next253>, ir<%wide.trip.count255>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond86.for.inc103_crit_edge.us>, scalar.ph

ir-bb<for.cond86.for.inc103_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond86.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %54 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv252 = phi 0, %indvars.iv.next253, ir<1>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%55>, ir<%indvars.iv257>, ir<1>, ir<%indvars.iv252>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN ir<%58> = load vp<%4>
    CLONE ir<%arrayidx99.us> = getelementptr inbounds ir<%57>, ir<%indvars.iv252>
    vp<%5> = vector-pointer ir<%arrayidx99.us>
    WIDEN store vp<%5>, ir<%58>
    CLONE ir<%indvars.iv.next253> = add nuw nsw ir<%indvars.iv252>, ir<1>
    CLONE ir<%exitcond256.not> = icmp eq ir<%indvars.iv.next253>, ir<%wide.trip.count255>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond86.for.inc103_crit_edge.us>, scalar.ph

ir-bb<for.cond86.for.inc103_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv252 = phi i64 [ 0, %for.cond86.preheader.us ], [ %indvars.iv.next253, %for.body88.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx94.us = getelementptr inbounds %struct.basic_state, ptr %55, i64 %indvars.iv257, i32 1, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %58 = load float, ptr %arrayidx94.us, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx99.us = getelementptr inbounds float, ptr %57, i64 %indvars.iv252 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %58, ptr %arrayidx99.us, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next253 = add nuw nsw i64 %indvars.iv252, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond256.not = icmp eq i64 %indvars.iv.next253, %wide.trip.count255 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond256.not, label %for.cond86.for.inc103_crit_edge.us, label %for.body88.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan9toPlan7 at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond86.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %54 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%55>, ir<%indvars.iv257>, ir<1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx94.us>
    WIDEN ir<%67> = load vp<%5>
    CLONE ir<%arrayidx99.us> = getelementptr inbounds ir<%61>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx99.us>
    WIDEN store vp<%6>, ir<%67>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond86.for.inc103_crit_edge.us>, scalar.ph

ir-bb<for.cond86.for.inc103_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %97, ptr %arrayidx126, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %97, ptr %arrayidx126, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %97, ptr %arrayidx126, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %97, ptr %arrayidx126, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %97, ptr %arrayidx126, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body120.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %96 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv262 = phi 0, %indvars.iv.next263, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%null121>, ir<0>, ir<%indvars.iv262>
    CLONE ir<%97> = load ir<%arrayidx123>
    CLONE ir<%arrayidx126> = getelementptr inbounds ir<%null>, ir<0>, ir<%indvars.iv262>
    CLONE store ir<%97>, ir<%arrayidx126>
    CLONE ir<%indvars.iv.next263> = add nuw nsw ir<%indvars.iv262>, ir<1>
    CLONE ir<%exitcond266.not> = icmp eq ir<%indvars.iv.next263>, ir<%wide.trip.count265>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end129.loopexit>, scalar.ph

ir-bb<for.end129.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body120.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %96 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv262 = phi 0, %indvars.iv.next263, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%null121>, ir<0>, ir<%indvars.iv262>
    vp<%4> = vector-pointer ir<%arrayidx123>
    WIDEN ir<%97> = load vp<%4>
    CLONE ir<%arrayidx126> = getelementptr inbounds ir<%null>, ir<0>, ir<%indvars.iv262>
    vp<%5> = vector-pointer ir<%arrayidx126>
    WIDEN store vp<%5>, ir<%97>
    CLONE ir<%indvars.iv.next263> = add nuw nsw ir<%indvars.iv262>, ir<1>
    CLONE ir<%exitcond266.not> = icmp eq ir<%indvars.iv.next263>, ir<%wide.trip.count265>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end129.loopexit>, scalar.ph

ir-bb<for.end129.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Plan9toPlan7' from plan7.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body120.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %96 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv262 = phi 0, %indvars.iv.next263, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%null121>, ir<0>, ir<%indvars.iv262>
    vp<%4> = vector-pointer ir<%arrayidx123>
    WIDEN ir<%97> = load vp<%4>
    CLONE ir<%arrayidx126> = getelementptr inbounds ir<%null>, ir<0>, ir<%indvars.iv262>
    vp<%5> = vector-pointer ir<%arrayidx126>
    WIDEN store vp<%5>, ir<%97>
    CLONE ir<%indvars.iv.next263> = add nuw nsw ir<%indvars.iv262>, ir<1>
    CLONE ir<%exitcond266.not> = icmp eq ir<%indvars.iv.next263>, ir<%wide.trip.count265>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end129.loopexit>, scalar.ph

ir-bb<for.end129.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Plan9toPlan7' from plan7.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv262 = phi i64 [ 0, %for.body120.lr.ph ], [ %indvars.iv.next263, %for.body120 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx123 = getelementptr inbounds [20 x float], ptr %null121, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %97 = load float, ptr %arrayidx123, align 4, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx126 = getelementptr inbounds [20 x float], ptr %null, i64 0, i64 %indvars.iv262 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %97, ptr %arrayidx126, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next263 = add nuw nsw i64 %indvars.iv262, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond266.not = icmp eq i64 %indvars.iv.next263, %wide.trip.count265 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond266.not, label %for.end129.loopexit, label %for.body120 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Plan9toPlan7 at line: plan7.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body120.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %96 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%null121>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx123>
    WIDEN ir<%102> = load vp<%5>
    CLONE ir<%arrayidx126> = getelementptr inbounds ir<%null>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx126>
    WIDEN store vp<%6>, ir<%102>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end129.loopexit>, scalar.ph

ir-bb<for.end129.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o plan9.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                plan9.c
========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    CLONE store ir<0.000000e+00>, ir<%arrayidx>
    CLONE store ir<0.000000e+00>, ir<%arrayidx7>
    CLONE store ir<0.000000e+00>, ir<%arrayidx12>
    CLONE ir<%arrayidx5.1> = getelementptr inbounds ir<%arrayidx>, ir<4>
    CLONE store ir<0.000000e+00>, ir<%arrayidx5.1>
    CLONE ir<%arrayidx10.1> = getelementptr inbounds ir<%arrayidx7>, ir<4>
    CLONE store ir<0.000000e+00>, ir<%arrayidx10.1>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<%arrayidx12>, ir<4>
    CLONE store ir<0.000000e+00>, ir<%arrayidx15.1>
    CLONE ir<%arrayidx5.2> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE store ir<0.000000e+00>, ir<%arrayidx5.2>
    CLONE ir<%arrayidx10.2> = getelementptr inbounds ir<%arrayidx7>, ir<8>
    CLONE store ir<0.000000e+00>, ir<%arrayidx10.2>
    CLONE ir<%arrayidx15.2> = getelementptr inbounds ir<%arrayidx12>, ir<8>
    CLONE store ir<0.000000e+00>, ir<%arrayidx15.2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end41.loopexit86>, scalar.ph

ir-bb<for.end41.loopexit86>:
No successors

scalar.ph:
No successors
}

========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    REPLICATE ir<%arrayidx7> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    REPLICATE ir<%arrayidx12> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx7>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx12>
    REPLICATE ir<%arrayidx5.1> = getelementptr inbounds ir<%arrayidx>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx5.1>
    REPLICATE ir<%arrayidx10.1> = getelementptr inbounds ir<%arrayidx7>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx10.1>
    REPLICATE ir<%arrayidx15.1> = getelementptr inbounds ir<%arrayidx12>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx15.1>
    REPLICATE ir<%arrayidx5.2> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx5.2>
    REPLICATE ir<%arrayidx10.2> = getelementptr inbounds ir<%arrayidx7>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx10.2>
    REPLICATE ir<%arrayidx15.2> = getelementptr inbounds ir<%arrayidx12>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx15.2>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end41.loopexit86>, scalar.ph

ir-bb<for.end41.loopexit86>:
No successors

scalar.ph:
No successors
}

========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%arrayidx7> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%arrayidx12> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx7>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx12>
    WIDEN-GEP Var[Inv] ir<%arrayidx5.1> = getelementptr inbounds ir<%arrayidx>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx5.1>
    WIDEN-GEP Var[Inv] ir<%arrayidx10.1> = getelementptr inbounds ir<%arrayidx7>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx10.1>
    WIDEN-GEP Var[Inv] ir<%arrayidx15.1> = getelementptr inbounds ir<%arrayidx12>, ir<4>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx15.1>
    WIDEN-GEP Var[Inv] ir<%arrayidx5.2> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx5.2>
    WIDEN-GEP Var[Inv] ir<%arrayidx10.2> = getelementptr inbounds ir<%arrayidx7>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx10.2>
    WIDEN-GEP Var[Inv] ir<%arrayidx15.2> = getelementptr inbounds ir<%arrayidx12>, ir<8>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx15.2>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end41.loopexit86>, scalar.ph

ir-bb<for.end41.loopexit86>:
No successors

scalar.ph:
No successors
}

========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%arrayidx7> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%arrayidx12> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<0.000000e+00>
    WIDEN store ir<%arrayidx7>, ir<0.000000e+00>
    WIDEN store ir<%arrayidx12>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx5.1> = getelementptr inbounds ir<%arrayidx>, ir<4>
    WIDEN store ir<%arrayidx5.1>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx10.1> = getelementptr inbounds ir<%arrayidx7>, ir<4>
    WIDEN store ir<%arrayidx10.1>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx15.1> = getelementptr inbounds ir<%arrayidx12>, ir<4>
    WIDEN store ir<%arrayidx15.1>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx5.2> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN store ir<%arrayidx5.2>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx10.2> = getelementptr inbounds ir<%arrayidx7>, ir<8>
    WIDEN store ir<%arrayidx10.2>, ir<0.000000e+00>
    WIDEN-GEP Var[Inv] ir<%arrayidx15.2> = getelementptr inbounds ir<%arrayidx12>, ir<8>
    WIDEN store ir<%arrayidx15.2>, ir<0.000000e+00>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end41.loopexit86>, scalar.ph

ir-bb<for.end41.loopexit86>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Scalar loop costs: 20.
-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Vector loop of width 2 costs: 118

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Vector loop of width 4 costs: 117

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672980
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672980

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 92
A is scalable.	B is not scalable.	
RTCostA: 199179108372, RTCostB: 42949672980
A is scalable.	B is not scalable.	
RTCostA: 199179108372, RTCostB: 42949672980

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader ], [ 0, %for.cond1.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx7 = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx12 = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx7, align 4, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx12, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx5.1 = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx5.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx10.1 = getelementptr inbounds i8, ptr %arrayidx7, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx10.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15.1 = getelementptr inbounds i8, ptr %arrayidx12, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx15.1, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx5.2 = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx5.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx10.2 = getelementptr inbounds i8, ptr %arrayidx7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx10.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15.2 = getelementptr inbounds i8, ptr %arrayidx12, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx15.2, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond, label %for.end41.loopexit86, label %for.cond1.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 91
A is scalable.	B is not scalable.	
RTCostA: 196494753812, RTCostB: 42949672980
A is scalable.	B is not scalable.	
RTCostA: 196494753812, RTCostB: 42949672980
LV: Selecting VF: 1 With Cost: 20.
maxbefore: 2
maxafter: 2
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx23.us> = getelementptr inbounds ir<%1>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    CLONE store ir<0.000000e+00>, ir<%arrayidx23.us>
    CLONE ir<%arrayidx29.us> = getelementptr inbounds ir<%2>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    CLONE store ir<0.000000e+00>, ir<%arrayidx29.us>
    CLONE ir<%arrayidx35.us> = getelementptr inbounds ir<%3>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    CLONE store ir<0.000000e+00>, ir<%arrayidx35.us>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond16.for.inc39_crit_edge.us>, scalar.ph

ir-bb<for.cond16.for.inc39_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx23.us> = getelementptr inbounds ir<%1>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%4> = vector-pointer ir<%arrayidx23.us>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx29.us> = getelementptr inbounds ir<%2>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%5> = vector-pointer ir<%arrayidx29.us>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%arrayidx35.us> = getelementptr inbounds ir<%3>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%6> = vector-pointer ir<%arrayidx35.us>
    WIDEN store vp<%6>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond16.for.inc39_crit_edge.us>, scalar.ph

ir-bb<for.cond16.for.inc39_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: P9ZeroHMM' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx23.us> = getelementptr inbounds ir<%1>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%4> = vector-pointer ir<%arrayidx23.us>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx29.us> = getelementptr inbounds ir<%2>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%5> = vector-pointer ir<%arrayidx29.us>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%arrayidx35.us> = getelementptr inbounds ir<%3>, ir<%indvars.iv80>, ir<1>, ir<%indvars.iv75>
    vp<%6> = vector-pointer ir<%arrayidx35.us>
    WIDEN store vp<%6>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond16.for.inc39_crit_edge.us>, scalar.ph

ir-bb<for.cond16.for.inc39_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709123, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709123, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354579, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354579, RTCostB: 5368709123
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354579

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354579, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354579, RTCostB: 2684354579
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P9ZeroHMM' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next76, %for.body18.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx23.us = getelementptr inbounds %struct.basic_state, ptr %1, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx23.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx29.us = getelementptr inbounds %struct.basic_state, ptr %2, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx29.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx35.us = getelementptr inbounds %struct.basic_state, ptr %3, i64 %indvars.iv80, i32 1, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx35.us, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond79.not, label %for.cond16.for.inc39_crit_edge.us, label %for.body18.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177331, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177331, RTCostB: 2684354579
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P9ZeroHMM at line: plan9.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx23.us> = getelementptr inbounds ir<%1>, ir<%indvars.iv80>, ir<1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx23.us>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%arrayidx29.us> = getelementptr inbounds ir<%3>, ir<%indvars.iv80>, ir<1>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx29.us>
    WIDEN store vp<%6>, ir<0.000000e+00>
    CLONE ir<%arrayidx35.us> = getelementptr inbounds ir<%5>, ir<%indvars.iv80>, ir<1>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx35.us>
    WIDEN store vp<%7>, ir<0.000000e+00>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond16.for.inc39_crit_edge.us>, scalar.ph

ir-bb<for.cond16.for.inc39_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body8.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    CLONE store ir<2.500000e-01>, ir<%arrayidx10>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end15.loopexit36>, scalar.ph

ir-bb<if.end15.loopexit36>:
No successors

scalar.ph:
No successors
}

========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body8.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%4>, ir<2.500000e-01>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end15.loopexit36>, scalar.ph

ir-bb<if.end15.loopexit36>:
No successors

scalar.ph:
No successors
}

========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body8.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%4>, ir<2.500000e-01>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end15.loopexit36>, scalar.ph

ir-bb<if.end15.loopexit36>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1610612745

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body8.preheader ], [ %indvars.iv.next, %for.body8 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 2.500000e-01, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end15.loopexit36, label %for.body8 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306393, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306393, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P9DefaultNullModel at line: plan9.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body8.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%5>, ir<2.500000e-01>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end15.loopexit36>, scalar.ph

ir-bb<if.end15.loopexit36>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %22 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %22, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %22, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %22, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %22 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %22, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %22, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %21 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv30 = phi 0, %indvars.iv.next31, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv30>
    CLONE ir<%22> = load ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv30>
    CLONE store ir<%22>, ir<%arrayidx3>
    CLONE ir<%indvars.iv.next31> = add nuw nsw ir<%indvars.iv30>, ir<1>
    CLONE ir<%exitcond34.not> = icmp eq ir<%indvars.iv.next31>, ir<%wide.trip.count33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end15.loopexit>, scalar.ph

ir-bb<if.end15.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %21 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv30 = phi 0, %indvars.iv.next31, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv30>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%22> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv30>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%22>
    CLONE ir<%indvars.iv.next31> = add nuw nsw ir<%indvars.iv30>, ir<1>
    CLONE ir<%exitcond34.not> = icmp eq ir<%indvars.iv.next31>, ir<%wide.trip.count33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end15.loopexit>, scalar.ph

ir-bb<if.end15.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P9DefaultNullModel' from plan9.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %21 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv30 = phi 0, %indvars.iv.next31, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv30>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%22> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv30>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%22>
    CLONE ir<%indvars.iv.next31> = add nuw nsw ir<%indvars.iv30>, ir<1>
    CLONE ir<%exitcond34.not> = icmp eq ir<%indvars.iv.next31>, ir<%wide.trip.count33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end15.loopexit>, scalar.ph

ir-bb<if.end15.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P9DefaultNullModel' from plan9.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv30 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next31, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %22 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv30 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %22, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond34.not = icmp eq i64 %indvars.iv.next31, %wide.trip.count33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond34.not, label %if.end15.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P9DefaultNullModel at line: plan9.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %21 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%26> = load vp<%5>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%6>, ir<%26>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end15.loopexit>, scalar.ph

ir-bb<if.end15.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o postprob.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                postprob.c
@@ Instruction =>  store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: P7FillOptimalAccuracy' from postprob.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %M) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx15>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx18>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    CLONE store ir<-987654321>, ir<%arrayidx21>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7FillOptimalAccuracy' from postprob.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %M) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7FillOptimalAccuracy' from postprob.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %M) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%4>, ir<-987654321>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 17179869184
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 17179869184
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 17179869184
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869184
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 17179869184
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7FillOptimalAccuracy' from postprob.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx15, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx18 = getelementptr inbounds i32, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx18, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -987654321, ptr %arrayidx21, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 17179869184
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177280, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7FillOptimalAccuracy at line: postprob.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %M) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<%5>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%5>, ir<-987654321>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%7>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%6>, ir<-987654321>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%9>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%7>, ir<-987654321>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o prior.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                prior.c
@@ Instruction =>  store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    CLONE store ir<%conv8>, ir<%arrayidx10>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}

========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%4>, ir<%conv8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}

========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%4>, ir<%conv8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1610612745

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body6.lr.ph ], [ %indvars.iv.next, %for.body6 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx10 = getelementptr inbounds float, ptr %null, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %conv8, ptr %arrayidx10, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body6 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306393, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306393, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7DefaultNullModel at line: prior.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx10> = getelementptr inbounds ir<%null>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx10>
    WIDEN store vp<%5>, ir<%conv8>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %21 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %21, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %21, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %21, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %21 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %21, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load float, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %21, ptr %arrayidx3, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv29>
    CLONE ir<%21> = load ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv29>
    CLONE store ir<%21>, ir<%arrayidx3>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv29>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%21> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv29>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%21>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7DefaultNullModel' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, ir<%indvars.iv29>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%21> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, ir<%indvars.iv29>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%21>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'P7DefaultNullModel' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [0 x float], ptr @aafq, i64 0, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %21 = load float, ptr %arrayidx, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3 = getelementptr inbounds float, ptr %null, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %21, ptr %arrayidx3, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7DefaultNullModel at line: prior.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@aafq>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%25> = load vp<%5>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%null>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%6>, ir<%25>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us205>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %12) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv238 = phi %indvars.iv.next239, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us207> = phi ir<0.000000e+00>, ir<%add97.us>.1
    CLONE ir<%arrayidx76.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv238>
    CLONE ir<%22> = load ir<%arrayidx76.us>
    CLONE ir<%arrayidx81.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>
    CLONE ir<%arrayidx83.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>, ir<%indvars.iv247>
    CLONE ir<%23> = load ir<%arrayidx83.us>
    CLONE ir<%add84.us> = fadd ir<%21>, ir<%23>
    CLONE ir<%mul85.us> = fmul ir<%22>, ir<%add84.us>
    CLONE ir<%arrayidx89.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<12>
    CLONE ir<%24> = load ir<%arrayidx89.us>
    CLONE ir<%add90.us> = fadd ir<%add44>, ir<%24>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<16>
    CLONE ir<%25> = load ir<%arrayidx94.us>
    CLONE ir<%add95.us> = fadd ir<%add90.us>, ir<%25>
    CLONE ir<%div96.us> = fdiv ir<%mul85.us>, ir<%add95.us>
    CLONE ir<%add97.us> = fadd ir<%xi.0203.us207>, ir<%div96.us>
    CLONE ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond243.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count242>
    REDUCE ir<%add97.us>.1 = ir<%xi.0203.us207> + reduce.fadd (ir<%div96.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%xi.0203.us207>, ir<%add97.us>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end124.loopexit255>, scalar.ph

ir-bb<for.end124.loopexit255>:
No successors

scalar.ph:
No successors

Live-out float %add97.us.lcssa = vp<%6>
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us205>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %12) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv238 = phi %indvars.iv.next239, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us207> = phi ir<0.000000e+00>, ir<%add97.us>.1
    CLONE ir<%arrayidx76.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv238>
    vp<%4> = vector-pointer ir<%arrayidx76.us>
    WIDEN ir<%22> = load vp<%4>
    CLONE ir<%arrayidx81.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>
    CLONE ir<%arrayidx83.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>, ir<%indvars.iv247>
    INTERLEAVE-GROUP with factor 7 at %23, ir<%arrayidx83.us>
      ir<%23> = load from index 0
    WIDEN ir<%add84.us> = fadd ir<%21>, ir<%23>
    WIDEN ir<%mul85.us> = fmul ir<%22>, ir<%add84.us>
    CLONE ir<%arrayidx89.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<12>
    INTERLEAVE-GROUP with factor 7 at %24, ir<%arrayidx89.us>
      ir<%24> = load from index 0
      ir<%25> = load from index 1
    WIDEN ir<%add90.us> = fadd ir<%add44>, ir<%24>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<16>
    WIDEN ir<%add95.us> = fadd ir<%add90.us>, ir<%25>
    WIDEN ir<%div96.us> = fdiv ir<%mul85.us>, ir<%add95.us>
    WIDEN ir<%add97.us> = fadd ir<%xi.0203.us207>, ir<%div96.us>
    CLONE ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond243.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count242>
    REDUCE ir<%add97.us>.1 = ir<%xi.0203.us207> + reduce.fadd (ir<%div96.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us207>, ir<%add97.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us205>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %12) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv238 = phi %indvars.iv.next239, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us207> = phi ir<0.000000e+00>, ir<%add97.us>.1
    CLONE ir<%arrayidx76.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv238>
    vp<%4> = vector-pointer ir<%arrayidx76.us>
    WIDEN ir<%22> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx81.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx83.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>, ir<%indvars.iv247>
    REPLICATE ir<%23> = load ir<%arrayidx83.us>
    WIDEN ir<%add84.us> = fadd ir<%21>, ir<%23>
    WIDEN ir<%mul85.us> = fmul ir<%22>, ir<%add84.us>
    WIDEN-GEP Var[Inv] ir<%arrayidx89.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<12>
    REPLICATE ir<%24> = load ir<%arrayidx89.us>
    WIDEN ir<%add90.us> = fadd ir<%add44>, ir<%24>
    WIDEN-GEP Var[Inv] ir<%arrayidx94.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<16>
    REPLICATE ir<%25> = load ir<%arrayidx94.us>
    WIDEN ir<%add95.us> = fadd ir<%add90.us>, ir<%25>
    WIDEN ir<%div96.us> = fdiv ir<%mul85.us>, ir<%add95.us>
    WIDEN ir<%add97.us> = fadd ir<%xi.0203.us207>, ir<%div96.us>
    WIDEN ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond243.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count242>
    REDUCE ir<%add97.us>.1 = ir<%xi.0203.us207> + reduce.fadd (ir<%div96.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us207>, ir<%add97.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us205>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %12) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv238 = phi %indvars.iv.next239, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us207> = phi ir<0.000000e+00>, ir<%add97.us>.1
    CLONE ir<%arrayidx76.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv238>
    vp<%4> = vector-pointer ir<%arrayidx76.us>
    WIDEN ir<%22> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx81.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx83.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv238>, ir<%indvars.iv247>
    WIDEN ir<%23> = load ir<%arrayidx83.us>
    WIDEN ir<%add84.us> = fadd ir<%21>, ir<%23>
    WIDEN ir<%mul85.us> = fmul ir<%22>, ir<%add84.us>
    WIDEN-GEP Var[Inv] ir<%arrayidx89.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<12>
    WIDEN ir<%24> = load ir<%arrayidx89.us>
    WIDEN ir<%add90.us> = fadd ir<%add44>, ir<%24>
    WIDEN-GEP Var[Inv] ir<%arrayidx94.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<16>
    WIDEN ir<%25> = load ir<%arrayidx94.us>
    WIDEN ir<%add95.us> = fadd ir<%add90.us>, ir<%25>
    WIDEN ir<%div96.us> = fdiv ir<%mul85.us>, ir<%add95.us>
    WIDEN ir<%add97.us> = fadd ir<%xi.0203.us207>, ir<%div96.us>
    WIDEN ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond243.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count242>
    REDUCE ir<%add97.us>.1 = ir<%xi.0203.us207> + reduce.fadd (ir<%div96.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us207>, ir<%add97.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx94.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 6 for VF 2 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 35433480177, RTCostB: 38654705646
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 35433480177, RTCostB: 38654705646
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 17 for VF 4 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 30 for VF 4 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 38117834735, RTCostB: 38654705646
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 38117834735, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Vector loop of width vscale x 2 costs: 34
A is scalable.	B is not scalable.	
RTCostA: 73551314861, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 73551314861, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv238 = phi i64 [ %indvars.iv.next239, %for.body56.us206 ], [ 0, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %xi.0203.us207 = phi float [ %add97.us, %for.body56.us206 ], [ 0.000000e+00, %for.body56.lr.ph.split.us205 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx76.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %22 = load float, ptr %arrayidx76.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx81.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx83.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv238, i64 %indvars.iv247 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %23 = load float, ptr %arrayidx83.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add84.us = fadd float %21, %23 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul85.us = fmul float %22, %add84.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx89.us = getelementptr inbounds i8, ptr %arrayidx81.us, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 162 for VF vscale x 4 For instruction:   %24 = load float, ptr %arrayidx89.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add90.us = fadd float %add44, %24 of type:fadd
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %25 = load float, ptr %arrayidx94.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add95.us = fadd float %add90.us, %25 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div96.us = fdiv float %mul85.us, %add95.us of type:fdiv
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add97.us = fadd float %xi.0203.us207, %div96.us of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond243.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count242 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond243.not, label %for.end124.loopexit255, label %for.body56.us206 of type:br
LV: Vector loop of width vscale x 4 costs: 32
A is scalable.	B is not scalable.	
RTCostA: 70330089336, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 70330089336, RTCostB: 35433480177
LV: Selecting VF: 2 With Cost: 16.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=2 at function: P7PriorifyTransitionVector at line: prior.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us205>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %12) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us207> = phi ir<0.000000e+00>, ir<%add97.us>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx76.us> = getelementptr inbounds ir<%mix>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx76.us>
    WIDEN ir<%22> = load vp<%5>
    CLONE ir<%arrayidx81.us> = getelementptr inbounds ir<%t103>, ir<0>, vp<%4>
    CLONE ir<%arrayidx83.us> = getelementptr inbounds ir<%t103>, ir<0>, vp<%4>, ir<%indvars.iv247>
    INTERLEAVE-GROUP with factor 7 at %23, ir<%arrayidx83.us>
      ir<%23> = load from index 0
    WIDEN ir<%add84.us> = fadd ir<%21>, ir<%23>
    WIDEN ir<%mul85.us> = fmul ir<%22>, ir<%add84.us>
    CLONE ir<%arrayidx89.us> = getelementptr inbounds ir<%arrayidx81.us>, ir<12>
    INTERLEAVE-GROUP with factor 7 at %24, ir<%arrayidx89.us>
      ir<%24> = load from index 0
      ir<%25> = load from index 1
    WIDEN ir<%add90.us> = fadd ir<%add44>, ir<%24>
    WIDEN ir<%add95.us> = fadd ir<%add90.us>, ir<%25>
    WIDEN ir<%div96.us> = fdiv ir<%mul85.us>, ir<%add95.us>
    REDUCE ir<%add97.us> = ir<%xi.0203.us207> + reduce.fadd (ir<%div96.us>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%xi.0203.us207>, ir<%add97.us>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us215>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %13) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv235 = phi %indvars.iv.next236, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us217> = phi ir<0.000000e+00>, ir<%add121.us>.1
    CLONE ir<%arrayidx100.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv235>
    CLONE ir<%58> = load ir<%arrayidx100.us>
    CLONE ir<%arrayidx105.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>
    CLONE ir<%arrayidx107.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>, ir<%indvars.iv247>
    CLONE ir<%59> = load ir<%arrayidx107.us>
    CLONE ir<%add108.us> = fadd ir<%57>, ir<%59>
    CLONE ir<%mul109.us> = fmul ir<%58>, ir<%add108.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<20>
    CLONE ir<%60> = load ir<%arrayidx113.us>
    CLONE ir<%add114.us> = fadd ir<%add47>, ir<%60>
    CLONE ir<%arrayidx118.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<24>
    CLONE ir<%61> = load ir<%arrayidx118.us>
    CLONE ir<%add119.us> = fadd ir<%add114.us>, ir<%61>
    CLONE ir<%div120.us> = fdiv ir<%mul109.us>, ir<%add119.us>
    CLONE ir<%add121.us> = fadd ir<%xi.0203.us217>, ir<%div120.us>
    CLONE ir<%indvars.iv.next236> = add nuw nsw ir<%indvars.iv235>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next236>, ir<%wide.trip.count>
    REDUCE ir<%add121.us>.1 = ir<%xi.0203.us217> + reduce.fadd (ir<%div120.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%xi.0203.us217>, ir<%add121.us>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end124.loopexit256>, scalar.ph

ir-bb<for.end124.loopexit256>:
No successors

scalar.ph:
No successors

Live-out float %add121.us.lcssa = vp<%6>
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us215>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %13) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv235 = phi %indvars.iv.next236, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us217> = phi ir<0.000000e+00>, ir<%add121.us>.1
    CLONE ir<%arrayidx100.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv235>
    vp<%4> = vector-pointer ir<%arrayidx100.us>
    WIDEN ir<%58> = load vp<%4>
    CLONE ir<%arrayidx105.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>
    CLONE ir<%arrayidx107.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>, ir<%indvars.iv247>
    INTERLEAVE-GROUP with factor 7 at %59, ir<%arrayidx107.us>
      ir<%59> = load from index 0
    WIDEN ir<%add108.us> = fadd ir<%57>, ir<%59>
    WIDEN ir<%mul109.us> = fmul ir<%58>, ir<%add108.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<20>
    INTERLEAVE-GROUP with factor 7 at %60, ir<%arrayidx113.us>
      ir<%60> = load from index 0
      ir<%61> = load from index 1
    WIDEN ir<%add114.us> = fadd ir<%add47>, ir<%60>
    CLONE ir<%arrayidx118.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<24>
    WIDEN ir<%add119.us> = fadd ir<%add114.us>, ir<%61>
    WIDEN ir<%div120.us> = fdiv ir<%mul109.us>, ir<%add119.us>
    WIDEN ir<%add121.us> = fadd ir<%xi.0203.us217>, ir<%div120.us>
    CLONE ir<%indvars.iv.next236> = add nuw nsw ir<%indvars.iv235>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next236>, ir<%wide.trip.count>
    REDUCE ir<%add121.us>.1 = ir<%xi.0203.us217> + reduce.fadd (ir<%div120.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us217>, ir<%add121.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us215>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %13) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv235 = phi %indvars.iv.next236, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us217> = phi ir<0.000000e+00>, ir<%add121.us>.1
    CLONE ir<%arrayidx100.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv235>
    vp<%4> = vector-pointer ir<%arrayidx100.us>
    WIDEN ir<%58> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx105.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx107.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>, ir<%indvars.iv247>
    REPLICATE ir<%59> = load ir<%arrayidx107.us>
    WIDEN ir<%add108.us> = fadd ir<%57>, ir<%59>
    WIDEN ir<%mul109.us> = fmul ir<%58>, ir<%add108.us>
    WIDEN-GEP Var[Inv] ir<%arrayidx113.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<20>
    REPLICATE ir<%60> = load ir<%arrayidx113.us>
    WIDEN ir<%add114.us> = fadd ir<%add47>, ir<%60>
    WIDEN-GEP Var[Inv] ir<%arrayidx118.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<24>
    REPLICATE ir<%61> = load ir<%arrayidx118.us>
    WIDEN ir<%add119.us> = fadd ir<%add114.us>, ir<%61>
    WIDEN ir<%div120.us> = fdiv ir<%mul109.us>, ir<%add119.us>
    WIDEN ir<%add121.us> = fadd ir<%xi.0203.us217>, ir<%div120.us>
    WIDEN ir<%indvars.iv.next236> = add nuw nsw ir<%indvars.iv235>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next236>, ir<%wide.trip.count>
    REDUCE ir<%add121.us>.1 = ir<%xi.0203.us217> + reduce.fadd (ir<%div120.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us217>, ir<%add121.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: P7PriorifyTransitionVector' from prior.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us215>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %13) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv235 = phi %indvars.iv.next236, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us217> = phi ir<0.000000e+00>, ir<%add121.us>.1
    CLONE ir<%arrayidx100.us> = getelementptr inbounds ir<%mix>, ir<0>, ir<%indvars.iv235>
    vp<%4> = vector-pointer ir<%arrayidx100.us>
    WIDEN ir<%58> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx105.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx107.us> = getelementptr inbounds ir<%t103>, ir<0>, ir<%indvars.iv235>, ir<%indvars.iv247>
    WIDEN ir<%59> = load ir<%arrayidx107.us>
    WIDEN ir<%add108.us> = fadd ir<%57>, ir<%59>
    WIDEN ir<%mul109.us> = fmul ir<%58>, ir<%add108.us>
    WIDEN-GEP Var[Inv] ir<%arrayidx113.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<20>
    WIDEN ir<%60> = load ir<%arrayidx113.us>
    WIDEN ir<%add114.us> = fadd ir<%add47>, ir<%60>
    WIDEN-GEP Var[Inv] ir<%arrayidx118.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<24>
    WIDEN ir<%61> = load ir<%arrayidx118.us>
    WIDEN ir<%add119.us> = fadd ir<%add114.us>, ir<%61>
    WIDEN ir<%div120.us> = fdiv ir<%mul109.us>, ir<%add119.us>
    WIDEN ir<%add121.us> = fadd ir<%xi.0203.us217>, ir<%div120.us>
    WIDEN ir<%indvars.iv.next236> = add nuw nsw ir<%indvars.iv235>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next236>, ir<%wide.trip.count>
    REDUCE ir<%add121.us>.1 = ir<%xi.0203.us217> + reduce.fadd (ir<%div120.us>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%xi.0203.us217>, ir<%add121.us>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx118.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 6 for VF 2 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 35433480177, RTCostB: 38654705646
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 35433480177, RTCostB: 38654705646
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 17 for VF 4 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 30 for VF 4 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 38117834735, RTCostB: 38654705646
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 38117834735, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Vector loop of width vscale x 2 costs: 34
A is scalable.	B is not scalable.	
RTCostA: 73551314861, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 73551314861, RTCostB: 35433480177

-----------------Function that is being costed:'P7PriorifyTransitionVector' from prior.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv235 = phi i64 [ %indvars.iv.next236, %for.body56.us216 ], [ 0, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %xi.0203.us217 = phi float [ %add121.us, %for.body56.us216 ], [ 0.000000e+00, %for.body56.lr.ph.split.us215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx100.us = getelementptr inbounds [200 x float], ptr %mix, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %58 = load float, ptr %arrayidx100.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx105.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx107.us = getelementptr inbounds [200 x [7 x float]], ptr %t103, i64 0, i64 %indvars.iv235, i64 %indvars.iv247 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %59 = load float, ptr %arrayidx107.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add108.us = fadd float %57, %59 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul109.us = fmul float %58, %add108.us of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx113.us = getelementptr inbounds i8, ptr %arrayidx105.us, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 162 for VF vscale x 4 For instruction:   %60 = load float, ptr %arrayidx113.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add114.us = fadd float %add47, %60 of type:fadd
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %61 = load float, ptr %arrayidx118.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add119.us = fadd float %add114.us, %61 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div120.us = fdiv float %mul109.us, %add119.us of type:fdiv
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add121.us = fadd float %xi.0203.us217, %div120.us of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next236 = add nuw nsw i64 %indvars.iv235, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next236, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end124.loopexit256, label %for.body56.us216 of type:br
LV: Vector loop of width vscale x 4 costs: 32
A is scalable.	B is not scalable.	
RTCostA: 70330089336, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 70330089336, RTCostB: 35433480177
LV: Selecting VF: 2 With Cost: 16.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=2 at function: P7PriorifyTransitionVector at line: prior.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.lr.ph.split.us215>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %13) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%xi.0203.us217> = phi ir<0.000000e+00>, ir<%add121.us>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx100.us> = getelementptr inbounds ir<%mix>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx100.us>
    WIDEN ir<%58> = load vp<%5>
    CLONE ir<%arrayidx105.us> = getelementptr inbounds ir<%t103>, ir<0>, vp<%4>
    CLONE ir<%arrayidx107.us> = getelementptr inbounds ir<%t103>, ir<0>, vp<%4>, ir<%indvars.iv247>
    INTERLEAVE-GROUP with factor 7 at %59, ir<%arrayidx107.us>
      ir<%59> = load from index 0
    WIDEN ir<%add108.us> = fadd ir<%57>, ir<%59>
    WIDEN ir<%mul109.us> = fmul ir<%58>, ir<%add108.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%arrayidx105.us>, ir<20>
    INTERLEAVE-GROUP with factor 7 at %60, ir<%arrayidx113.us>
      ir<%60> = load from index 0
      ir<%61> = load from index 1
    WIDEN ir<%add114.us> = fadd ir<%add47>, ir<%60>
    WIDEN ir<%add119.us> = fadd ir<%add114.us>, ir<%61>
    WIDEN ir<%div120.us> = fdiv ir<%mul109.us>, ir<%add119.us>
    REDUCE ir<%add121.us> = ir<%xi.0203.us217> + reduce.fadd (ir<%div120.us>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%xi.0203.us217>, ir<%add121.us>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o tophits.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                tophits.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o trace.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                trace.c
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%t1>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%1>, ir<%arrayidx3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond4.preheader.loopexit>, scalar.ph

ir-bb<for.cond4.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%t1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader.loopexit>, scalar.ph

ir-bb<for.cond4.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%t1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader.loopexit>, scalar.ph

ir-bb<for.cond4.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %t1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond4.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %t1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond4.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %t1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond4.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %t1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %1, ptr %arrayidx3, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond4.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: MergeTraceArrays at line: trace.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%t1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%call>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%6>, ir<%5>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond4.preheader.loopexit>, scalar.ph

ir-bb<for.cond4.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %32, ptr %gep, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %32, ptr %gep, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %32, ptr %gep, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%t2>, ir<%indvars.iv35>
    CLONE ir<%32> = load ir<%arrayidx9>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv35>
    CLONE store ir<%32>, ir<%gep>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond40.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end15.loopexit>, scalar.ph

ir-bb<for.end15.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%t2>, ir<%indvars.iv35>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%32> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv35>
    vp<%5> = vector-pointer ir<%gep>
    WIDEN store vp<%5>, ir<%32>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond40.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end15.loopexit>, scalar.ph

ir-bb<for.end15.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: MergeTraceArrays' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%t2>, ir<%indvars.iv35>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%32> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv35>
    vp<%5> = vector-pointer ir<%gep>
    WIDEN store vp<%5>, ir<%32>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond40.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end15.loopexit>, scalar.ph

ir-bb<for.end15.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next36, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %t2, i64 %indvars.iv35 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep = getelementptr ptr, ptr %invariant.gep, i64 %indvars.iv35 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %32, ptr %gep, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond40.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count39 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond40.not, label %for.end15.loopexit, label %for.body7 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next36, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %t2, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep = getelementptr ptr, ptr %invariant.gep, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %32, ptr %gep, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond40.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count39 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond40.not, label %for.end15.loopexit, label %for.body7 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next36, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %t2, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep = getelementptr ptr, ptr %invariant.gep, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %32, ptr %gep, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond40.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count39 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond40.not, label %for.end15.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'MergeTraceArrays' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next36, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %t2, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %32 = load ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep = getelementptr ptr, ptr %invariant.gep, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %32, ptr %gep, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond40.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count39 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond40.not, label %for.end15.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: MergeTraceArrays at line: trace.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%t2>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%38> = load vp<%5>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, vp<%4>
    vp<%6> = vector-pointer ir<%gep>
    WIDEN store vp<%6>, ir<%38>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end15.loopexit>, scalar.ph

ir-bb<for.end15.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx98, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: P7Traces2Alignment' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mlen) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv800 = phi 0, %indvars.iv.next801, ir<1>
    CLONE ir<%arrayidx98> = getelementptr inbounds ir<%call>, ir<%indvars.iv800>
    CLONE ir<%19> = load ir<%arrayidx98>
    CLONE ir<%cmp99> = icmp sgt ir<%19>, ir<1>
  Successor(s): if.then101

  if.then101:
    CLONE store ir<1>, ir<%arrayidx98>, ir<%cmp99>
  Successor(s): for.inc105

  for.inc105:
    EMIT vp<%4> = not ir<%cmp99>
    EMIT vp<%5> = or vp<%4>, ir<%cmp99>
    CLONE ir<%indvars.iv.next801> = add nuw nsw ir<%indvars.iv800>, ir<1>
    CLONE ir<%exitcond804.not> = icmp eq ir<%indvars.iv.next801>, ir<%wide.trip.count803>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end108.loopexit>, scalar.ph

ir-bb<if.end108.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7Traces2Alignment' from trace.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mlen) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv800 = phi 0, %indvars.iv.next801, ir<1>
    CLONE ir<%arrayidx98> = getelementptr ir<%call>, ir<%indvars.iv800>
    vp<%4> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%cmp99> = icmp sgt ir<%19>, ir<1>
  Successor(s): if.then101

  if.then101:
    vp<%5> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%5>, ir<1>, ir<%cmp99>
  Successor(s): for.inc105

  for.inc105:
    EMIT vp<%6> = not ir<%cmp99>
    EMIT vp<%7> = or vp<%6>, ir<%cmp99>
    CLONE ir<%indvars.iv.next801> = add nuw nsw ir<%indvars.iv800>, ir<1>
    CLONE ir<%exitcond804.not> = icmp eq ir<%indvars.iv.next801>, ir<%wide.trip.count803>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end108.loopexit>, scalar.ph

ir-bb<if.end108.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: P7Traces2Alignment' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mlen) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv800 = phi 0, %indvars.iv.next801, ir<1>
    CLONE ir<%arrayidx98> = getelementptr ir<%call>, ir<%indvars.iv800>
    vp<%4> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%cmp99> = icmp sgt ir<%19>, ir<1>
  Successor(s): if.then101

  if.then101:
    vp<%5> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%5>, ir<1>, ir<%cmp99>
  Successor(s): for.inc105

  for.inc105:
    EMIT vp<%6> = not ir<%cmp99>
    EMIT vp<%7> = or vp<%6>, ir<%cmp99>
    CLONE ir<%indvars.iv.next801> = add nuw nsw ir<%indvars.iv800>, ir<1>
    CLONE ir<%exitcond804.not> = icmp eq ir<%indvars.iv.next801>, ir<%wide.trip.count803>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end108.loopexit>, scalar.ph

ir-bb<if.end108.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 15032385536, RTCostB: 12884901888
A is not scalable.	B is not scalable.	
RTCostA: 15032385536, RTCostB: 12884901888

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 12884901888
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 12884901888

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 12884901888
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv800 = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next801, %for.inc105 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx98 = getelementptr inbounds i32, ptr %call, i64 %indvars.iv800 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %19 = load i32, ptr %arrayidx98, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp99 = icmp sgt i32 %19, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp99, label %if.then101, label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1, ptr %arrayidx98, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc105 of type:br

-----------------Function that is being costed:'P7Traces2Alignment' from trace.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next801 = add nuw nsw i64 %indvars.iv800, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond804.not = icmp eq i64 %indvars.iv.next801, %wide.trip.count803 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond804.not, label %if.end108.loopexit, label %for.body96 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 12884901888
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177280, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: P7Traces2Alignment at line: trace.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mlen) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx98> = getelementptr ir<%call>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%19> = load vp<%5>
    WIDEN ir<%cmp99> = icmp sgt ir<%19>, ir<1>
    vp<%6> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%6>, ir<1>, ir<%cmp99>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end108.loopexit>, scalar.ph

ir-bb<if.end108.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: TraceDecompose' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ntr.0220> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx>
    CLONE ir<%cmp1> = icmp eq ir<%2>, ir<6>
    CLONE ir<%inc> = zext ir<%cmp1>
    CLONE ir<%spec.select> = add ir<%ntr.0220>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%ntr.0220>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: TraceDecompose' from trace.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ntr.0220> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ntr.0220>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%ntr.0220>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: TraceDecompose' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ntr.0220> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ntr.0220>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%ntr.0220>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676414, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676414, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 9663676414
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 3 for VF 8 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919144, RTCostB: 15032385529
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919144, RTCostB: 3758096398
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 7 for VF 16 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2013266010, RTCostB: 15032385529
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2013266010, RTCostB: 2415919144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2013266010

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 2013266010

-----------------Function that is being costed:'TraceDecompose' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ntr.0220 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %ntr.0220, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612779, RTCostB: 15032385529
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612779, RTCostB: 2013266010
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: TraceDecompose at line: trace.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%ntr.0220> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%5>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ntr.0220>, ir<%inc>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%ntr.0220>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 23
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: TraceDomainNumber' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ndom.010> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx>
    CLONE ir<%cmp1> = icmp eq ir<%2>, ir<6>
    CLONE ir<%inc> = zext ir<%cmp1>
    CLONE ir<%spec.select> = add ir<%ndom.010>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%ndom.010>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: TraceDomainNumber' from trace.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ndom.010> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ndom.010>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%ndom.010>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: TraceDomainNumber' from trace.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%ndom.010> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ndom.010>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%ndom.010>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676414, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676414, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 9663676414
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 3 for VF 8 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919144, RTCostB: 15032385529
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919144, RTCostB: 3758096398
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 7 for VF 16 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2013266010, RTCostB: 15032385529
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2013266010, RTCostB: 2415919144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2013266010

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 2013266010

-----------------Function that is being costed:'TraceDomainNumber' from trace.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ndom.010 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1 = icmp eq i8 %2, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = zext i1 %cmp1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %ndom.010, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612779, RTCostB: 15032385529
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612779, RTCostB: 2013266010
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: TraceDomainNumber at line: trace.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%ndom.010> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%5>
    WIDEN ir<%cmp1> = icmp eq ir<%2>, ir<6>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1> to i32
    WIDEN ir<%spec.select> = add ir<%ndom.010>, ir<%inc>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%ndom.010>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ucbqsort.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ucbqsort.c
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    CLONE ir<%4> = load ir<%j.2102>
    CLONE ir<%5> = load ir<%i.0101>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    CLONE store ir<%5>, ir<%j.2102>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    CLONE store ir<%4>, ir<%i.0101>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 68
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 68
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: specqsort at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: specqsort at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%spec.select.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%base>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%7> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%8> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%8>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%7>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: specqsort at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%spec.select.lcssa>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%base>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%46> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%47> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%47>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%46>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 4
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    CLONE ir<%16> = load ir<%i.3>
    CLONE ir<%17> = load ir<%jj.1>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    CLONE store ir<%17>, ir<%i.3>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    CLONE store ir<%16>, ir<%jj.1>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: qst at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%i.2.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%jj.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%18> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%19> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%19>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%18>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%18> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%i.2.lcssa>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%jj.0>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%56> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%57> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%57>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%56>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%18>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    CLONE ir<%6> = load ir<%i.0>
    CLONE ir<%7> = load ir<%j.1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    CLONE store ir<%7>, ir<%i.0>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    CLONE store ir<%6>, ir<%j.1>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: qst at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%add.ptr>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%j.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%9> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%10> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%10>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%9>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%add.ptr>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%j.0>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%47> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%48> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%48>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%47>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o a2m.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                a2m.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o aligneval.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                aligneval.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o alignio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                alignio.c
========== Loop: AllocAlignment' from alignio.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv48 = phi 0, %indvars.iv.next49, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call13>, ir<%indvars.iv48>
    CLONE store ir<0>, ir<%arrayidx20>
    CLONE ir<%indvars.iv.next49> = add nuw nsw ir<%indvars.iv48>, ir<1>
    CLONE ir<%exitcond52.not> = icmp eq ir<%indvars.iv.next49>, ir<%wide.trip.count51>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end23.loopexit>, scalar.ph

ir-bb<for.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: AllocAlignment' from alignio.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv48 = phi 0, %indvars.iv.next49, ir<1>
    REPLICATE ir<%arrayidx20> = getelementptr inbounds ir<%call13>, ir<%indvars.iv48>
    REPLICATE store ir<0>, ir<%arrayidx20>
    REPLICATE ir<%indvars.iv.next49> = add nuw nsw ir<%indvars.iv48>, ir<1>
    CLONE ir<%exitcond52.not> = icmp eq ir<%indvars.iv.next49>, ir<%wide.trip.count51>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end23.loopexit>, scalar.ph

ir-bb<for.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: AllocAlignment' from alignio.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv48 = phi 0, %indvars.iv.next49, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx20> = getelementptr inbounds ir<%call13>, ir<%indvars.iv48>
    REPLICATE store ir<0>, ir<%arrayidx20>
    WIDEN ir<%indvars.iv.next49> = add nuw nsw ir<%indvars.iv48>, ir<1>
    CLONE ir<%exitcond52.not> = icmp eq ir<%indvars.iv.next49>, ir<%wide.trip.count51>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end23.loopexit>, scalar.ph

ir-bb<for.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: AllocAlignment' from alignio.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv48 = phi 0, %indvars.iv.next49, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx20> = getelementptr inbounds ir<%call13>, ir<%indvars.iv48>
    WIDEN store ir<%arrayidx20>, ir<0>
    WIDEN ir<%indvars.iv.next49> = add nuw nsw ir<%indvars.iv48>, ir<1>
    CLONE ir<%exitcond52.not> = icmp eq ir<%indvars.iv.next49>, ir<%wide.trip.count51>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end23.loopexit>, scalar.ph

ir-bb<for.end23.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Vector loop of width 2 costs: 14

-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Vector loop of width 4 costs: 13

-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588

-----------------Function that is being costed:'AllocAlignment' from alignio.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv48 = phi i64 [ 0, %for.body17.preheader ], [ %indvars.iv.next49, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx20 = getelementptr inbounds %struct.seqinfo_s, ptr %call13, i64 %indvars.iv48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx20, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next49 = add nuw nsw i64 %indvars.iv48, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond52.not = icmp eq i64 %indvars.iv.next49, %wide.trip.count51 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond52.not, label %for.end23.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: AllocAlignment at line: alignio.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call13>, vp<%4>
    CLONE store ir<0>, ir<%arrayidx20>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end23.loopexit>, scalar.ph

ir-bb<for.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o clustal.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                clustal.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cluster.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cluster.c
@@ Instruction =>  %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx12.us> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx12.us>
    CLONE ir<%arrayidx16.us> = getelementptr inbounds ir<%call4.us>, ir<%indvars.iv>
    CLONE store ir<%1>, ir<%arrayidx16.us>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count830>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond5.for.inc17_crit_edge.us>, scalar.ph

ir-bb<for.cond5.for.inc17_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx12.us> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx12.us>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx16.us> = getelementptr inbounds ir<%call4.us>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx16.us>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count830>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond5.for.inc17_crit_edge.us>, scalar.ph

ir-bb<for.cond5.for.inc17_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx12.us> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx12.us>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx16.us> = getelementptr inbounds ir<%call4.us>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx16.us>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count830>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond5.for.inc17_crit_edge.us>, scalar.ph

ir-bb<for.cond5.for.inc17_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.us ], [ %indvars.iv.next, %for.body8.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx12.us = getelementptr inbounds float, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx12.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx16.us = getelementptr inbounds float, ptr %call4.us, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %1, ptr %arrayidx16.us, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count830 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond5.for.inc17_crit_edge.us, label %for.body8.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Cluster at line: cluster.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx12.us> = getelementptr inbounds ir<%0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx12.us>
    WIDEN ir<%6> = load vp<%5>
    CLONE ir<%arrayidx16.us> = getelementptr inbounds ir<%call4.us>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx16.us>
    WIDEN store vp<%6>, ir<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond5.for.inc17_crit_edge.us>, scalar.ph

ir-bb<for.cond5.for.inc17_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body29.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv832 = phi 0, %indvars.iv.next833, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv832 = phi 0, %indvars.iv.next833\l" +
    "  ir<%35>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%call22>, ir<%indvars.iv832>
    CLONE store ir<%35>, ir<%arrayidx31>
    CLONE ir<%indvars.iv.next833> = add nuw nsw ir<%indvars.iv832>, ir<1>
    CLONE ir<%exitcond836.not> = icmp eq ir<%indvars.iv.next833>, ir<%wide.trip.count835>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond35.preheader>, scalar.ph

ir-bb<for.cond35.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body29.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv832 = phi 0, %indvars.iv.next833, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv832 = phi 0, %indvars.iv.next833\l" +
    "  ir<%35>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%call22>, ir<%indvars.iv832>
    vp<%4> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%4>, ir<%35>
    WIDEN ir<%indvars.iv.next833> = add nuw nsw ir<%indvars.iv832>, ir<1>
    CLONE ir<%exitcond836.not> = icmp eq ir<%indvars.iv.next833>, ir<%wide.trip.count835>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond35.preheader>, scalar.ph

ir-bb<for.cond35.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: Cluster' from cluster.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body29.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv832 = phi 0, %indvars.iv.next833, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv832 = phi 0, %indvars.iv.next833\l" +
    "  ir<%35>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%call22>, ir<%indvars.iv832>
    vp<%4> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%4>, ir<%35>
    WIDEN ir<%indvars.iv.next833> = add nuw nsw ir<%indvars.iv832>, ir<1>
    CLONE ir<%exitcond836.not> = icmp eq ir<%indvars.iv.next833>, ir<%wide.trip.count835>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond35.preheader>, scalar.ph

ir-bb<for.cond35.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Cluster' from cluster.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv832 = phi i64 [ 0, %for.body29.preheader ], [ %indvars.iv.next833, %for.body29 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx31 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv832 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %35 = trunc nuw nsw i64 %indvars.iv832 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %35, ptr %arrayidx31, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next833 = add nuw nsw i64 %indvars.iv832, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond836.not = icmp eq i64 %indvars.iv.next833, %wide.trip.count835 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond836.not, label %for.cond35.preheader, label %for.body29 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Cluster at line: cluster.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body29.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv832 = phi 0, %indvars.iv.next833\l" +
    "  ir<%35>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%call22>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%5>, ir<%35>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond35.preheader>, scalar.ph

ir-bb<for.cond35.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dayhoff.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dayhoff.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o eps.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                eps.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o file.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                file.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o getopt.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                getopt.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o gki.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                gki.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o gsi.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                gsi.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hsregex.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hsregex.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o iupac.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                iupac.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o msa.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                msa.c
@@ Instruction =>  %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: MSASmallerAlignment' from msa.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nnew.0234> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%useme>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%tobool.not> = icmp ne ir<%1>, ir<0>
    CLONE ir<%inc> = zext ir<%tobool.not>
    CLONE ir<%spec.select> = add ir<%nnew.0234>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%nnew.0234>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: MSASmallerAlignment' from msa.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nnew.0234> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%useme>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp ne ir<%1>, ir<0>
    WIDEN-CAST ir<%inc> = zext  ir<%tobool.not> to i32
    WIDEN ir<%spec.select> = add ir<%nnew.0234>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nnew.0234>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: MSASmallerAlignment' from msa.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nnew.0234> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%useme>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp ne ir<%1>, ir<0>
    WIDEN-CAST ir<%inc> = zext  ir<%tobool.not> to i32
    WIDEN ir<%spec.select> = add ir<%nnew.0234>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nnew.0234>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 6442450945
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225487

-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 3221225487
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'MSASmallerAlignment' from msa.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %nnew.0234 = phi i32 [ 0, %for.body.preheader ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %useme, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i32, ptr %arrayidx, align 4, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp ne i32 %1, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = zext i1 %tobool.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %nnew.0234, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612779, RTCostB: 15032385529
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612779, RTCostB: 3221225487
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: MSASmallerAlignment at line: msa.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%nnew.0234> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%useme>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%tobool.not> = icmp ne ir<%1>, ir<0>
    WIDEN-CAST ir<%inc> = zext  ir<%tobool.not> to i32
    WIDEN ir<%spec.select> = add ir<%nnew.0234>, ir<%inc>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%nnew.0234>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o msf.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                msf.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o phylip.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                phylip.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o revcomp.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                revcomp.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rk.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                rk.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o selex.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                selex.c
========== Loop: ReadSELEX' from selex.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1374 = phi 0, %indvars.iv.next1375, ir<1>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, ir<%indvars.iv1374>
    CLONE ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    CLONE ir<%24> = load ir<%rcol234>
    CLONE ir<%25> = load ir<%arrayidx233>
    CLONE ir<%sub238> = add ir<%alen.01335>, ir<1>
    CLONE ir<%add239> = add ir<%sub238>, ir<%24>
    CLONE ir<%add240> = sub ir<%add239>, ir<%25>
    CLONE ir<%indvars.iv.next1375> = add nuw nsw ir<%indvars.iv1374>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next1375>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%6>
}

========== Loop: ReadSELEX' from selex.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1374 = phi 0, %indvars.iv.next1375, ir<1>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, ir<%indvars.iv1374>
    CLONE ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    INTERLEAVE-GROUP with factor 2 at %24, ir<%rcol234>
      ir<%25> = load from index 0
      ir<%24> = load from index 1
    WIDEN ir<%sub238> = add ir<%alen.01335>, ir<1>
    WIDEN ir<%add239> = add ir<%sub238>, ir<%24>
    WIDEN ir<%add240> = sub ir<%add239>, ir<%25>
    CLONE ir<%indvars.iv.next1375> = add nuw nsw ir<%indvars.iv1374>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next1375>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%6>
}

========== Loop: ReadSELEX' from selex.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1374 = phi 0, %indvars.iv.next1375, ir<1>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    WIDEN-GEP Inv[Var] ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, ir<%indvars.iv1374>
    WIDEN-GEP Var[Inv] ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    REPLICATE ir<%24> = load ir<%rcol234>
    REPLICATE ir<%25> = load ir<%arrayidx233>
    WIDEN ir<%sub238> = add ir<%alen.01335>, ir<1>
    WIDEN ir<%add239> = add ir<%sub238>, ir<%24>
    WIDEN ir<%add240> = sub ir<%add239>, ir<%25>
    WIDEN ir<%indvars.iv.next1375> = add nuw nsw ir<%indvars.iv1374>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next1375>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%6>
}

========== Loop: ReadSELEX' from selex.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1374 = phi 0, %indvars.iv.next1375, ir<1>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    WIDEN-GEP Inv[Var] ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, ir<%indvars.iv1374>
    WIDEN-GEP Var[Inv] ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    WIDEN ir<%24> = load ir<%rcol234>
    WIDEN ir<%25> = load ir<%arrayidx233>
    WIDEN ir<%sub238> = add ir<%alen.01335>, ir<1>
    WIDEN ir<%add239> = add ir<%sub238>, ir<%24>
    WIDEN ir<%add240> = sub ir<%add239>, ir<%25>
    WIDEN ir<%indvars.iv.next1375> = add nuw nsw ir<%indvars.iv1374>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next1375>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%6>
}

========== Loop: ReadSELEX' from selex.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1374 = phi 0, %indvars.iv.next1375, ir<1>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, ir<%indvars.iv1374>
    CLONE ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    INTERLEAVE-GROUP with factor 2 at %24, ir<%rcol234>
      ir<%25> = load from index 0
      ir<%24> = load from index 1
    WIDEN ir<%sub238> = add ir<%alen.01335>, ir<1>
    WIDEN ir<%add239> = add ir<%sub238>, ir<%24>
    WIDEN ir<%add240> = sub ir<%add239>, ir<%25>
    CLONE ir<%indvars.iv.next1375> = add nuw nsw ir<%indvars.iv1374>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next1375>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%6>
}


-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 87
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 87, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 87
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 348, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'ReadSELEX' from selex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1374 = phi i64 [ 0, %for.body231.preheader ], [ %indvars.iv.next1375, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %alen.01335 = phi i32 [ 0, %for.body231.preheader ], [ %add240, %for.body231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx233 = getelementptr inbounds %struct.block_struc, ptr %blocks.1.lcssa, i64 %indvars.iv1374 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rcol234 = getelementptr inbounds i8, ptr %arrayidx233, i64 4 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %24 = load i32, ptr %rcol234, align 4, !tbaa !18 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %25 = load i32, ptr %arrayidx233, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub238 = add i32 %alen.01335, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add239 = add i32 %sub238, %24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add240 = sub i32 %add239, %25 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1375 = add nuw nsw i64 %indvars.iv1374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next1375, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end243.loopexit, label %for.body231 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: ReadSELEX at line: selex.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body231.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {1,+,1}<%while.body> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%alen.01335> = phi ir<0>, ir<%add240>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx233> = getelementptr inbounds ir<%blocks.1.lcssa>, vp<%4>
    CLONE ir<%rcol234> = getelementptr inbounds ir<%arrayidx233>, ir<4>
    INTERLEAVE-GROUP with factor 2 at %24, ir<%rcol234>
      ir<%25> = load from index 0
      ir<%24> = load from index 1
    WIDEN ir<%sub238> = add ir<%alen.01335>, ir<1>
    WIDEN ir<%add239> = add ir<%sub238>, ir<%24>
    WIDEN ir<%add240> = sub ir<%add239>, ir<%25>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%alen.01335>, ir<%add240>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end243.loopexit>, scalar.ph

ir-bb<for.end243.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add240.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o seqencode.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                seqencode.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o shuffle.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                shuffle.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sqerror.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sqerror.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sqio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sqio.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o squidcore.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                squidcore.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sre_ctype.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sre_ctype.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sre_math.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sre_math.c
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%yavg.075> = phi ir<0.000000e+00>, ir<%add3>.1
    WIDEN-REDUCTION-PHI ir<%xavg.074> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%add> = fadd ir<%xavg.074>, ir<%0>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    CLONE ir<%add3> = fadd ir<%yavg.075>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add3>.1 = ir<%yavg.075> + reduce.fadd (ir<%1>)
    REDUCE ir<%add>.1 = ir<%xavg.074> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%yavg.075>, ir<%add3>.1
  EMIT vp<%7> = compute-reduction-result ir<%xavg.074>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%7>
Live-out float %add3.lcssa = vp<%6>
}

========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%yavg.075> = phi ir<0.000000e+00>, ir<%add3>.1
    WIDEN-REDUCTION-PHI ir<%xavg.074> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%xavg.074>, ir<%0>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add3> = fadd ir<%yavg.075>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add3>.1 = ir<%yavg.075> + reduce.fadd (ir<%1>)
    REDUCE ir<%add>.1 = ir<%xavg.074> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%yavg.075>, ir<%add3>.1
  EMIT vp<%9> = compute-reduction-result ir<%xavg.074>, ir<%add>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%9>
Live-out float %add3.lcssa = vp<%8>
}

========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%yavg.075> = phi ir<0.000000e+00>, ir<%add3>.1
    WIDEN-REDUCTION-PHI ir<%xavg.074> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%xavg.074>, ir<%0>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add3> = fadd ir<%yavg.075>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add3>.1 = ir<%yavg.075> + reduce.fadd (ir<%1>)
    REDUCE ir<%add>.1 = ir<%xavg.074> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%yavg.075>, ir<%add3>.1
  EMIT vp<%9> = compute-reduction-result ir<%xavg.074>, ir<%add>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%9>
Live-out float %add3.lcssa = vp<%8>
}


-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 17179869176, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 17179869176, RTCostB: 17179869176

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 17179869176, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 17179869176, RTCostB: 17179869176

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %yavg.075 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %xavg.074 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add = fadd float %xavg.074, %0 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add3 = fadd float %yavg.075, %1 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709156, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 5368709156, RTCostB: 6442450956
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Linefit at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%yavg.075> = phi ir<0.000000e+00>, ir<%add3>
    WIDEN-REDUCTION-PHI ir<%xavg.074> = phi ir<0.000000e+00>, ir<%add>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%x>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%y>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%6>
    REDUCE ir<%add3> = ir<%yavg.075> + reduce.fadd (ir<%1>)
    REDUCE ir<%add> = ir<%xavg.074> + reduce.fadd (ir<%0>)
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%yavg.075>, ir<%add3>
  EMIT vp<%10> = compute-reduction-result ir<%xavg.074>, ir<%add>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%10>
Live-out float %add3.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv89 = phi 0, %indvars.iv.next90, ir<1>
    WIDEN-REDUCTION-PHI ir<%sxy.081> = phi ir<0.000000e+00>, ir<%35>.1
    WIDEN-REDUCTION-PHI ir<%syy.080> = phi ir<0.000000e+00>, ir<%34>.1
    WIDEN-REDUCTION-PHI ir<%sxx.079> = phi ir<0.000000e+00>, ir<%32>.1
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%x>, ir<%indvars.iv89>
    CLONE ir<%31> = load ir<%arrayidx11>
    CLONE ir<%sub> = fsub ir<%31>, ir<%div>
    EMIT vp<%4> = fmul ir<%sub>, ir<%sub>
    CLONE ir<%32> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub>, ir<%sxx.079>)
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%y>, ir<%indvars.iv89>
    CLONE ir<%33> = load ir<%arrayidx16>
    CLONE ir<%sub17> = fsub ir<%33>, ir<%div5>
    CLONE ir<%sub20> = fsub ir<%33>, ir<%div>
    EMIT vp<%5> = fmul ir<%sub17>, ir<%sub20>
    CLONE ir<%34> = call @llvm.fmuladd.f32(ir<%sub17>, ir<%sub20>, ir<%syy.080>)
    EMIT vp<%6> = fmul ir<%sub>, ir<%sub17>
    CLONE ir<%35> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub17>, ir<%sxy.081>)
    CLONE ir<%indvars.iv.next90> = add nuw nsw ir<%indvars.iv89>, ir<1>
    CLONE ir<%exitcond93.not> = icmp eq ir<%indvars.iv.next90>, ir<%wide.trip.count92>
    REDUCE ir<%35>.1 = ir<%sxy.081> + reduce.fadd (vp<%6>)
    REDUCE ir<%34>.1 = ir<%syy.080> + reduce.fadd (vp<%5>)
    REDUCE ir<%32>.1 = ir<%sxx.079> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sxy.081>, ir<%35>.1
  EMIT vp<%10> = compute-reduction-result ir<%syy.080>, ir<%34>.1
  EMIT vp<%11> = compute-reduction-result ir<%sxx.079>, ir<%32>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa104 = vp<%11>
Live-out float %.lcssa103 = vp<%10>
Live-out float %.lcssa = vp<%9>
}

========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv89 = phi 0, %indvars.iv.next90, ir<1>
    WIDEN-REDUCTION-PHI ir<%sxy.081> = phi ir<0.000000e+00>, ir<%35>.1
    WIDEN-REDUCTION-PHI ir<%syy.080> = phi ir<0.000000e+00>, ir<%34>.1
    WIDEN-REDUCTION-PHI ir<%sxx.079> = phi ir<0.000000e+00>, ir<%32>.1
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%x>, ir<%indvars.iv89>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%31> = load vp<%4>
    WIDEN ir<%sub> = fsub ir<%31>, ir<%div>
    EMIT vp<%5> = fmul ir<%sub>, ir<%sub>
    WIDEN-CALL ir<%32> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub>, ir<%sxx.079>) (using vector intrinsic)
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%y>, ir<%indvars.iv89>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%33> = load vp<%6>
    WIDEN ir<%sub17> = fsub ir<%33>, ir<%div5>
    WIDEN ir<%sub20> = fsub ir<%33>, ir<%div>
    EMIT vp<%7> = fmul ir<%sub17>, ir<%sub20>
    WIDEN-CALL ir<%34> = call @llvm.fmuladd.f32(ir<%sub17>, ir<%sub20>, ir<%syy.080>) (using vector intrinsic)
    EMIT vp<%8> = fmul ir<%sub>, ir<%sub17>
    WIDEN-CALL ir<%35> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub17>, ir<%sxy.081>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next90> = add nuw nsw ir<%indvars.iv89>, ir<1>
    CLONE ir<%exitcond93.not> = icmp eq ir<%indvars.iv.next90>, ir<%wide.trip.count92>
    REDUCE ir<%35>.1 = ir<%sxy.081> + reduce.fadd (vp<%8>)
    REDUCE ir<%34>.1 = ir<%syy.080> + reduce.fadd (vp<%7>)
    REDUCE ir<%32>.1 = ir<%sxx.079> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%sxy.081>, ir<%35>.1
  EMIT vp<%12> = compute-reduction-result ir<%syy.080>, ir<%34>.1
  EMIT vp<%13> = compute-reduction-result ir<%sxx.079>, ir<%32>.1
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa104 = vp<%13>
Live-out float %.lcssa103 = vp<%12>
Live-out float %.lcssa = vp<%11>
}

========== Loop: Linefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv89 = phi 0, %indvars.iv.next90, ir<1>
    WIDEN-REDUCTION-PHI ir<%sxy.081> = phi ir<0.000000e+00>, ir<%35>.1
    WIDEN-REDUCTION-PHI ir<%syy.080> = phi ir<0.000000e+00>, ir<%34>.1
    WIDEN-REDUCTION-PHI ir<%sxx.079> = phi ir<0.000000e+00>, ir<%32>.1
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%x>, ir<%indvars.iv89>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%31> = load vp<%4>
    WIDEN ir<%sub> = fsub ir<%31>, ir<%div>
    EMIT vp<%5> = fmul ir<%sub>, ir<%sub>
    WIDEN-CALL ir<%32> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub>, ir<%sxx.079>) (using vector intrinsic)
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%y>, ir<%indvars.iv89>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%33> = load vp<%6>
    WIDEN ir<%sub17> = fsub ir<%33>, ir<%div5>
    WIDEN ir<%sub20> = fsub ir<%33>, ir<%div>
    EMIT vp<%7> = fmul ir<%sub17>, ir<%sub20>
    WIDEN-CALL ir<%34> = call @llvm.fmuladd.f32(ir<%sub17>, ir<%sub20>, ir<%syy.080>) (using vector intrinsic)
    EMIT vp<%8> = fmul ir<%sub>, ir<%sub17>
    WIDEN-CALL ir<%35> = call @llvm.fmuladd.f32(ir<%sub>, ir<%sub17>, ir<%sxy.081>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next90> = add nuw nsw ir<%indvars.iv89>, ir<1>
    CLONE ir<%exitcond93.not> = icmp eq ir<%indvars.iv.next90>, ir<%wide.trip.count92>
    REDUCE ir<%35>.1 = ir<%sxy.081> + reduce.fadd (vp<%8>)
    REDUCE ir<%34>.1 = ir<%syy.080> + reduce.fadd (vp<%7>)
    REDUCE ir<%32>.1 = ir<%sxx.079> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%sxy.081>, ir<%35>.1
  EMIT vp<%12> = compute-reduction-result ir<%syy.080>, ir<%34>.1
  EMIT vp<%13> = compute-reduction-result ir<%sxx.079>, ir<%32>.1
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa104 = vp<%13>
Live-out float %.lcssa103 = vp<%12>
Live-out float %.lcssa = vp<%11>
}


-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of 8 for VF 2 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of 8 for VF 2 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of 8 for VF 2 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Vector loop of width 2 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 33285996525, RTCostB: 25769803764
A is not scalable.	B is not scalable.	
RTCostA: 33285996525, RTCostB: 25769803764

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of 16 for VF 4 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of 16 for VF 4 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of 16 for VF 4 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Vector loop of width 4 costs: 13
A is not scalable.	B is not scalable.	
RTCostA: 29527900141, RTCostB: 25769803764
A is not scalable.	B is not scalable.	
RTCostA: 29527900141, RTCostB: 25769803764

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 2 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 13421772811, RTCostB: 25769803764
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 13421772811, RTCostB: 25769803764
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Linefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv89 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next90, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sxy.081 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %35, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %syy.080 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %34, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sxx.079 = phi float [ 0.000000e+00, %for.body9.preheader ], [ %32, %for.body9 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11 = getelementptr inbounds float, ptr %x, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %31 = load float, ptr %arrayidx11, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub = fsub float %31, %div of type:fsub
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %32 = tail call float @llvm.fmuladd.f32(float %sub, float %sub, float %sxx.079) of type:call
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx16 = getelementptr inbounds float, ptr %y, i64 %indvars.iv89 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %33 = load float, ptr %arrayidx16, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub17 = fsub float %33, %div5 of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub20 = fsub float %33, %div of type:fsub
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %34 = tail call float @llvm.fmuladd.f32(float %sub17, float %sub20, float %syy.080) of type:call
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %35 = tail call float @llvm.fmuladd.f32(float %sub, float %sub17, float %sxy.081) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond93.not = icmp eq i64 %indvars.iv.next90, %wide.trip.count92 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond93.not, label %for.end29.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 4 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 9932111919, RTCostB: 25769803764
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 9932111919, RTCostB: 13421772811
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 4.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Linefit at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-REDUCTION-PHI ir<%sxy.081> = phi ir<0.000000e+00>, ir<%35>
    WIDEN-REDUCTION-PHI ir<%syy.080> = phi ir<0.000000e+00>, ir<%34>
    WIDEN-REDUCTION-PHI ir<%sxx.079> = phi ir<0.000000e+00>, ir<%32>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%x>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%31> = load vp<%5>
    WIDEN ir<%sub> = fsub ir<%31>, ir<%div>
    EMIT vp<%6> = fmul ir<%sub>, ir<%sub>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%y>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%33> = load vp<%7>
    WIDEN ir<%sub17> = fsub ir<%33>, ir<%div5>
    WIDEN ir<%sub20> = fsub ir<%33>, ir<%div>
    EMIT vp<%8> = fmul ir<%sub17>, ir<%sub20>
    EMIT vp<%9> = fmul ir<%sub>, ir<%sub17>
    REDUCE ir<%35> = ir<%sxy.081> + reduce.fadd (vp<%9>)
    REDUCE ir<%34> = ir<%syy.080> + reduce.fadd (vp<%8>)
    REDUCE ir<%32> = ir<%sxx.079> + reduce.fadd (vp<%6>)
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%sxy.081>, ir<%35>
  EMIT vp<%13> = compute-reduction-result ir<%syy.080>, ir<%34>
  EMIT vp<%14> = compute-reduction-result ir<%sxx.079>, ir<%32>
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa104 = vp<%14>
Live-out float %.lcssa103 = vp<%13>
Live-out float %.lcssa = vp<%12>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: WeightedLinefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%s.084> = phi ir<0.000000e+00>, ir<%add>.1
    WIDEN-REDUCTION-PHI ir<%sx.083> = phi ir<0.000000e+00>, ir<%add7>.1
    WIDEN-REDUCTION-PHI ir<%sxy.082> = phi ir<0.000000e+00>, ir<%add33>.1
    WIDEN-REDUCTION-PHI ir<%sxx.081> = phi ir<0.000000e+00>, ir<%add23>.1
    WIDEN-REDUCTION-PHI ir<%sy.080> = phi ir<0.000000e+00>, ir<%add14>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%var>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%conv> = fpext ir<%0>
    CLONE ir<%div> = fdiv ir<1.000000e+00>, ir<%conv>
    CLONE ir<%add> = fadd ir<%s.084>, ir<%div>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    CLONE ir<%div5> = fdiv ir<%1>, ir<%0>
    CLONE ir<%conv6> = fpext ir<%div5>
    CLONE ir<%add7> = fadd ir<%sx.083>, ir<%conv6>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx9>
    CLONE ir<%div12> = fdiv ir<%2>, ir<%0>
    CLONE ir<%conv13> = fpext ir<%div12>
    CLONE ir<%add14> = fadd ir<%sy.080>, ir<%conv13>
    CLONE ir<%mul> = fmul ir<%1>, ir<%1>
    CLONE ir<%div21> = fdiv ir<%mul>, ir<%0>
    CLONE ir<%conv22> = fpext ir<%div21>
    CLONE ir<%add23> = fadd ir<%sxx.081>, ir<%conv22>
    CLONE ir<%mul28> = fmul ir<%1>, ir<%2>
    CLONE ir<%div31> = fdiv ir<%mul28>, ir<%0>
    CLONE ir<%conv32> = fpext ir<%div31>
    CLONE ir<%add33> = fadd ir<%sxy.082>, ir<%conv32>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%s.084> + reduce.fadd (ir<%div>)
    REDUCE ir<%add7>.1 = ir<%sx.083> + reduce.fadd (ir<%conv6>)
    REDUCE ir<%add33>.1 = ir<%sxy.082> + reduce.fadd (ir<%conv32>)
    REDUCE ir<%add23>.1 = ir<%sxx.081> + reduce.fadd (ir<%conv22>)
    REDUCE ir<%add14>.1 = ir<%sy.080> + reduce.fadd (ir<%conv13>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%s.084>, ir<%add>.1
  EMIT vp<%7> = compute-reduction-result ir<%sx.083>, ir<%add7>.1
  EMIT vp<%8> = compute-reduction-result ir<%sxy.082>, ir<%add33>.1
  EMIT vp<%9> = compute-reduction-result ir<%sxx.081>, ir<%add23>.1
  EMIT vp<%10> = compute-reduction-result ir<%sy.080>, ir<%add14>.1
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%6>
Live-out double %add7.lcssa = vp<%7>
Live-out double %add14.lcssa = vp<%10>
Live-out double %add23.lcssa = vp<%9>
Live-out double %add33.lcssa = vp<%8>
}

========== Loop: WeightedLinefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%s.084> = phi ir<0.000000e+00>, ir<%add>.1
    WIDEN-REDUCTION-PHI ir<%sx.083> = phi ir<0.000000e+00>, ir<%add7>.1
    WIDEN-REDUCTION-PHI ir<%sxy.082> = phi ir<0.000000e+00>, ir<%add33>.1
    WIDEN-REDUCTION-PHI ir<%sxx.081> = phi ir<0.000000e+00>, ir<%add23>.1
    WIDEN-REDUCTION-PHI ir<%sy.080> = phi ir<0.000000e+00>, ir<%add14>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%var>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN-CAST ir<%conv> = fpext  ir<%0> to double
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%conv>
    WIDEN ir<%add> = fadd ir<%s.084>, ir<%div>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%div5> = fdiv ir<%1>, ir<%0>
    WIDEN-CAST ir<%conv6> = fpext  ir<%div5> to double
    WIDEN ir<%add7> = fadd ir<%sx.083>, ir<%conv6>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%6>
    WIDEN ir<%div12> = fdiv ir<%2>, ir<%0>
    WIDEN-CAST ir<%conv13> = fpext  ir<%div12> to double
    WIDEN ir<%add14> = fadd ir<%sy.080>, ir<%conv13>
    WIDEN ir<%mul> = fmul ir<%1>, ir<%1>
    WIDEN ir<%div21> = fdiv ir<%mul>, ir<%0>
    WIDEN-CAST ir<%conv22> = fpext  ir<%div21> to double
    WIDEN ir<%add23> = fadd ir<%sxx.081>, ir<%conv22>
    WIDEN ir<%mul28> = fmul ir<%1>, ir<%2>
    WIDEN ir<%div31> = fdiv ir<%mul28>, ir<%0>
    WIDEN-CAST ir<%conv32> = fpext  ir<%div31> to double
    WIDEN ir<%add33> = fadd ir<%sxy.082>, ir<%conv32>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%s.084> + reduce.fadd (ir<%div>)
    REDUCE ir<%add7>.1 = ir<%sx.083> + reduce.fadd (ir<%conv6>)
    REDUCE ir<%add33>.1 = ir<%sxy.082> + reduce.fadd (ir<%conv32>)
    REDUCE ir<%add23>.1 = ir<%sxx.081> + reduce.fadd (ir<%conv22>)
    REDUCE ir<%add14>.1 = ir<%sy.080> + reduce.fadd (ir<%conv13>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%s.084>, ir<%add>.1
  EMIT vp<%10> = compute-reduction-result ir<%sx.083>, ir<%add7>.1
  EMIT vp<%11> = compute-reduction-result ir<%sxy.082>, ir<%add33>.1
  EMIT vp<%12> = compute-reduction-result ir<%sxx.081>, ir<%add23>.1
  EMIT vp<%13> = compute-reduction-result ir<%sy.080>, ir<%add14>.1
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%9>
Live-out double %add7.lcssa = vp<%10>
Live-out double %add14.lcssa = vp<%13>
Live-out double %add23.lcssa = vp<%12>
Live-out double %add33.lcssa = vp<%11>
}

========== Loop: WeightedLinefit' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%s.084> = phi ir<0.000000e+00>, ir<%add>.1
    WIDEN-REDUCTION-PHI ir<%sx.083> = phi ir<0.000000e+00>, ir<%add7>.1
    WIDEN-REDUCTION-PHI ir<%sxy.082> = phi ir<0.000000e+00>, ir<%add33>.1
    WIDEN-REDUCTION-PHI ir<%sxx.081> = phi ir<0.000000e+00>, ir<%add23>.1
    WIDEN-REDUCTION-PHI ir<%sy.080> = phi ir<0.000000e+00>, ir<%add14>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%var>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN-CAST ir<%conv> = fpext  ir<%0> to double
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%conv>
    WIDEN ir<%add> = fadd ir<%s.084>, ir<%div>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%x>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%div5> = fdiv ir<%1>, ir<%0>
    WIDEN-CAST ir<%conv6> = fpext  ir<%div5> to double
    WIDEN ir<%add7> = fadd ir<%sx.083>, ir<%conv6>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%y>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%6>
    WIDEN ir<%div12> = fdiv ir<%2>, ir<%0>
    WIDEN-CAST ir<%conv13> = fpext  ir<%div12> to double
    WIDEN ir<%add14> = fadd ir<%sy.080>, ir<%conv13>
    WIDEN ir<%mul> = fmul ir<%1>, ir<%1>
    WIDEN ir<%div21> = fdiv ir<%mul>, ir<%0>
    WIDEN-CAST ir<%conv22> = fpext  ir<%div21> to double
    WIDEN ir<%add23> = fadd ir<%sxx.081>, ir<%conv22>
    WIDEN ir<%mul28> = fmul ir<%1>, ir<%2>
    WIDEN ir<%div31> = fdiv ir<%mul28>, ir<%0>
    WIDEN-CAST ir<%conv32> = fpext  ir<%div31> to double
    WIDEN ir<%add33> = fadd ir<%sxy.082>, ir<%conv32>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%s.084> + reduce.fadd (ir<%div>)
    REDUCE ir<%add7>.1 = ir<%sx.083> + reduce.fadd (ir<%conv6>)
    REDUCE ir<%add33>.1 = ir<%sxy.082> + reduce.fadd (ir<%conv32>)
    REDUCE ir<%add23>.1 = ir<%sxx.081> + reduce.fadd (ir<%conv22>)
    REDUCE ir<%add14>.1 = ir<%sy.080> + reduce.fadd (ir<%conv13>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%s.084>, ir<%add>.1
  EMIT vp<%10> = compute-reduction-result ir<%sx.083>, ir<%add7>.1
  EMIT vp<%11> = compute-reduction-result ir<%sxy.082>, ir<%add33>.1
  EMIT vp<%12> = compute-reduction-result ir<%sxx.081>, ir<%add23>.1
  EMIT vp<%13> = compute-reduction-result ir<%sy.080>, ir<%add14>.1
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%9>
Live-out double %add7.lcssa = vp<%10>
Live-out double %add14.lcssa = vp<%13>
Live-out double %add23.lcssa = vp<%12>
Live-out double %add33.lcssa = vp<%11>
}


-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 32.
-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 27
A is not scalable.	B is not scalable.	
RTCostA: 57982058474, RTCostB: 68719476704
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 57982058474, RTCostB: 68719476704
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of 4 for VF 4 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 24
A is not scalable.	B is not scalable.	
RTCostA: 51539607552, RTCostB: 68719476704
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 51539607552, RTCostB: 57982058474
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 68719476704
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607552

-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320180, RTCostB: 68719476704
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 23622320180, RTCostB: 51539607552
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'WeightedLinefit' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.084 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sx.083 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add7, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sxy.082 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add33, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sxx.081 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add23, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sy.080 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add14, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %var, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv = fpext float %0 to double of type:fpext
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %div = fdiv double 1.000000e+00, %conv of type:fdiv
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add = fadd double %s.084, %div of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %x, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div5 = fdiv float %1, %0 of type:fdiv
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv6 = fpext float %div5 to double of type:fpext
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add7 = fadd double %sx.083, %conv6 of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds float, ptr %y, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load float, ptr %arrayidx9, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div12 = fdiv float %2, %0 of type:fdiv
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv13 = fpext float %div12 to double of type:fpext
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add14 = fadd double %sy.080, %conv13 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul = fmul float %1, %1 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div21 = fdiv float %mul, %0 of type:fdiv
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv22 = fpext float %div21 to double of type:fpext
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add23 = fadd double %sxx.081, %conv22 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul28 = fmul float %1, %2 of type:fmul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div31 = fdiv float %mul28, %0 of type:fdiv
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv32 = fpext float %div31 to double of type:fpext
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add33 = fadd double %sxy.082, %conv32 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 8
A is scalable.	B is not scalable.	
RTCostA: 19058917529, RTCostB: 68719476704
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 19058917529, RTCostB: 23622320180
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 8.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: WeightedLinefit at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %N to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%s.084> = phi ir<0.000000e+00>, ir<%add>
    WIDEN-REDUCTION-PHI ir<%sx.083> = phi ir<0.000000e+00>, ir<%add7>
    WIDEN-REDUCTION-PHI ir<%sxy.082> = phi ir<0.000000e+00>, ir<%add33>
    WIDEN-REDUCTION-PHI ir<%sxx.081> = phi ir<0.000000e+00>, ir<%add23>
    WIDEN-REDUCTION-PHI ir<%sy.080> = phi ir<0.000000e+00>, ir<%add14>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%var>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    WIDEN-CAST ir<%conv> = fpext  ir<%0> to double
    WIDEN ir<%div> = fdiv ir<1.000000e+00>, ir<%conv>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%x>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%6>
    WIDEN ir<%div5> = fdiv ir<%1>, ir<%0>
    WIDEN-CAST ir<%conv6> = fpext  ir<%div5> to double
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%y>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%7>
    WIDEN ir<%div12> = fdiv ir<%2>, ir<%0>
    WIDEN-CAST ir<%conv13> = fpext  ir<%div12> to double
    WIDEN ir<%mul> = fmul ir<%1>, ir<%1>
    WIDEN ir<%div21> = fdiv ir<%mul>, ir<%0>
    WIDEN-CAST ir<%conv22> = fpext  ir<%div21> to double
    WIDEN ir<%mul28> = fmul ir<%1>, ir<%2>
    WIDEN ir<%div31> = fdiv ir<%mul28>, ir<%0>
    WIDEN-CAST ir<%conv32> = fpext  ir<%div31> to double
    REDUCE ir<%add> = ir<%s.084> + reduce.fadd (ir<%div>)
    REDUCE ir<%add7> = ir<%sx.083> + reduce.fadd (ir<%conv6>)
    REDUCE ir<%add33> = ir<%sxy.082> + reduce.fadd (ir<%conv32>)
    REDUCE ir<%add23> = ir<%sxx.081> + reduce.fadd (ir<%conv22>)
    REDUCE ir<%add14> = ir<%sy.080> + reduce.fadd (ir<%conv13>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%s.084>, ir<%add>
  EMIT vp<%11> = compute-reduction-result ir<%sx.083>, ir<%add7>
  EMIT vp<%12> = compute-reduction-result ir<%sxy.082>, ir<%add33>
  EMIT vp<%13> = compute-reduction-result ir<%sxx.081>, ir<%add23>
  EMIT vp<%14> = compute-reduction-result ir<%sy.080>, ir<%add14>
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%10>
Live-out double %add7.lcssa = vp<%11>
Live-out double %add14.lcssa = vp<%14>
Live-out double %add23.lcssa = vp<%13>
Live-out double %add33.lcssa = vp<%12>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: FMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%add.ptr>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds float, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'FMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds float, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967292, RTCostB: 10737418230
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967292, RTCostB: 10737418230
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds float, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418230
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967292

-----------------Function that is being costed:'FMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds float, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 10737418230
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 4294967292
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: FMX2Alloc at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%add.ptr>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: DMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%add.ptr>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DMX2Alloc' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds double, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'DMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds double, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967292, RTCostB: 10737418230
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967292, RTCostB: 10737418230
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds double, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418230
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967292

-----------------Function that is being costed:'DMX2Alloc' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = mul nsw i64 %indvars.iv, %conv3 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds double, ptr %call5, i64 %0 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %arrayidx9, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 10737418230
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 4294967292
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DMX2Alloc at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %rows to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN ir<%0> = mul nsw ir<%indvars.iv>, ir<%conv3>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call5>, ir<%0>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%add.ptr>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
========== Loop: FMX2Multiply' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%p> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%5> = phi ir<0.000000e+00>, ir<%8>.1
    WIDEN-INDUCTION %k.040.us.us.us = phi 0, %inc.us.us.us, ir<1>
    CLONE ir<%6> = load ir<%arrayidx12.us.us.us>
    CLONE ir<%7> = load ir<%arrayidx16.us.us.us>
    EMIT vp<%3> = fmul ir<%6>, ir<%7>
    CLONE ir<%8> = call @llvm.fmuladd.f32(ir<%6>, ir<%7>, ir<%5>)
    CLONE ir<%inc.us.us.us> = add nuw nsw ir<%k.040.us.us.us>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%inc.us.us.us>, ir<%p>
    REDUCE ir<%8>.1 = ir<%5> + reduce.fadd (vp<%3>) (with final reduction value stored in invariant address sank outside of loop)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%5>, ir<%8>.1
  EMIT vp<%7> = icmp eq ir<%p>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>, scalar.ph

ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>:
No successors

scalar.ph:
No successors
}

========== Loop: FMX2Multiply' from sre_math.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%p> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%5> = phi ir<0.000000e+00>, ir<%8>.1
    WIDEN-INDUCTION %k.040.us.us.us = phi 0, %inc.us.us.us, ir<1>
    CLONE ir<%6> = load ir<%arrayidx12.us.us.us>
    CLONE ir<%7> = load ir<%arrayidx16.us.us.us>
    EMIT vp<%3> = fmul ir<%6>, ir<%7>
    WIDEN-CALL ir<%8> = call @llvm.fmuladd.f32(ir<%6>, ir<%7>, ir<%5>) (using vector intrinsic)
    CLONE ir<%inc.us.us.us> = add nuw nsw ir<%k.040.us.us.us>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%inc.us.us.us>, ir<%p>
    REDUCE ir<%8>.1 = ir<%5> + reduce.fadd (vp<%3>) (with final reduction value stored in invariant address sank outside of loop)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%5>, ir<%8>.1
  EMIT vp<%7> = icmp eq ir<%p>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>, scalar.ph

ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>:
No successors

scalar.ph:
No successors
}

========== Loop: FMX2Multiply' from sre_math.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%p> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%5> = phi ir<0.000000e+00>, ir<%8>.1
    WIDEN-INDUCTION %k.040.us.us.us = phi 0, %inc.us.us.us, ir<1>
    CLONE ir<%6> = load ir<%arrayidx12.us.us.us>
    CLONE ir<%7> = load ir<%arrayidx16.us.us.us>
    EMIT vp<%3> = fmul ir<%6>, ir<%7>
    WIDEN-CALL ir<%8> = call @llvm.fmuladd.f32(ir<%6>, ir<%7>, ir<%5>) (using vector intrinsic)
    CLONE ir<%inc.us.us.us> = add nuw nsw ir<%k.040.us.us.us>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%inc.us.us.us>, ir<%p>
    REDUCE ir<%8>.1 = ir<%5> + reduce.fadd (vp<%3>) (with final reduction value stored in invariant address sank outside of loop)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%5>, ir<%8>.1
  EMIT vp<%7> = icmp eq ir<%p>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>, scalar.ph

ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 15032385529, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 15032385529, RTCostB: 15032385529

-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160063, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11811160063, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 11811160063

-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450953, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450953, RTCostB: 11811160063
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FMX2Multiply' from sre_math.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %5 = phi float [ 0.000000e+00, %for.body3.us.us.us ], [ %8, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %k.040.us.us.us = phi i32 [ 0, %for.body3.us.us.us ], [ %inc.us.us.us, %for.body8.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %6 = load float, ptr %arrayidx12.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %7 = load float, ptr %arrayidx16.us.us.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %8 = tail call float @llvm.fmuladd.f32(float %6, float %7, float %5) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc.us.us.us = add nuw nsw i32 %k.040.us.us.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond57.not = icmp eq i32 %inc.us.us.us, %p of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond57.not, label %for.cond6.for.inc21_crit_edge.us.us.us, label %for.body8.us.us.us of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967329, RTCostB: 15032385529
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967329, RTCostB: 6442450953
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FMX2Multiply at line: sre_math.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%p> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%8> = phi ir<0.000000e+00>, ir<%11>
    CLONE ir<%9> = load ir<%arrayidx12.us.us.us>
    CLONE ir<%10> = load ir<%arrayidx16.us.us.us>
    EMIT vp<%3> = fmul ir<%9>, ir<%10>
    REDUCE ir<%11> = ir<%8> + reduce.fadd (vp<%3>) (with final reduction value stored in invariant address sank outside of loop)
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%8>, ir<%11>
  EMIT vp<%7> = icmp eq ir<%p>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>, scalar.ph

ir-bb<for.cond6.for.inc21_crit_edge.us.us.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sre_random.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sre_random.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sre_string.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sre_string.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ssi.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ssi.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stack.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                stack.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stockholm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                stockholm.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o translate.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                translate.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o types.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                types.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vectorops.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                vectorops.c
@@ Instruction =>  store double %value, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %value, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %value, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE store ir<%value>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%value>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%value>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %value, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'DSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %value, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %value, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225473

-----------------Function that is being costed:'DSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %value, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DSet at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%value>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store float %value, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %value, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %value, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %value, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %value, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE store ir<%value>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%value>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FSet' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%value>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1610612745

-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FSet' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %value, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306393, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306393, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FSet at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%value>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %mul, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%mul> = fmul ir<%0>, ir<%scale>
    CLONE store ir<%mul>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %0, %scale of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'DScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450946

-----------------Function that is being costed:'DScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DScale at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%mul>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %mul, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %mul, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %mul, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %mul, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %mul, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%mul> = fmul ir<%0>, ir<%scale>
    CLONE store ir<%mul>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FScale' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225490

-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FScale' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul = fmul float %0, %scale of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %mul, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612786, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612786, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FScale at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    WIDEN ir<%mul> = fmul ir<%0>, ir<%scale>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%mul>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%6>
}

========== Loop: DSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%7>
}

========== Loop: DSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%7>
}


-----------------Function that is being costed:'DSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.05 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd double %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'DSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.05 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd double %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.05 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd double %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676412

-----------------Function that is being costed:'DSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.05 = phi double [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd double %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 9663676412
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DSum at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    REDUCE ir<%add> = ir<%sum.05> + reduce.fadd (ir<%0>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sum.05>, ir<%add>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%6>
}

========== Loop: FSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%7>
}

========== Loop: FSum' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.05>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.05> + reduce.fadd (ir<%0>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.05>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%7>
}


-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9126805502, RTCostB: 10737418235
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9126805502, RTCostB: 9663676412
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9126805502

-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 9126805502
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FSum' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sum.05 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add = fadd float %sum.05, %0 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2952790040, RTCostB: 10737418235
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2952790040, RTCostB: 3758096392
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FSum at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%sum.05> = phi ir<0.000000e+00>, ir<%add>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    REDUCE ir<%add> = ir<%sum.05> + reduce.fadd (ir<%0>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sum.05>, ir<%add>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %add, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    CLONE ir<%add> = fadd ir<%0>, ir<%1>
    CLONE store ir<%add>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%0>, ir<%1>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%0>, ir<%1>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd double %0, %1 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %add, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'DAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = fadd double %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %add, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd double %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %add, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450947

-----------------Function that is being costed:'DAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = fadd double %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %add, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DAdd at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%2> = load vp<%6>
    WIDEN ir<%add> = fadd ir<%1>, ir<%2>
    vp<%7> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%7>, ir<%add>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %add, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %add, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %add, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %add, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %add, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    CLONE ir<%add> = fadd ir<%0>, ir<%1>
    CLONE store ir<%add>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%0>, ir<%1>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FAdd' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%0>, ir<%1>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225493

-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FAdd' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add = fadd float %0, %1 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %add, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612793, RTCostB: 19327352823
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612793, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FAdd at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%2> = load vp<%6>
    WIDEN ir<%add> = fadd ir<%1>, ir<%2>
    vp<%7> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%7>, ir<%add>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %0, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %0, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %0, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %0, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'DCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %0, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %0, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'DCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %0, ptr %arrayidx2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DCopy at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%4>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %0, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %0, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %0, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %0, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %0, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FCopy' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FCopy' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %0, ptr %arrayidx2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FCopy at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%4>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 10
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %0 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    EMIT vp<%4> = fmul ir<%0>, ir<%1>
    CLONE ir<%2> = call @llvm.fmuladd.f64(ir<%0>, ir<%1>, ir<%result.08>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: DDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    EMIT vp<%6> = fmul ir<%0>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f64(ir<%0>, ir<%1>, ir<%result.08>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: DDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    EMIT vp<%6> = fmul ir<%0>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f64(ir<%0>, ir<%1>, ir<%result.08>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'DDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %result.08 = phi double [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %0, double %1, double %result.08) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'DDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %result.08 = phi double [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %0, double %1, double %result.08) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %result.08 = phi double [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %0, double %1, double %result.08) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901883

-----------------Function that is being costed:'DDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %result.08 = phi double [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds double, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load double, ptr %arrayidx2, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %0, double %1, double %result.08) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 12884901883
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DDot at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%6>
    EMIT vp<%7> = fmul ir<%0>, ir<%1>
    REDUCE ir<%2> = ir<%result.08> + reduce.fadd (vp<%7>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%result.08>, ir<%2>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 11
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx2>
    EMIT vp<%4> = fmul ir<%0>, ir<%1>
    CLONE ir<%2> = call @llvm.fmuladd.f32(ir<%0>, ir<%1>, ir<%result.08>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa = vp<%7>
}

========== Loop: FDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    EMIT vp<%6> = fmul ir<%0>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f32(ir<%0>, ir<%1>, ir<%result.08>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa = vp<%9>
}

========== Loop: FDot' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%5>
    EMIT vp<%6> = fmul ir<%0>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f32(ir<%0>, ir<%1>, ir<%result.08>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%2>.1 = ir<%result.08> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%result.08>, ir<%2>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa = vp<%9>
}


-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418241, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418241, RTCostB: 12884901883
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418241

-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 10737418241
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FDot' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %result.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %2, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds float, ptr %vec2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load float, ptr %arrayidx2, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %2 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %result.08) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096419, RTCostB: 15032385529
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096419, RTCostB: 5368709131
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FDot at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%result.08> = phi ir<0.000000e+00>, ir<%2>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%vec2>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%1> = load vp<%6>
    EMIT vp<%7> = fmul ir<%0>, ir<%1>
    REDUCE ir<%2> = ir<%result.08> + reduce.fadd (vp<%7>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%result.08>, ir<%2>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out float %.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 12
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store double %div5, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div5, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %div5, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body4.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE store ir<%div5>, ir<%arrayidx7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}

========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body4.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%4>, ir<%div5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}

========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body4.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%4>, ir<%div5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body4.lr.ph ], [ %indvars.iv.next, %for.body4 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx7 = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div5, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body4 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body4.lr.ph ], [ %indvars.iv.next, %for.body4 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx7 = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div5, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body4 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body4.lr.ph ], [ %indvars.iv.next, %for.body4 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx7 = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div5, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body4 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225473

-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body4.lr.ph ], [ %indvars.iv.next, %for.body4 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx7 = getelementptr inbounds double, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %div5, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit35, label %for.body4 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DNorm at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body4.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%5>, ir<%div5>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit35>, scalar.ph

ir-bb<if.end.loopexit35>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %19 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %19 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv29>
    CLONE ir<%19> = load ir<%arrayidx>
    CLONE ir<%div> = fdiv ir<%19>, ir<%call>
    CLONE store ir<%div>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv29>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: DNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv29 = phi 0, %indvars.iv.next30, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv29>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next30> = add nuw nsw ir<%indvars.iv29>, ir<1>
    CLONE ir<%exitcond33.not> = icmp eq ir<%indvars.iv.next30>, ir<%wide.trip.count32>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv29 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %19, %call of type:fdiv
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450946

-----------------Function that is being costed:'DNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv29 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next30, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %vec, i64 %indvars.iv29 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond33.not = icmp eq i64 %indvars.iv.next30, %wide.trip.count32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond33.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: DNorm at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%5>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%div>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 14
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    CLONE store ir<%conv11>, ir<%arrayidx13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit41>, scalar.ph

ir-bb<if.end.loopexit41>:
No successors

scalar.ph:
No successors
}

========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%4>, ir<%conv11>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit41>, scalar.ph

ir-bb<if.end.loopexit41>:
No successors

scalar.ph:
No successors
}

========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%vec>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%4>, ir<%conv11>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit41>, scalar.ph

ir-bb<if.end.loopexit41>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1610612745

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.lr.ph ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx13 = getelementptr inbounds float, ptr %vec, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %conv11, ptr %arrayidx13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit41, label %for.body7 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306393, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306393, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FNorm at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%5>, ir<%conv11>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit41>, scalar.ph

ir-bb<if.end.loopexit41>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %19 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %div, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %19 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load float, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv35>
    CLONE ir<%19> = load ir<%arrayidx>
    CLONE ir<%div> = fdiv ir<%19>, ir<%call>
    CLONE store ir<%div>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond39.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv35>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond39.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: FNorm' from vectorops.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv35 = phi 0, %indvars.iv.next36, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, ir<%indvars.iv35>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next36> = add nuw nsw ir<%indvars.iv35>, ir<1>
    CLONE ir<%exitcond39.not> = icmp eq ir<%indvars.iv.next36>, ir<%wide.trip.count38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225490

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'FNorm' from vectorops.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv35 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next36, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds float, ptr %vec, i64 %indvars.iv35 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %19 = load float, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div = fdiv float %19, %call of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %div, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond39.not = icmp eq i64 %indvars.iv.next36, %wide.trip.count38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond39.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612786, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612786, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: FNorm at line: vectorops.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%vec>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%19> = load vp<%5>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%call>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%div>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 16
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o weight.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                weight.c
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%call9>, ir<%indvars.iv>
    CLONE store ir<0.000000e+00>, ir<%arrayidx17>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    CLONE store ir<0.000000e+00>, ir<%arrayidx19>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%call9>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx19>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%call9>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<0.000000e+00>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx19>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx17 = getelementptr inbounds float, ptr %call9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx19 = getelementptr inbounds float, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float 0.000000e+00, ptr %arrayidx19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: GSCWeights at line: weight.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%call9>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%5>, ir<0.000000e+00>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%call4>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx19>
    WIDEN store vp<%6>, ir<0.000000e+00>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %33, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %33, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %33, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %33, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %33, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%call14>, ir<%indvars.iv75>
    CLONE ir<%33> = load ir<%arrayidx28>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv75>
    CLONE store ir<%33>, ir<%arrayidx30>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end33.loopexit>, scalar.ph

ir-bb<for.end33.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%call14>, ir<%indvars.iv75>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%33> = load vp<%4>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv75>
    vp<%5> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%5>, ir<%33>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end33.loopexit>, scalar.ph

ir-bb<for.end33.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: GSCWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv75 = phi 0, %indvars.iv.next76, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%call14>, ir<%indvars.iv75>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%33> = load vp<%4>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv75>
    vp<%5> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%5>, ir<%33>
    CLONE ir<%indvars.iv.next76> = add nuw nsw ir<%indvars.iv75>, ir<1>
    CLONE ir<%exitcond79.not> = icmp eq ir<%indvars.iv.next76>, ir<%wide.trip.count78>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end33.loopexit>, scalar.ph

ir-bb<for.end33.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483662

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'GSCWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv75 = phi i64 [ 0, %for.body26.preheader ], [ %indvars.iv.next76, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx28 = getelementptr inbounds float, ptr %call14, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %33 = load float, ptr %arrayidx28, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx30 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv75 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %33, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next76 = add nuw nsw i64 %indvars.iv75, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond79.not = icmp eq i64 %indvars.iv.next76, %wide.trip.count78 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond79.not, label %for.end33.loopexit, label %for.body26 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: GSCWeights at line: weight.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%call14>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%37> = load vp<%5>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%wgt>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%6>, ir<%37>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end33.loopexit>, scalar.ph

ir-bb<for.end33.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div258, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div258, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  store float %div258, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div258, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %div258, ptr %arrayidx256, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: VoronoiWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body254.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv459 = phi 0, %indvars.iv.next460, ir<1>
    CLONE ir<%arrayidx256> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv459>
    CLONE ir<%24> = load ir<%arrayidx256>
    CLONE ir<%div258> = fdiv ir<%24>, ir<5.000000e+01>
    CLONE store ir<%div258>, ir<%arrayidx256>
    CLONE ir<%indvars.iv.next460> = add nuw nsw ir<%indvars.iv459>, ir<1>
    CLONE ir<%exitcond463.not> = icmp eq ir<%indvars.iv.next460>, ir<%wide.trip.count462>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end263.loopexit>, scalar.ph

ir-bb<for.end263.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: VoronoiWeights' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body254.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv459 = phi 0, %indvars.iv.next460, ir<1>
    CLONE ir<%arrayidx256> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv459>
    vp<%4> = vector-pointer ir<%arrayidx256>
    WIDEN ir<%24> = load vp<%4>
    WIDEN ir<%div258> = fdiv ir<%24>, ir<5.000000e+01>
    vp<%5> = vector-pointer ir<%arrayidx256>
    WIDEN store vp<%5>, ir<%div258>
    CLONE ir<%indvars.iv.next460> = add nuw nsw ir<%indvars.iv459>, ir<1>
    CLONE ir<%exitcond463.not> = icmp eq ir<%indvars.iv.next460>, ir<%wide.trip.count462>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end263.loopexit>, scalar.ph

ir-bb<for.end263.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: VoronoiWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body254.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv459 = phi 0, %indvars.iv.next460, ir<1>
    CLONE ir<%arrayidx256> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv459>
    vp<%4> = vector-pointer ir<%arrayidx256>
    WIDEN ir<%24> = load vp<%4>
    WIDEN ir<%div258> = fdiv ir<%24>, ir<5.000000e+01>
    vp<%5> = vector-pointer ir<%arrayidx256>
    WIDEN store vp<%5>, ir<%div258>
    CLONE ir<%indvars.iv.next460> = add nuw nsw ir<%indvars.iv459>, ir<1>
    CLONE ir<%exitcond463.not> = icmp eq ir<%indvars.iv.next460>, ir<%wide.trip.count462>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end263.loopexit>, scalar.ph

ir-bb<for.end263.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225490

-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'VoronoiWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv459 = phi i64 [ 0, %for.body254.preheader ], [ %indvars.iv.next460, %for.body254 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx256 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv459 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = load float, ptr %arrayidx256, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div258 = fdiv float %24, 5.000000e+01 of type:fdiv
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %div258, ptr %arrayidx256, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next460 = add nuw nsw i64 %indvars.iv459, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond463.not = icmp eq i64 %indvars.iv.next460, %wide.trip.count462 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond463.not, label %for.end263.loopexit, label %for.body254 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612786, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612786, RTCostB: 3221225490
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: VoronoiWeights at line: weight.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body254.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx256> = getelementptr inbounds ir<%wgt>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx256>
    WIDEN ir<%24> = load vp<%5>
    WIDEN ir<%div258> = fdiv ir<%24>, ir<5.000000e+01>
    vp<%6> = vector-pointer ir<%arrayidx256>
    WIDEN store vp<%6>, ir<%div258>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end263.loopexit>, scalar.ph

ir-bb<for.end263.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: BlosumWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%.pre.pre>, ir<%indvars.iv54>
    CLONE ir<%5> = load ir<%arrayidx19>
    CLONE ir<%idxprom20> = sext ir<%5>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%call>, ir<%idxprom20>
    CLONE ir<%6> = load ir<%arrayidx21>
    CLONE ir<%conv22> = sitofp ir<%6>
    CLONE ir<%conv24> = fdiv ir<1.000000e+00>, ir<%conv22>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv54>
    CLONE store ir<%conv24>, ir<%arrayidx26>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BlosumWeights' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%.pre.pre>, ir<%indvars.iv54>
    vp<%4> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%idxprom20> = sext  ir<%5> to i64
    REPLICATE ir<%arrayidx21> = getelementptr inbounds ir<%call>, ir<%idxprom20>
    REPLICATE ir<%6> = load ir<%arrayidx21>
    WIDEN-CAST ir<%conv22> = sitofp  ir<%6> to float
    WIDEN ir<%conv24> = fdiv ir<1.000000e+00>, ir<%conv22>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv54>
    vp<%5> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%5>, ir<%conv24>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BlosumWeights' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%.pre.pre>, ir<%indvars.iv54>
    vp<%4> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%idxprom20> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx21> = getelementptr inbounds ir<%call>, ir<%idxprom20>
    REPLICATE ir<%6> = load ir<%arrayidx21>
    WIDEN-CAST ir<%conv22> = sitofp  ir<%6> to float
    WIDEN ir<%conv24> = fdiv ir<1.000000e+00>, ir<%conv22>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv54>
    vp<%5> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%5>, ir<%conv24>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BlosumWeights' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%.pre.pre>, ir<%indvars.iv54>
    vp<%4> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%idxprom20> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx21> = getelementptr inbounds ir<%call>, ir<%idxprom20>
    WIDEN ir<%6> = load ir<%arrayidx21>
    WIDEN-CAST ir<%conv22> = sitofp  ir<%6> to float
    WIDEN ir<%conv24> = fdiv ir<1.000000e+00>, ir<%conv22>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%wgt>, ir<%indvars.iv54>
    vp<%5> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%5>, ir<%conv24>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 39728447462, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 39728447462, RTCostB: 23622320117

-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 37044092892, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 37044092892, RTCostB: 23622320117

-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117

-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 25769803761, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: 25769803761, RTCostB: 23622320117

-----------------Function that is being costed:'BlosumWeights' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next55, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx19 = getelementptr inbounds i32, ptr %.pre.pre, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %5 = load i32, ptr %arrayidx19, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom20 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx21 = getelementptr inbounds i32, ptr %call, i64 %idxprom20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %6 = load i32, ptr %arrayidx21, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv22 = sitofp i32 %6 to float of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv24 = fdiv float 1.000000e+00, %conv22 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx26 = getelementptr inbounds float, ptr %wgt, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store float %conv24, ptr %arrayidx26, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond58.not, label %for.end29.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24159191027, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: 24159191027, RTCostB: 23622320117
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: BlosumWeights at line: weight.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%.pre.pre>, vp<%4>
    CLONE ir<%5> = load ir<%arrayidx19>
    CLONE ir<%idxprom20> = sext ir<%5>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%call>, ir<%idxprom20>
    CLONE ir<%6> = load ir<%arrayidx21>
    CLONE ir<%conv22> = sitofp ir<%6>
    CLONE ir<%conv24> = fdiv ir<1.000000e+00>, ir<%conv22>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%wgt>, vp<%4>
    CLONE store ir<%conv24>, ir<%arrayidx26>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end29.loopexit>, scalar.ph

ir-bb<for.end29.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: SingleLinkCluster' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader>, scalar.ph

ir-bb<while.cond.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: SingleLinkCluster' from weight.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%0>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader>, scalar.ph

ir-bb<while.cond.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: SingleLinkCluster' from weight.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%0>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader>, scalar.ph

ir-bb<while.cond.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'SingleLinkCluster' from weight.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %while.cond.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: SingleLinkCluster at line: weight.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nseq to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%0>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader>, scalar.ph

ir-bb<while.cond.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions          alphabet.o core_algorithms.o debug.o display.o emit.o emulation.o fast_algorithms.o histogram.o hmmio.o hmmcalibrate.o hmmsearch.o mathsupport.o masks.o misc.o modelmakers.o plan7.o plan9.o postprob.o prior.o tophits.o trace.o ucbqsort.o a2m.o aligneval.o alignio.o clustal.o cluster.o dayhoff.o eps.o file.o getopt.o gki.o gsi.o hsregex.o iupac.o msa.o msf.o phylip.o revcomp.o rk.o selex.o seqencode.o shuffle.o sqerror.o sqio.o squidcore.o sre_ctype.o sre_math.o sre_random.o sre_string.o ssi.o stack.o stockholm.o translate.o types.o vectorops.o weight.o             -lm        -o hmmer
