/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o av.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        av.c
MVT: v2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div121> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %tmp102.0 = phi %dec, %sub.ptr.div121, ir<-1>
    CLONE ir<%dec> = add nsw ir<%tmp102.0>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr112>, ir<%tmp102.0>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx>
    CLONE ir<%tobool139.old.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%sub.ptr.div121>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end140.loopexit>, scalar.ph

ir-bb<if.end140.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div121> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %tmp102.0 = phi %dec, %sub.ptr.div121, ir<-1>
    CLONE ir<%dec> = add nsw ir<%tmp102.0>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr112>, ir<%tmp102.0>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool139.old.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%sub.ptr.div121>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end140.loopexit>, scalar.ph

ir-bb<if.end140.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div121> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %tmp102.0 = phi %dec, %sub.ptr.div121, ir<-1>
    CLONE ir<%dec> = add nsw ir<%tmp102.0>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr112>, ir<%tmp102.0>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool139.old.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%sub.ptr.div121>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end140.loopexit>, scalar.ph

ir-bb<if.end140.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmp102.0 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div121, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %tmp102.0, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr112, i64 %tmp102.0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool139.old.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool139.old.not, label %if.end140.loopexit, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmp102.0 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div121, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %tmp102.0, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr112, i64 %tmp102.0 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool139.old.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool139.old.not, label %if.end140.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmp102.0 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div121, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %tmp102.0, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr112, i64 %tmp102.0 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool139.old.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool139.old.not, label %if.end140.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmp102.0 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div121, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %tmp102.0, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr112, i64 %tmp102.0 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool139.old.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool139.old.not, label %if.end140.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_av_extend at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div121> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%sub.ptr.div121> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr112>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<@PL_sv_undef>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%sub.ptr.div121>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end140.loopexit>, scalar.ph

ir-bb<if.end140.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%tmp102.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %tmp102.2 = phi %dec256, %tmp102.1, ir<-1>
    CLONE ir<%dec256> = add nsw ir<%tmp102.2>, ir<-1>
    CLONE ir<%arrayidx257> = getelementptr ir<%add.ptr209.pn>, ir<%tmp102.2>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx257>
    CLONE ir<%tobool254.old.not> = icmp eq ir<%dec256>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%tmp102.1>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end259.loopexit>, scalar.ph

ir-bb<if.end259.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%tmp102.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %tmp102.2 = phi %dec256, %tmp102.1, ir<-1>
    CLONE ir<%dec256> = add nsw ir<%tmp102.2>, ir<-1>
    CLONE ir<%arrayidx257> = getelementptr ir<%add.ptr209.pn>, ir<%tmp102.2>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx257>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool254.old.not> = icmp eq ir<%dec256>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%tmp102.1>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end259.loopexit>, scalar.ph

ir-bb<if.end259.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%tmp102.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %tmp102.2 = phi %dec256, %tmp102.1, ir<-1>
    CLONE ir<%dec256> = add nsw ir<%tmp102.2>, ir<-1>
    CLONE ir<%arrayidx257> = getelementptr ir<%add.ptr209.pn>, ir<%tmp102.2>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx257>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool254.old.not> = icmp eq ir<%dec256>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%tmp102.1>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end259.loopexit>, scalar.ph

ir-bb<if.end259.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmp102.2 = phi i64 [ %dec256, %while.body255 ], [ %tmp102.1, %while.body255.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec256 = add nsw i64 %tmp102.2, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx257 = getelementptr ptr, ptr %add.ptr209.pn, i64 %tmp102.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool254.old.not = icmp eq i64 %dec256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool254.old.not, label %if.end259.loopexit, label %while.body255 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmp102.2 = phi i64 [ %dec256, %while.body255 ], [ %tmp102.1, %while.body255.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec256 = add nsw i64 %tmp102.2, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx257 = getelementptr ptr, ptr %add.ptr209.pn, i64 %tmp102.2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool254.old.not = icmp eq i64 %dec256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool254.old.not, label %if.end259.loopexit, label %while.body255 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmp102.2 = phi i64 [ %dec256, %while.body255 ], [ %tmp102.1, %while.body255.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec256 = add nsw i64 %tmp102.2, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx257 = getelementptr ptr, ptr %add.ptr209.pn, i64 %tmp102.2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool254.old.not = icmp eq i64 %dec256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool254.old.not, label %if.end259.loopexit, label %while.body255 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmp102.2 = phi i64 [ %dec256, %while.body255 ], [ %tmp102.1, %while.body255.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec256 = add nsw i64 %tmp102.2, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx257 = getelementptr ptr, ptr %add.ptr209.pn, i64 %tmp102.2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx257, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool254.old.not = icmp eq i64 %dec256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool254.old.not, label %if.end259.loopexit, label %while.body255 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_av_extend at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%tmp102.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%tmp102.1> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%arrayidx257> = getelementptr ir<%add.ptr209.pn>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx257>
    WIDEN store vp<%5>, ir<@PL_sv_undef>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%tmp102.1>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end259.loopexit>, scalar.ph

ir-bb<if.end259.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %52) + (-1 smax %fill))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %key.1193 = phi %inc, %52, ir<1>
    CLONE ir<%inc> = add nsw ir<%key.1193>, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%53>, ir<%inc>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx123>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%spec.store.select>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end125.loopexit>, scalar.ph

ir-bb<if.end125.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %52) + (-1 smax %fill))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %key.1193 = phi %inc, %52, ir<1>
    CLONE ir<%inc> = add nsw ir<%key.1193>, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%53>, ir<%inc>
    vp<%4> = vector-pointer ir<%arrayidx123>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%spec.store.select>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end125.loopexit>, scalar.ph

ir-bb<if.end125.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %52) + (-1 smax %fill))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %key.1193 = phi %inc, %52, ir<1>
    CLONE ir<%inc> = add nsw ir<%key.1193>, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%53>, ir<%inc>
    vp<%4> = vector-pointer ir<%arrayidx123>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%spec.store.select>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end125.loopexit>, scalar.ph

ir-bb<if.end125.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %key.1193 = phi i64 [ %inc, %while.body122 ], [ %52, %while.body122.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i64 %key.1193, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx123 = getelementptr inbounds ptr, ptr %53, i64 %inc of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %inc, %spec.store.select of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end125.loopexit, label %while.body122 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %key.1193 = phi i64 [ %inc, %while.body122 ], [ %52, %while.body122.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i64 %key.1193, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx123 = getelementptr inbounds ptr, ptr %53, i64 %inc of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %inc, %spec.store.select of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end125.loopexit, label %while.body122 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %key.1193 = phi i64 [ %inc, %while.body122 ], [ %52, %while.body122.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nsw i64 %key.1193, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx123 = getelementptr inbounds ptr, ptr %53, i64 %inc of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %inc, %spec.store.select of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end125.loopexit, label %while.body122 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %key.1193 = phi i64 [ %inc, %while.body122 ], [ %52, %while.body122.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i64 %key.1193, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx123 = getelementptr inbounds ptr, ptr %53, i64 %inc of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx123, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %inc, %spec.store.select of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end125.loopexit, label %while.body122 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_av_fill at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %52) + (-1 smax %fill))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%52> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%inc> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%53>, ir<%inc>
    vp<%6> = vector-pointer ir<%arrayidx123>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end125.loopexit>, scalar.ph

ir-bb<if.end125.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%num> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %num.addr.0266 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1265> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr52>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0266>, ir<-1>
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%sp.1265>, ir<8>
    CLONE store ir<@PL_sv_undef>, ir<%incdec.ptr55>
    CLONE ir<%cmp53> = icmp ugt ir<%num.addr.0266>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%num>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr55.lcssa = ir<%incdec.ptr55>
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%num> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %num.addr.0266 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1265> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr52>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0266>, ir<-1>
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%sp.1265>, ir<8>
    vp<%3> = vector-pointer ir<%incdec.ptr55>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%cmp53> = icmp ugt ir<%num.addr.0266>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%num>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr55.lcssa = ir<%incdec.ptr55>
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%num> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %num.addr.0266 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1265> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr52>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0266>, ir<-1>
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%sp.1265>, ir<8>
    vp<%3> = vector-pointer ir<%incdec.ptr55>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%cmp53> = icmp ugt ir<%num.addr.0266>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%num>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr55.lcssa = ir<%incdec.ptr55>
}


-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %num.addr.0266 = phi i64 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.1265 = phi ptr [ %incdec.ptr55, %while.body ], [ %incdec.ptr52, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %num.addr.0266, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %sp.1265, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp53 = icmp ugt i64 %num.addr.0266, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp53, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %num.addr.0266 = phi i64 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.1265 = phi ptr [ %incdec.ptr55, %while.body ], [ %incdec.ptr52, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %num.addr.0266, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %sp.1265, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp53 = icmp ugt i64 %num.addr.0266, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp53, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %num.addr.0266 = phi i64 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.1265 = phi ptr [ %incdec.ptr55, %while.body ], [ %incdec.ptr52, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %num.addr.0266, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %sp.1265, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp53 = icmp ugt i64 %num.addr.0266, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp53, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %num.addr.0266 = phi i64 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.1265 = phi ptr [ %incdec.ptr55, %while.body ], [ %incdec.ptr52, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %num.addr.0266, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %sp.1265, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr55, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp53 = icmp ugt i64 %num.addr.0266, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp53, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_av_unshift at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%num> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%incdec.ptr52>, vp<%4>
    CLONE ir<%incdec.ptr55> = getelementptr inbounds vp<%5>, ir<8>
    vp<%6> = vector-pointer ir<%incdec.ptr55>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%num>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr55.lcssa = ir<%incdec.ptr55>
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then149>:
  EMIT vp<%2> = EXPAND SCEV ((0 smax %77) + %num.addr.1263)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %num.addr.2 = phi %add158, %dec167, ir<-1>
    CLONE ir<%dec167> = add nsw ir<%num.addr.2>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%80>, ir<%dec167>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx>
    CLONE ir<%tobool168.not> = icmp eq ir<%dec167>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then149>:
  EMIT vp<%2> = EXPAND SCEV ((0 smax %77) + %num.addr.1263)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %num.addr.2 = phi %add158, %dec167, ir<-1>
    CLONE ir<%dec167> = add nsw ir<%num.addr.2>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%80>, ir<%dec167>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool168.not> = icmp eq ir<%dec167>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then149>:
  EMIT vp<%2> = EXPAND SCEV ((0 smax %77) + %num.addr.1263)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %num.addr.2 = phi %add158, %dec167, ir<-1>
    CLONE ir<%dec167> = add nsw ir<%num.addr.2>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%80>, ir<%dec167>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool168.not> = icmp eq ir<%dec167>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %num.addr.2 = phi i64 [ %add158, %if.then149 ], [ %dec167, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec167 = add nsw i64 %num.addr.2, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %80, i64 %dec167 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool168.not = icmp eq i64 %dec167, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool168.not, label %do.end, label %do.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %num.addr.2 = phi i64 [ %add158, %if.then149 ], [ %dec167, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec167 = add nsw i64 %num.addr.2, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %80, i64 %dec167 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool168.not = icmp eq i64 %dec167, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool168.not, label %do.end, label %do.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %num.addr.2 = phi i64 [ %add158, %if.then149 ], [ %dec167, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec167 = add nsw i64 %num.addr.2, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %80, i64 %dec167 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool168.not = icmp eq i64 %dec167, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool168.not, label %do.end, label %do.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %num.addr.2 = phi i64 [ %add158, %if.then149 ], [ %dec167, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec167 = add nsw i64 %num.addr.2, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %80, i64 %dec167 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool168.not = icmp eq i64 %dec167, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool168.not, label %do.end, label %do.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_av_unshift at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then149>:
  EMIT vp<%2> = EXPAND SCEV ((0 smax %77) + %num.addr.1263)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%add158> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%dec167> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%80>, ir<%dec167>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o deb.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        deb.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o doio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        doio.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o doop.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        doop.c
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %12 = load i8, ptr %s.068, align 1, !tbaa !23 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.068> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.067> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.068>, ir<1>
    CLONE ir<%12> = load ir<%s.068>
    CLONE ir<%idxprom> = zext ir<%12>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    CLONE ir<%13> = load ir<%arrayidx>
    CLONE ir<%cmp1261> = icmp sgt ir<%13>, ir<-1>
    CLONE ir<%inc> = zext ir<%cmp1261>
    CLONE ir<%spec.select> = add ir<%matches.067>, ir<%inc>
    CLONE ir<%cmp9> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%matches.067>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %spec.select.lcssa = vp<%6>
}

========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.068> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.067> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.068>, ir<1>
    vp<%4> = vector-pointer ir<%s.068>
    WIDEN ir<%12> = load vp<%4>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    REPLICATE ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1261> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1261> to i64
    WIDEN ir<%spec.select> = add ir<%matches.067>, ir<%inc>
    CLONE ir<%cmp9> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%matches.067>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %spec.select.lcssa = vp<%7>
}

========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.068> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.067> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.068>, ir<1>
    vp<%4> = vector-pointer ir<%s.068>
    WIDEN ir<%12> = load vp<%4>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    REPLICATE ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1261> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1261> to i64
    WIDEN ir<%spec.select> = add ir<%matches.067>, ir<%inc>
    CLONE ir<%cmp9> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%matches.067>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %spec.select.lcssa = vp<%7>
}

========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.068> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.067> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.068>, ir<1>
    vp<%4> = vector-pointer ir<%s.068>
    WIDEN ir<%12> = load vp<%4>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    WIDEN ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1261> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1261> to i64
    WIDEN ir<%spec.select> = add ir<%matches.067>, ir<%inc>
    CLONE ir<%cmp9> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%matches.067>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 3 for VF 4 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 69
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 69, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 69
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 69, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 7 for VF 8 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 7 for VF 8 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 8 costs: 17
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 141
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 141, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 141
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 141, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 2 for VF 16 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 15 for VF 16 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 8 for VF 16 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 16 costs: 16
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 267
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 267, CostB * EstimatedWidthA: 112
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 267
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 267, CostB * EstimatedWidthA: 112

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.068 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %matches.067 = phi i64 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.068, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i8, ptr %s.068, align 1, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %13 = load i16, ptr %arrayidx, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1261 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext i1 %cmp1261 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i64 %matches.067, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp9 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp9, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 28
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: S_do_trans_count at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%matches.067> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond>, vp<%4>
    CLONE ir<%12> = load vp<%5>
    CLONE ir<%idxprom> = zext ir<%12>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    CLONE ir<%13> = load ir<%arrayidx>
    CLONE ir<%cmp1261> = icmp sgt ir<%13>, ir<-1>
    CLONE ir<%inc> = zext ir<%cmp1261>
    CLONE ir<%spec.select> = add ir<%matches.067>, ir<%inc>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%matches.067>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %spec.select.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2662> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2661> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2660> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2659 = phi %dec331, %div632, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.2659>, ir<-1>
    CLONE ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.2661>, ir<8>
    CLONE ir<%79> = load ir<%ll.2661>
    CLONE ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.2660>, ir<8>
    CLONE ir<%80> = load ir<%rl.2660>
    CLONE ir<%or336> = or ir<%80>, ir<%79>
    CLONE ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.2662>, ir<8>
    CLONE store ir<%or336>, ir<%dl.2662>
    CLONE ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.2661>, ir<16>
    CLONE ir<%81> = load ir<%incdec.ptr334>
    CLONE ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.2660>, ir<16>
    CLONE ir<%82> = load ir<%incdec.ptr335>
    CLONE ir<%or340> = or ir<%82>, ir<%81>
    CLONE ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.2662>, ir<16>
    CLONE store ir<%or340>, ir<%incdec.ptr337>
    CLONE ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.2661>, ir<24>
    CLONE ir<%83> = load ir<%incdec.ptr338>
    CLONE ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.2660>, ir<24>
    CLONE ir<%84> = load ir<%incdec.ptr339>
    CLONE ir<%or344> = or ir<%84>, ir<%83>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.2662>, ir<24>
    CLONE store ir<%or344>, ir<%incdec.ptr341>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.2661>, ir<32>
    CLONE ir<%85> = load ir<%incdec.ptr342>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.2660>, ir<32>
    CLONE ir<%86> = load ir<%incdec.ptr343>
    CLONE ir<%or348> = or ir<%86>, ir<%85>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.2662>, ir<32>
    CLONE store ir<%or348>, ir<%incdec.ptr345>
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit747>, scalar.ph

ir-bb<if.end353.loopexit747>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2662> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2661> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2660> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2659 = phi %dec331, %div632, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.2659>, ir<-1>
    CLONE ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.2661>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %79, ir<%ll.2661>
      ir<%79> = load from index 0
      ir<%81> = load from index 1
      ir<%83> = load from index 2
      ir<%85> = load from index 3
    CLONE ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.2660>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %80, ir<%rl.2660>
      ir<%80> = load from index 0
      ir<%82> = load from index 1
      ir<%84> = load from index 2
      ir<%86> = load from index 3
    WIDEN ir<%or336> = or ir<%80>, ir<%79>
    CLONE ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.2662>, ir<8>
    CLONE ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.2661>, ir<16>
    CLONE ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.2660>, ir<16>
    WIDEN ir<%or340> = or ir<%82>, ir<%81>
    CLONE ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.2662>, ir<16>
    CLONE ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.2661>, ir<24>
    CLONE ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.2660>, ir<24>
    WIDEN ir<%or344> = or ir<%84>, ir<%83>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.2662>, ir<24>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.2661>, ir<32>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.2660>, ir<32>
    WIDEN ir<%or348> = or ir<%86>, ir<%85>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.2662>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr345>
      store ir<%or336> to index 0
      store ir<%or340> to index 1
      store ir<%or344> to index 2
      store ir<%or348> to index 3
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit747>, scalar.ph

ir-bb<if.end353.loopexit747>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2662> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2661> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2660> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2659 = phi %dec331, %div632, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.2659>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.2661>, ir<8>
    REPLICATE ir<%79> = load ir<%ll.2661>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.2660>, ir<8>
    REPLICATE ir<%80> = load ir<%rl.2660>
    WIDEN ir<%or336> = or ir<%80>, ir<%79>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.2662>, ir<8>
    REPLICATE store ir<%or336>, ir<%dl.2662>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.2661>, ir<16>
    REPLICATE ir<%81> = load ir<%incdec.ptr334>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.2660>, ir<16>
    REPLICATE ir<%82> = load ir<%incdec.ptr335>
    WIDEN ir<%or340> = or ir<%82>, ir<%81>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.2662>, ir<16>
    REPLICATE store ir<%or340>, ir<%incdec.ptr337>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.2661>, ir<24>
    REPLICATE ir<%83> = load ir<%incdec.ptr338>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.2660>, ir<24>
    REPLICATE ir<%84> = load ir<%incdec.ptr339>
    WIDEN ir<%or344> = or ir<%84>, ir<%83>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.2662>, ir<24>
    REPLICATE store ir<%or344>, ir<%incdec.ptr341>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.2661>, ir<32>
    REPLICATE ir<%85> = load ir<%incdec.ptr342>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.2660>, ir<32>
    REPLICATE ir<%86> = load ir<%incdec.ptr343>
    WIDEN ir<%or348> = or ir<%86>, ir<%85>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.2662>, ir<32>
    REPLICATE store ir<%or348>, ir<%incdec.ptr345>
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit747>, scalar.ph

ir-bb<if.end353.loopexit747>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2662> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2661> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2660> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2659 = phi %dec331, %div632, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.2659>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.2661>, ir<8>
    WIDEN ir<%79> = load ir<%ll.2661>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.2660>, ir<8>
    WIDEN ir<%80> = load ir<%rl.2660>
    WIDEN ir<%or336> = or ir<%80>, ir<%79>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.2662>, ir<8>
    WIDEN store ir<%dl.2662>, ir<%or336>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.2661>, ir<16>
    WIDEN ir<%81> = load ir<%incdec.ptr334>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.2660>, ir<16>
    WIDEN ir<%82> = load ir<%incdec.ptr335>
    WIDEN ir<%or340> = or ir<%82>, ir<%81>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.2662>, ir<16>
    WIDEN store ir<%incdec.ptr337>, ir<%or340>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.2661>, ir<24>
    WIDEN ir<%83> = load ir<%incdec.ptr338>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.2660>, ir<24>
    WIDEN ir<%84> = load ir<%incdec.ptr339>
    WIDEN ir<%or344> = or ir<%84>, ir<%83>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.2662>, ir<24>
    WIDEN store ir<%incdec.ptr341>, ir<%or344>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.2661>, ir<32>
    WIDEN ir<%85> = load ir<%incdec.ptr342>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.2660>, ir<32>
    WIDEN ir<%86> = load ir<%incdec.ptr343>
    WIDEN ir<%or348> = or ir<%86>, ir<%85>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.2662>, ir<32>
    WIDEN store ir<%incdec.ptr345>, ir<%or348>
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit747>, scalar.ph

ir-bb<if.end353.loopexit747>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.2662 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.2661 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.2660 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.2659 = phi i64 [ %dec331, %while.body333 ], [ %div632, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec331 = add nsw i64 %len.2659, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr334 = getelementptr inbounds i8, ptr %ll.2661, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %79 = load i64, ptr %ll.2661, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr335 = getelementptr inbounds i8, ptr %rl.2660, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %80 = load i64, ptr %rl.2660, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or336 = or i64 %80, %79 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr337 = getelementptr inbounds i8, ptr %dl.2662, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or336, ptr %dl.2662, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr338 = getelementptr inbounds i8, ptr %ll.2661, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %81 = load i64, ptr %incdec.ptr334, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr339 = getelementptr inbounds i8, ptr %rl.2660, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %82 = load i64, ptr %incdec.ptr335, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or340 = or i64 %82, %81 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr341 = getelementptr inbounds i8, ptr %dl.2662, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or340, ptr %incdec.ptr337, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr342 = getelementptr inbounds i8, ptr %ll.2661, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %83 = load i64, ptr %incdec.ptr338, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr343 = getelementptr inbounds i8, ptr %rl.2660, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %84 = load i64, ptr %incdec.ptr339, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or344 = or i64 %84, %83 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.2662, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or344, ptr %incdec.ptr341, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.2661, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %85 = load i64, ptr %incdec.ptr342, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.2660, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %86 = load i64, ptr %incdec.ptr343, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or348 = or i64 %86, %85 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.2662, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or348, ptr %incdec.ptr345, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool332.not = icmp eq i64 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool332.not, label %if.end353.loopexit747, label %while.body333 of type:br
LV: Scalar loop costs: 30.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.2662 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.2661 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.2660 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.2659 = phi i64 [ %dec331, %while.body333 ], [ %div632, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec331 = add nsw i64 %len.2659, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %79 = load i64, ptr %ll.2661, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %80 = load i64, ptr %rl.2660, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or336 = or i64 %80, %79 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or336, ptr %dl.2662, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %81 = load i64, ptr %incdec.ptr334, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %82 = load i64, ptr %incdec.ptr335, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or340 = or i64 %82, %81 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or340, ptr %incdec.ptr337, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %83 = load i64, ptr %incdec.ptr338, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %84 = load i64, ptr %incdec.ptr339, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or344 = or i64 %84, %83 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.2662, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or344, ptr %incdec.ptr341, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.2661, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %85 = load i64, ptr %incdec.ptr342, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.2660, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %86 = load i64, ptr %incdec.ptr343, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or348 = or i64 %86, %85 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.2662, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i64 %or348, ptr %incdec.ptr345, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool332.not = icmp eq i64 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool332.not, label %if.end353.loopexit747, label %while.body333 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.2662 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.2661 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.2660 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.2659 = phi i64 [ %dec331, %while.body333 ], [ %div632, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec331 = add nsw i64 %len.2659, -1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %79 = load i64, ptr %ll.2661, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %80 = load i64, ptr %rl.2660, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or336 = or i64 %80, %79 of type:or
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or336, ptr %dl.2662, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %81 = load i64, ptr %incdec.ptr334, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %82 = load i64, ptr %incdec.ptr335, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or340 = or i64 %82, %81 of type:or
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or340, ptr %incdec.ptr337, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %83 = load i64, ptr %incdec.ptr338, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %84 = load i64, ptr %incdec.ptr339, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or344 = or i64 %84, %83 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.2662, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or344, ptr %incdec.ptr341, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.2661, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %85 = load i64, ptr %incdec.ptr342, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.2660, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %86 = load i64, ptr %incdec.ptr343, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or348 = or i64 %86, %85 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.2662, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %or348, ptr %incdec.ptr345, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool332.not = icmp eq i64 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool332.not, label %if.end353.loopexit747, label %while.body333 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 60
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.2662 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.2661 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.2660 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.2659 = phi i64 [ %dec331, %while.body333 ], [ %div632, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec331 = add nsw i64 %len.2659, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %79 = load i64, ptr %ll.2661, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %80 = load i64, ptr %rl.2660, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or336 = or i64 %80, %79 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or336, ptr %dl.2662, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %81 = load i64, ptr %incdec.ptr334, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %82 = load i64, ptr %incdec.ptr335, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or340 = or i64 %82, %81 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or340, ptr %incdec.ptr337, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %83 = load i64, ptr %incdec.ptr338, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %84 = load i64, ptr %incdec.ptr339, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or344 = or i64 %84, %83 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.2662, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or344, ptr %incdec.ptr341, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.2661, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %85 = load i64, ptr %incdec.ptr342, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.2660, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %86 = load i64, ptr %incdec.ptr343, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or348 = or i64 %86, %85 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.2662, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   store i64 %or348, ptr %incdec.ptr345, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool332.not = icmp eq i64 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool332.not, label %if.end353.loopexit747, label %while.body333 of type:br
LV: Vector loop of width vscale x 2 costs: 124
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 498, CostB * EstimatedWidthA: 120
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 996, CostB * EstimatedWidthA: 72
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %80, vp<%9>
      ir<%80> = load from index 0
      ir<%82> = load from index 1
      ir<%84> = load from index 2
      ir<%86> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %81, vp<%12>
      ir<%81> = load from index 0
      ir<%83> = load from index 1
      ir<%85> = load from index 2
      ir<%87> = load from index 3
    WIDEN ir<%or336> = or ir<%81>, ir<%80>
    WIDEN ir<%or340> = or ir<%83>, ir<%82>
    WIDEN ir<%or344> = or ir<%85>, ir<%84>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%or348> = or ir<%87>, ir<%86>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr345>
      store ir<%or336> to index 0
      store ir<%or340> to index 1
      store ir<%or344> to index 2
      store ir<%or348> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end353.loopexit747>, scalar.ph

ir-bb<if.end353.loopexit747>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}
================ Final VPlan ================

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body311.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1669> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1668> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1667> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1666 = phi %dec309, %div632, ir<-1>
    CLONE ir<%dec309> = add nsw ir<%len.1666>, ir<-1>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds ir<%ll.1668>, ir<8>
    CLONE ir<%93> = load ir<%ll.1668>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.1667>, ir<8>
    CLONE ir<%94> = load ir<%rl.1667>
    CLONE ir<%xor314> = xor ir<%94>, ir<%93>
    CLONE ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.1669>, ir<8>
    CLONE store ir<%xor314>, ir<%dl.1669>
    CLONE ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.1668>, ir<16>
    CLONE ir<%95> = load ir<%incdec.ptr312>
    CLONE ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.1667>, ir<16>
    CLONE ir<%96> = load ir<%incdec.ptr313>
    CLONE ir<%xor318> = xor ir<%96>, ir<%95>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.1669>, ir<16>
    CLONE store ir<%xor318>, ir<%incdec.ptr315>
    CLONE ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.1668>, ir<24>
    CLONE ir<%97> = load ir<%incdec.ptr316>
    CLONE ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.1667>, ir<24>
    CLONE ir<%98> = load ir<%incdec.ptr317>
    CLONE ir<%xor322> = xor ir<%98>, ir<%97>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.1669>, ir<24>
    CLONE store ir<%xor322>, ir<%incdec.ptr319>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.1668>, ir<32>
    CLONE ir<%99> = load ir<%incdec.ptr320>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.1667>, ir<32>
    CLONE ir<%100> = load ir<%incdec.ptr321>
    CLONE ir<%xor326> = xor ir<%100>, ir<%99>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.1669>, ir<32>
    CLONE store ir<%xor326>, ir<%incdec.ptr323>
    CLONE ir<%tobool310.not> = icmp eq ir<%dec309>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit746>, scalar.ph

ir-bb<if.end353.loopexit746>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body311.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1669> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1668> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1667> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1666 = phi %dec309, %div632, ir<-1>
    CLONE ir<%dec309> = add nsw ir<%len.1666>, ir<-1>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds ir<%ll.1668>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %93, ir<%ll.1668>
      ir<%93> = load from index 0
      ir<%95> = load from index 1
      ir<%97> = load from index 2
      ir<%99> = load from index 3
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.1667>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %94, ir<%rl.1667>
      ir<%94> = load from index 0
      ir<%96> = load from index 1
      ir<%98> = load from index 2
      ir<%100> = load from index 3
    WIDEN ir<%xor314> = xor ir<%94>, ir<%93>
    CLONE ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.1669>, ir<8>
    CLONE ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.1668>, ir<16>
    CLONE ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.1667>, ir<16>
    WIDEN ir<%xor318> = xor ir<%96>, ir<%95>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.1669>, ir<16>
    CLONE ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.1668>, ir<24>
    CLONE ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.1667>, ir<24>
    WIDEN ir<%xor322> = xor ir<%98>, ir<%97>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.1669>, ir<24>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.1668>, ir<32>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.1667>, ir<32>
    WIDEN ir<%xor326> = xor ir<%100>, ir<%99>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.1669>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr323>
      store ir<%xor314> to index 0
      store ir<%xor318> to index 1
      store ir<%xor322> to index 2
      store ir<%xor326> to index 3
    CLONE ir<%tobool310.not> = icmp eq ir<%dec309>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit746>, scalar.ph

ir-bb<if.end353.loopexit746>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body311.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1669> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1668> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1667> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1666 = phi %dec309, %div632, ir<-1>
    CLONE ir<%dec309> = add nsw ir<%len.1666>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr312> = getelementptr inbounds ir<%ll.1668>, ir<8>
    REPLICATE ir<%93> = load ir<%ll.1668>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.1667>, ir<8>
    REPLICATE ir<%94> = load ir<%rl.1667>
    WIDEN ir<%xor314> = xor ir<%94>, ir<%93>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.1669>, ir<8>
    REPLICATE store ir<%xor314>, ir<%dl.1669>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.1668>, ir<16>
    REPLICATE ir<%95> = load ir<%incdec.ptr312>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.1667>, ir<16>
    REPLICATE ir<%96> = load ir<%incdec.ptr313>
    WIDEN ir<%xor318> = xor ir<%96>, ir<%95>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.1669>, ir<16>
    REPLICATE store ir<%xor318>, ir<%incdec.ptr315>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.1668>, ir<24>
    REPLICATE ir<%97> = load ir<%incdec.ptr316>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.1667>, ir<24>
    REPLICATE ir<%98> = load ir<%incdec.ptr317>
    WIDEN ir<%xor322> = xor ir<%98>, ir<%97>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.1669>, ir<24>
    REPLICATE store ir<%xor322>, ir<%incdec.ptr319>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.1668>, ir<32>
    REPLICATE ir<%99> = load ir<%incdec.ptr320>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.1667>, ir<32>
    REPLICATE ir<%100> = load ir<%incdec.ptr321>
    WIDEN ir<%xor326> = xor ir<%100>, ir<%99>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.1669>, ir<32>
    REPLICATE store ir<%xor326>, ir<%incdec.ptr323>
    CLONE ir<%tobool310.not> = icmp eq ir<%dec309>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit746>, scalar.ph

ir-bb<if.end353.loopexit746>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body311.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1669> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1668> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1667> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1666 = phi %dec309, %div632, ir<-1>
    CLONE ir<%dec309> = add nsw ir<%len.1666>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr312> = getelementptr inbounds ir<%ll.1668>, ir<8>
    WIDEN ir<%93> = load ir<%ll.1668>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.1667>, ir<8>
    WIDEN ir<%94> = load ir<%rl.1667>
    WIDEN ir<%xor314> = xor ir<%94>, ir<%93>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.1669>, ir<8>
    WIDEN store ir<%dl.1669>, ir<%xor314>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.1668>, ir<16>
    WIDEN ir<%95> = load ir<%incdec.ptr312>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.1667>, ir<16>
    WIDEN ir<%96> = load ir<%incdec.ptr313>
    WIDEN ir<%xor318> = xor ir<%96>, ir<%95>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.1669>, ir<16>
    WIDEN store ir<%incdec.ptr315>, ir<%xor318>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.1668>, ir<24>
    WIDEN ir<%97> = load ir<%incdec.ptr316>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.1667>, ir<24>
    WIDEN ir<%98> = load ir<%incdec.ptr317>
    WIDEN ir<%xor322> = xor ir<%98>, ir<%97>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.1669>, ir<24>
    WIDEN store ir<%incdec.ptr319>, ir<%xor322>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.1668>, ir<32>
    WIDEN ir<%99> = load ir<%incdec.ptr320>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.1667>, ir<32>
    WIDEN ir<%100> = load ir<%incdec.ptr321>
    WIDEN ir<%xor326> = xor ir<%100>, ir<%99>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.1669>, ir<32>
    WIDEN store ir<%incdec.ptr323>, ir<%xor326>
    CLONE ir<%tobool310.not> = icmp eq ir<%dec309>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit746>, scalar.ph

ir-bb<if.end353.loopexit746>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.1669 = phi ptr [ %incdec.ptr327, %while.body311 ], [ %dc.2, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.1668 = phi ptr [ %incdec.ptr324, %while.body311 ], [ %cond, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.1667 = phi ptr [ %incdec.ptr325, %while.body311 ], [ %cond57, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.1666 = phi i64 [ %dec309, %while.body311 ], [ %div632, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec309 = add nsw i64 %len.1666, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %ll.1668, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %93 = load i64, ptr %ll.1668, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %rl.1667, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %94 = load i64, ptr %rl.1667, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor314 = xor i64 %94, %93 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr315 = getelementptr inbounds i8, ptr %dl.1669, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %xor314, ptr %dl.1669, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr316 = getelementptr inbounds i8, ptr %ll.1668, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %95 = load i64, ptr %incdec.ptr312, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr317 = getelementptr inbounds i8, ptr %rl.1667, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %96 = load i64, ptr %incdec.ptr313, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor318 = xor i64 %96, %95 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dl.1669, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %xor318, ptr %incdec.ptr315, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr320 = getelementptr inbounds i8, ptr %ll.1668, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %97 = load i64, ptr %incdec.ptr316, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr321 = getelementptr inbounds i8, ptr %rl.1667, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %98 = load i64, ptr %incdec.ptr317, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor322 = xor i64 %98, %97 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.1669, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %xor322, ptr %incdec.ptr319, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.1668, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %99 = load i64, ptr %incdec.ptr320, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.1667, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %100 = load i64, ptr %incdec.ptr321, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor326 = xor i64 %100, %99 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.1669, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %xor326, ptr %incdec.ptr323, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool310.not = icmp eq i64 %dec309, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool310.not, label %if.end353.loopexit746, label %while.body311 of type:br
LV: Scalar loop costs: 30.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.1669 = phi ptr [ %incdec.ptr327, %while.body311 ], [ %dc.2, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.1668 = phi ptr [ %incdec.ptr324, %while.body311 ], [ %cond, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.1667 = phi ptr [ %incdec.ptr325, %while.body311 ], [ %cond57, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.1666 = phi i64 [ %dec309, %while.body311 ], [ %div632, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec309 = add nsw i64 %len.1666, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %93 = load i64, ptr %ll.1668, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %94 = load i64, ptr %rl.1667, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor314 = xor i64 %94, %93 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor314, ptr %dl.1669, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %95 = load i64, ptr %incdec.ptr312, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %96 = load i64, ptr %incdec.ptr313, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor318 = xor i64 %96, %95 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor318, ptr %incdec.ptr315, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %97 = load i64, ptr %incdec.ptr316, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %98 = load i64, ptr %incdec.ptr317, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor322 = xor i64 %98, %97 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.1669, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor322, ptr %incdec.ptr319, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.1668, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %99 = load i64, ptr %incdec.ptr320, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.1667, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %100 = load i64, ptr %incdec.ptr321, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor326 = xor i64 %100, %99 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.1669, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i64 %xor326, ptr %incdec.ptr323, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool310.not = icmp eq i64 %dec309, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool310.not, label %if.end353.loopexit746, label %while.body311 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.1669 = phi ptr [ %incdec.ptr327, %while.body311 ], [ %dc.2, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.1668 = phi ptr [ %incdec.ptr324, %while.body311 ], [ %cond, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.1667 = phi ptr [ %incdec.ptr325, %while.body311 ], [ %cond57, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.1666 = phi i64 [ %dec309, %while.body311 ], [ %div632, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec309 = add nsw i64 %len.1666, -1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %93 = load i64, ptr %ll.1668, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %94 = load i64, ptr %rl.1667, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xor314 = xor i64 %94, %93 of type:xor
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor314, ptr %dl.1669, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %95 = load i64, ptr %incdec.ptr312, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %96 = load i64, ptr %incdec.ptr313, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xor318 = xor i64 %96, %95 of type:xor
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor318, ptr %incdec.ptr315, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %97 = load i64, ptr %incdec.ptr316, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %98 = load i64, ptr %incdec.ptr317, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xor322 = xor i64 %98, %97 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.1669, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor322, ptr %incdec.ptr319, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.1668, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %99 = load i64, ptr %incdec.ptr320, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.1667, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %100 = load i64, ptr %incdec.ptr321, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xor326 = xor i64 %100, %99 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.1669, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %xor326, ptr %incdec.ptr323, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool310.not = icmp eq i64 %dec309, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool310.not, label %if.end353.loopexit746, label %while.body311 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 60
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.1669 = phi ptr [ %incdec.ptr327, %while.body311 ], [ %dc.2, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.1668 = phi ptr [ %incdec.ptr324, %while.body311 ], [ %cond, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.1667 = phi ptr [ %incdec.ptr325, %while.body311 ], [ %cond57, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.1666 = phi i64 [ %dec309, %while.body311 ], [ %div632, %while.body311.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec309 = add nsw i64 %len.1666, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %93 = load i64, ptr %ll.1668, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %94 = load i64, ptr %rl.1667, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor314 = xor i64 %94, %93 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor314, ptr %dl.1669, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %95 = load i64, ptr %incdec.ptr312, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %96 = load i64, ptr %incdec.ptr313, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor318 = xor i64 %96, %95 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor318, ptr %incdec.ptr315, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %97 = load i64, ptr %incdec.ptr316, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %98 = load i64, ptr %incdec.ptr317, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor322 = xor i64 %98, %97 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.1669, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor322, ptr %incdec.ptr319, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.1668, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %99 = load i64, ptr %incdec.ptr320, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.1667, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %100 = load i64, ptr %incdec.ptr321, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor326 = xor i64 %100, %99 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.1669, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   store i64 %xor326, ptr %incdec.ptr323, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool310.not = icmp eq i64 %dec309, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool310.not, label %if.end353.loopexit746, label %while.body311 of type:br
LV: Vector loop of width vscale x 2 costs: 124
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 498, CostB * EstimatedWidthA: 120
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 996, CostB * EstimatedWidthA: 72
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body311.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %94, vp<%9>
      ir<%94> = load from index 0
      ir<%96> = load from index 1
      ir<%98> = load from index 2
      ir<%100> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %95, vp<%12>
      ir<%95> = load from index 0
      ir<%97> = load from index 1
      ir<%99> = load from index 2
      ir<%101> = load from index 3
    WIDEN ir<%xor314> = xor ir<%95>, ir<%94>
    WIDEN ir<%xor318> = xor ir<%97>, ir<%96>
    WIDEN ir<%xor322> = xor ir<%99>, ir<%98>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%xor326> = xor ir<%101>, ir<%100>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr323>
      store ir<%xor314> to index 0
      store ir<%xor318> to index 1
      store ir<%xor322> to index 2
      store ir<%xor326> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end353.loopexit746>, scalar.ph

ir-bb<if.end353.loopexit746>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}
================ Final VPlan ================

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body290.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0677> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0676> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0675> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0674 = phi %dec, %div632, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0674>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0676>, ir<8>
    CLONE ir<%107> = load ir<%ll.0676>
    CLONE ir<%incdec.ptr291> = getelementptr inbounds ir<%rl.0675>, ir<8>
    CLONE ir<%108> = load ir<%rl.0675>
    CLONE ir<%and292> = and ir<%108>, ir<%107>
    CLONE ir<%incdec.ptr293> = getelementptr inbounds ir<%dl.0677>, ir<8>
    CLONE store ir<%and292>, ir<%dl.0677>
    CLONE ir<%incdec.ptr294> = getelementptr inbounds ir<%ll.0676>, ir<16>
    CLONE ir<%109> = load ir<%incdec.ptr>
    CLONE ir<%incdec.ptr295> = getelementptr inbounds ir<%rl.0675>, ir<16>
    CLONE ir<%110> = load ir<%incdec.ptr291>
    CLONE ir<%and296> = and ir<%110>, ir<%109>
    CLONE ir<%incdec.ptr297> = getelementptr inbounds ir<%dl.0677>, ir<16>
    CLONE store ir<%and296>, ir<%incdec.ptr293>
    CLONE ir<%incdec.ptr298> = getelementptr inbounds ir<%ll.0676>, ir<24>
    CLONE ir<%111> = load ir<%incdec.ptr294>
    CLONE ir<%incdec.ptr299> = getelementptr inbounds ir<%rl.0675>, ir<24>
    CLONE ir<%112> = load ir<%incdec.ptr295>
    CLONE ir<%and300> = and ir<%112>, ir<%111>
    CLONE ir<%incdec.ptr301> = getelementptr inbounds ir<%dl.0677>, ir<24>
    CLONE store ir<%and300>, ir<%incdec.ptr297>
    CLONE ir<%incdec.ptr302> = getelementptr inbounds ir<%ll.0676>, ir<32>
    CLONE ir<%113> = load ir<%incdec.ptr298>
    CLONE ir<%incdec.ptr303> = getelementptr inbounds ir<%rl.0675>, ir<32>
    CLONE ir<%114> = load ir<%incdec.ptr299>
    CLONE ir<%and304> = and ir<%114>, ir<%113>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds ir<%dl.0677>, ir<32>
    CLONE store ir<%and304>, ir<%incdec.ptr301>
    CLONE ir<%tobool289.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit>, scalar.ph

ir-bb<if.end353.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr302.lcssa = ir<%incdec.ptr302>
Live-out ptr %incdec.ptr303.lcssa = ir<%incdec.ptr303>
Live-out ptr %incdec.ptr305.lcssa = ir<%incdec.ptr305>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body290.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0677> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0676> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0675> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0674 = phi %dec, %div632, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0674>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0676>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %107, ir<%ll.0676>
      ir<%107> = load from index 0
      ir<%109> = load from index 1
      ir<%111> = load from index 2
      ir<%113> = load from index 3
    CLONE ir<%incdec.ptr291> = getelementptr inbounds ir<%rl.0675>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %108, ir<%rl.0675>
      ir<%108> = load from index 0
      ir<%110> = load from index 1
      ir<%112> = load from index 2
      ir<%114> = load from index 3
    WIDEN ir<%and292> = and ir<%108>, ir<%107>
    CLONE ir<%incdec.ptr293> = getelementptr inbounds ir<%dl.0677>, ir<8>
    CLONE ir<%incdec.ptr294> = getelementptr inbounds ir<%ll.0676>, ir<16>
    CLONE ir<%incdec.ptr295> = getelementptr inbounds ir<%rl.0675>, ir<16>
    WIDEN ir<%and296> = and ir<%110>, ir<%109>
    CLONE ir<%incdec.ptr297> = getelementptr inbounds ir<%dl.0677>, ir<16>
    CLONE ir<%incdec.ptr298> = getelementptr inbounds ir<%ll.0676>, ir<24>
    CLONE ir<%incdec.ptr299> = getelementptr inbounds ir<%rl.0675>, ir<24>
    WIDEN ir<%and300> = and ir<%112>, ir<%111>
    CLONE ir<%incdec.ptr301> = getelementptr inbounds ir<%dl.0677>, ir<24>
    CLONE ir<%incdec.ptr302> = getelementptr inbounds ir<%ll.0676>, ir<32>
    CLONE ir<%incdec.ptr303> = getelementptr inbounds ir<%rl.0675>, ir<32>
    WIDEN ir<%and304> = and ir<%114>, ir<%113>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds ir<%dl.0677>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr301>
      store ir<%and292> to index 0
      store ir<%and296> to index 1
      store ir<%and300> to index 2
      store ir<%and304> to index 3
    CLONE ir<%tobool289.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit>, scalar.ph

ir-bb<if.end353.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr302.lcssa = ir<%incdec.ptr302>
Live-out ptr %incdec.ptr303.lcssa = ir<%incdec.ptr303>
Live-out ptr %incdec.ptr305.lcssa = ir<%incdec.ptr305>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body290.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0677> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0676> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0675> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0674 = phi %dec, %div632, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0674>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0676>, ir<8>
    REPLICATE ir<%107> = load ir<%ll.0676>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr291> = getelementptr inbounds ir<%rl.0675>, ir<8>
    REPLICATE ir<%108> = load ir<%rl.0675>
    WIDEN ir<%and292> = and ir<%108>, ir<%107>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr293> = getelementptr inbounds ir<%dl.0677>, ir<8>
    REPLICATE store ir<%and292>, ir<%dl.0677>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr294> = getelementptr inbounds ir<%ll.0676>, ir<16>
    REPLICATE ir<%109> = load ir<%incdec.ptr>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr295> = getelementptr inbounds ir<%rl.0675>, ir<16>
    REPLICATE ir<%110> = load ir<%incdec.ptr291>
    WIDEN ir<%and296> = and ir<%110>, ir<%109>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr297> = getelementptr inbounds ir<%dl.0677>, ir<16>
    REPLICATE store ir<%and296>, ir<%incdec.ptr293>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr298> = getelementptr inbounds ir<%ll.0676>, ir<24>
    REPLICATE ir<%111> = load ir<%incdec.ptr294>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr299> = getelementptr inbounds ir<%rl.0675>, ir<24>
    REPLICATE ir<%112> = load ir<%incdec.ptr295>
    WIDEN ir<%and300> = and ir<%112>, ir<%111>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr301> = getelementptr inbounds ir<%dl.0677>, ir<24>
    REPLICATE store ir<%and300>, ir<%incdec.ptr297>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr302> = getelementptr inbounds ir<%ll.0676>, ir<32>
    REPLICATE ir<%113> = load ir<%incdec.ptr298>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr303> = getelementptr inbounds ir<%rl.0675>, ir<32>
    REPLICATE ir<%114> = load ir<%incdec.ptr299>
    WIDEN ir<%and304> = and ir<%114>, ir<%113>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr305> = getelementptr inbounds ir<%dl.0677>, ir<32>
    REPLICATE store ir<%and304>, ir<%incdec.ptr301>
    CLONE ir<%tobool289.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit>, scalar.ph

ir-bb<if.end353.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr302.lcssa = ir<%incdec.ptr302>
Live-out ptr %incdec.ptr303.lcssa = ir<%incdec.ptr303>
Live-out ptr %incdec.ptr305.lcssa = ir<%incdec.ptr305>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body290.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0677> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0676> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0675> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0674 = phi %dec, %div632, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0674>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0676>, ir<8>
    WIDEN ir<%107> = load ir<%ll.0676>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr291> = getelementptr inbounds ir<%rl.0675>, ir<8>
    WIDEN ir<%108> = load ir<%rl.0675>
    WIDEN ir<%and292> = and ir<%108>, ir<%107>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr293> = getelementptr inbounds ir<%dl.0677>, ir<8>
    WIDEN store ir<%dl.0677>, ir<%and292>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr294> = getelementptr inbounds ir<%ll.0676>, ir<16>
    WIDEN ir<%109> = load ir<%incdec.ptr>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr295> = getelementptr inbounds ir<%rl.0675>, ir<16>
    WIDEN ir<%110> = load ir<%incdec.ptr291>
    WIDEN ir<%and296> = and ir<%110>, ir<%109>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr297> = getelementptr inbounds ir<%dl.0677>, ir<16>
    WIDEN store ir<%incdec.ptr293>, ir<%and296>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr298> = getelementptr inbounds ir<%ll.0676>, ir<24>
    WIDEN ir<%111> = load ir<%incdec.ptr294>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr299> = getelementptr inbounds ir<%rl.0675>, ir<24>
    WIDEN ir<%112> = load ir<%incdec.ptr295>
    WIDEN ir<%and300> = and ir<%112>, ir<%111>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr301> = getelementptr inbounds ir<%dl.0677>, ir<24>
    WIDEN store ir<%incdec.ptr297>, ir<%and300>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr302> = getelementptr inbounds ir<%ll.0676>, ir<32>
    WIDEN ir<%113> = load ir<%incdec.ptr298>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr303> = getelementptr inbounds ir<%rl.0675>, ir<32>
    WIDEN ir<%114> = load ir<%incdec.ptr299>
    WIDEN ir<%and304> = and ir<%114>, ir<%113>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr305> = getelementptr inbounds ir<%dl.0677>, ir<32>
    WIDEN store ir<%incdec.ptr301>, ir<%and304>
    CLONE ir<%tobool289.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end353.loopexit>, scalar.ph

ir-bb<if.end353.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr302.lcssa = ir<%incdec.ptr302>
Live-out ptr %incdec.ptr303.lcssa = ir<%incdec.ptr303>
Live-out ptr %incdec.ptr305.lcssa = ir<%incdec.ptr305>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.0677 = phi ptr [ %incdec.ptr305, %while.body290 ], [ %dc.2, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.0676 = phi ptr [ %incdec.ptr302, %while.body290 ], [ %cond, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.0675 = phi ptr [ %incdec.ptr303, %while.body290 ], [ %cond57, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.0674 = phi i64 [ %dec, %while.body290 ], [ %div632, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %len.0674, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ll.0676, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %107 = load i64, ptr %ll.0676, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr291 = getelementptr inbounds i8, ptr %rl.0675, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %108 = load i64, ptr %rl.0675, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and292 = and i64 %108, %107 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr293 = getelementptr inbounds i8, ptr %dl.0677, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and292, ptr %dl.0677, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr294 = getelementptr inbounds i8, ptr %ll.0676, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %109 = load i64, ptr %incdec.ptr, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr295 = getelementptr inbounds i8, ptr %rl.0675, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %110 = load i64, ptr %incdec.ptr291, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and296 = and i64 %110, %109 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr297 = getelementptr inbounds i8, ptr %dl.0677, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and296, ptr %incdec.ptr293, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr298 = getelementptr inbounds i8, ptr %ll.0676, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %111 = load i64, ptr %incdec.ptr294, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr299 = getelementptr inbounds i8, ptr %rl.0675, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %112 = load i64, ptr %incdec.ptr295, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and300 = and i64 %112, %111 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr301 = getelementptr inbounds i8, ptr %dl.0677, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and300, ptr %incdec.ptr297, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr302 = getelementptr inbounds i8, ptr %ll.0676, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %113 = load i64, ptr %incdec.ptr298, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr303 = getelementptr inbounds i8, ptr %rl.0675, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %114 = load i64, ptr %incdec.ptr299, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and304 = and i64 %114, %113 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %dl.0677, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and304, ptr %incdec.ptr301, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool289.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool289.not, label %if.end353.loopexit, label %while.body290 of type:br
LV: Scalar loop costs: 30.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.0677 = phi ptr [ %incdec.ptr305, %while.body290 ], [ %dc.2, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.0676 = phi ptr [ %incdec.ptr302, %while.body290 ], [ %cond, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.0675 = phi ptr [ %incdec.ptr303, %while.body290 ], [ %cond57, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.0674 = phi i64 [ %dec, %while.body290 ], [ %div632, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %len.0674, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %107 = load i64, ptr %ll.0676, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %108 = load i64, ptr %rl.0675, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and292 = and i64 %108, %107 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and292, ptr %dl.0677, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %109 = load i64, ptr %incdec.ptr, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %110 = load i64, ptr %incdec.ptr291, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and296 = and i64 %110, %109 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and296, ptr %incdec.ptr293, align 8, !tbaa !19 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %111 = load i64, ptr %incdec.ptr294, align 8, !tbaa !19 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %112 = load i64, ptr %incdec.ptr295, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and300 = and i64 %112, %111 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr301 = getelementptr inbounds i8, ptr %dl.0677, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and300, ptr %incdec.ptr297, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr302 = getelementptr inbounds i8, ptr %ll.0676, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %113 = load i64, ptr %incdec.ptr298, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr303 = getelementptr inbounds i8, ptr %rl.0675, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %114 = load i64, ptr %incdec.ptr299, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and304 = and i64 %114, %113 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %dl.0677, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i64 %and304, ptr %incdec.ptr301, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool289.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool289.not, label %if.end353.loopexit, label %while.body290 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.0677 = phi ptr [ %incdec.ptr305, %while.body290 ], [ %dc.2, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.0676 = phi ptr [ %incdec.ptr302, %while.body290 ], [ %cond, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.0675 = phi ptr [ %incdec.ptr303, %while.body290 ], [ %cond57, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.0674 = phi i64 [ %dec, %while.body290 ], [ %div632, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %len.0674, -1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %107 = load i64, ptr %ll.0676, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %108 = load i64, ptr %rl.0675, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and292 = and i64 %108, %107 of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and292, ptr %dl.0677, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %109 = load i64, ptr %incdec.ptr, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %110 = load i64, ptr %incdec.ptr291, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and296 = and i64 %110, %109 of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and296, ptr %incdec.ptr293, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %111 = load i64, ptr %incdec.ptr294, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %112 = load i64, ptr %incdec.ptr295, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and300 = and i64 %112, %111 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr301 = getelementptr inbounds i8, ptr %dl.0677, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and300, ptr %incdec.ptr297, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr302 = getelementptr inbounds i8, ptr %ll.0676, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %113 = load i64, ptr %incdec.ptr298, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr303 = getelementptr inbounds i8, ptr %rl.0675, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %114 = load i64, ptr %incdec.ptr299, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and304 = and i64 %114, %113 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %dl.0677, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and304, ptr %incdec.ptr301, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool289.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool289.not, label %if.end353.loopexit, label %while.body290 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 60
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.0677 = phi ptr [ %incdec.ptr305, %while.body290 ], [ %dc.2, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.0676 = phi ptr [ %incdec.ptr302, %while.body290 ], [ %cond, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.0675 = phi ptr [ %incdec.ptr303, %while.body290 ], [ %cond57, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.0674 = phi i64 [ %dec, %while.body290 ], [ %div632, %while.body290.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %len.0674, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %107 = load i64, ptr %ll.0676, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   %108 = load i64, ptr %rl.0675, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and292 = and i64 %108, %107 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and292, ptr %dl.0677, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %109 = load i64, ptr %incdec.ptr, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %110 = load i64, ptr %incdec.ptr291, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and296 = and i64 %110, %109 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and296, ptr %incdec.ptr293, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %111 = load i64, ptr %incdec.ptr294, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %112 = load i64, ptr %incdec.ptr295, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and300 = and i64 %112, %111 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr301 = getelementptr inbounds i8, ptr %dl.0677, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and300, ptr %incdec.ptr297, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr302 = getelementptr inbounds i8, ptr %ll.0676, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %113 = load i64, ptr %incdec.ptr298, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr303 = getelementptr inbounds i8, ptr %rl.0675, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %114 = load i64, ptr %incdec.ptr299, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and304 = and i64 %114, %113 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %dl.0677, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   store i64 %and304, ptr %incdec.ptr301, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool289.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool289.not, label %if.end353.loopexit, label %while.body290 of type:br
LV: Vector loop of width vscale x 2 costs: 124
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 1, EstimatedWidthB: 1, CostB: 30
CostA * EstimatedWidthB: 498, CostB * EstimatedWidthA: 120
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 498
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 996, CostB * EstimatedWidthA: 72
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body290.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((%21 umin %20) /u 32)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %108, vp<%9>
      ir<%108> = load from index 0
      ir<%110> = load from index 1
      ir<%112> = load from index 2
      ir<%114> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %109, vp<%12>
      ir<%109> = load from index 0
      ir<%111> = load from index 1
      ir<%113> = load from index 2
      ir<%115> = load from index 3
    WIDEN ir<%and292> = and ir<%109>, ir<%108>
    WIDEN ir<%and296> = and ir<%111>, ir<%110>
    WIDEN ir<%and300> = and ir<%113>, ir<%112>
    CLONE ir<%incdec.ptr301> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr302> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr303> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%and304> = and ir<%115>, ir<%114>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr301>
      store ir<%and292> to index 0
      store ir<%and296> to index 1
      store ir<%and300> to index 2
      store ir<%and304> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end353.loopexit>, scalar.ph

ir-bb<if.end353.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr302.lcssa = ir<%incdec.ptr302>
Live-out ptr %incdec.ptr303.lcssa = ir<%incdec.ptr303>
Live-out ptr %incdec.ptr305.lcssa = ir<%incdec.ptr305>
}
================ Final VPlan ================

@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%dc.10685> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.7684> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.7683> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.6682 = phi %dec382, %len.3, ir<-1>
    CLONE ir<%dec382> = add nsw ir<%len.6682>, ir<-1>
    CLONE ir<%incdec.ptr385> = getelementptr inbounds ir<%lc.7684>, ir<1>
    CLONE ir<%157> = load ir<%lc.7684>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%rc.7683>, ir<1>
    CLONE ir<%158> = load ir<%rc.7683>
    CLONE ir<%or389633> = or ir<%158>, ir<%157>
    CLONE ir<%incdec.ptr391> = getelementptr inbounds ir<%dc.10685>, ir<1>
    CLONE store ir<%or389633>, ir<%dc.10685>
    CLONE ir<%tobool383.not> = icmp eq ir<%dec382>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<mop_up.loopexit745>, scalar.ph

ir-bb<mop_up.loopexit745>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.10685> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.7684> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.7683> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.6682 = phi %dec382, %len.3, ir<-1>
    CLONE ir<%dec382> = add nsw ir<%len.6682>, ir<-1>
    CLONE ir<%incdec.ptr385> = getelementptr inbounds ir<%lc.7684>, ir<1>
    vp<%3> = vector-pointer ir<%lc.7684>
    WIDEN ir<%157> = load vp<%3>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%rc.7683>, ir<1>
    vp<%4> = vector-pointer ir<%rc.7683>
    WIDEN ir<%158> = load vp<%4>
    WIDEN ir<%or389633> = or ir<%158>, ir<%157>
    CLONE ir<%incdec.ptr391> = getelementptr inbounds ir<%dc.10685>, ir<1>
    vp<%5> = vector-pointer ir<%dc.10685>
    WIDEN store vp<%5>, ir<%or389633>
    CLONE ir<%tobool383.not> = icmp eq ir<%dec382>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<mop_up.loopexit745>, scalar.ph

ir-bb<mop_up.loopexit745>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.10685> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.7684> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.7683> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.6682 = phi %dec382, %len.3, ir<-1>
    CLONE ir<%dec382> = add nsw ir<%len.6682>, ir<-1>
    CLONE ir<%incdec.ptr385> = getelementptr inbounds ir<%lc.7684>, ir<1>
    vp<%3> = vector-pointer ir<%lc.7684>
    WIDEN ir<%157> = load vp<%3>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%rc.7683>, ir<1>
    vp<%4> = vector-pointer ir<%rc.7683>
    WIDEN ir<%158> = load vp<%4>
    WIDEN ir<%or389633> = or ir<%158>, ir<%157>
    CLONE ir<%incdec.ptr391> = getelementptr inbounds ir<%dc.10685>, ir<1>
    vp<%5> = vector-pointer ir<%dc.10685>
    WIDEN store vp<%5>, ir<%or389633>
    CLONE ir<%tobool383.not> = icmp eq ir<%dec382>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<mop_up.loopexit745>, scalar.ph

ir-bb<mop_up.loopexit745>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.10685 = phi ptr [ %incdec.ptr391, %while.body384 ], [ %dc.7, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.7684 = phi ptr [ %incdec.ptr385, %while.body384 ], [ %lc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.7683 = phi ptr [ %incdec.ptr387, %while.body384 ], [ %rc.4, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.6682 = phi i64 [ %dec382, %while.body384 ], [ %len.3, %while.body384.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec382 = add nsw i64 %len.6682, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr385 = getelementptr inbounds i8, ptr %lc.7684, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %157 = load i8, ptr %lc.7684, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %rc.7683, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %158 = load i8, ptr %rc.7683, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or389633 = or i8 %158, %157 of type:or
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr391 = getelementptr inbounds i8, ptr %dc.10685, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %or389633, ptr %dc.10685, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool383.not = icmp eq i64 %dec382, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool383.not, label %mop_up.loopexit745, label %while.body384 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_do_vop at line: doop.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%163> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%164> = load vp<%10>
    WIDEN ir<%or389633> = or ir<%164>, ir<%163>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%or389633>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<mop_up.loopexit745>, scalar.ph

ir-bb<mop_up.loopexit745>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%204> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%205> = load vp<%10>
    WIDEN ir<%or389633> = or ir<%205>, ir<%204>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%or389633>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<mop_up.loopexit745>, scalar.ph

ir-bb<mop_up.loopexit745>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%dc.9690> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.6689> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.6688> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.5687 = phi %dec369, %len.3, ir<-1>
    CLONE ir<%dec369> = add nsw ir<%len.5687>, ir<-1>
    CLONE ir<%incdec.ptr372> = getelementptr inbounds ir<%lc.6689>, ir<1>
    CLONE ir<%216> = load ir<%lc.6689>
    CLONE ir<%incdec.ptr374> = getelementptr inbounds ir<%rc.6688>, ir<1>
    CLONE ir<%217> = load ir<%rc.6688>
    CLONE ir<%xor376634> = xor ir<%217>, ir<%216>
    CLONE ir<%incdec.ptr378> = getelementptr inbounds ir<%dc.9690>, ir<1>
    CLONE store ir<%xor376634>, ir<%dc.9690>
    CLONE ir<%tobool370.not> = icmp eq ir<%dec369>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.9690> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.6689> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.6688> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.5687 = phi %dec369, %len.3, ir<-1>
    CLONE ir<%dec369> = add nsw ir<%len.5687>, ir<-1>
    CLONE ir<%incdec.ptr372> = getelementptr inbounds ir<%lc.6689>, ir<1>
    vp<%3> = vector-pointer ir<%lc.6689>
    WIDEN ir<%216> = load vp<%3>
    CLONE ir<%incdec.ptr374> = getelementptr inbounds ir<%rc.6688>, ir<1>
    vp<%4> = vector-pointer ir<%rc.6688>
    WIDEN ir<%217> = load vp<%4>
    WIDEN ir<%xor376634> = xor ir<%217>, ir<%216>
    CLONE ir<%incdec.ptr378> = getelementptr inbounds ir<%dc.9690>, ir<1>
    vp<%5> = vector-pointer ir<%dc.9690>
    WIDEN store vp<%5>, ir<%xor376634>
    CLONE ir<%tobool370.not> = icmp eq ir<%dec369>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.9690> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.6689> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.6688> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.5687 = phi %dec369, %len.3, ir<-1>
    CLONE ir<%dec369> = add nsw ir<%len.5687>, ir<-1>
    CLONE ir<%incdec.ptr372> = getelementptr inbounds ir<%lc.6689>, ir<1>
    vp<%3> = vector-pointer ir<%lc.6689>
    WIDEN ir<%216> = load vp<%3>
    CLONE ir<%incdec.ptr374> = getelementptr inbounds ir<%rc.6688>, ir<1>
    vp<%4> = vector-pointer ir<%rc.6688>
    WIDEN ir<%217> = load vp<%4>
    WIDEN ir<%xor376634> = xor ir<%217>, ir<%216>
    CLONE ir<%incdec.ptr378> = getelementptr inbounds ir<%dc.9690>, ir<1>
    vp<%5> = vector-pointer ir<%dc.9690>
    WIDEN store vp<%5>, ir<%xor376634>
    CLONE ir<%tobool370.not> = icmp eq ir<%dec369>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.9690 = phi ptr [ %incdec.ptr378, %while.body371 ], [ %dc.7, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.6689 = phi ptr [ %incdec.ptr372, %while.body371 ], [ %lc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.6688 = phi ptr [ %incdec.ptr374, %while.body371 ], [ %rc.4, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.5687 = phi i64 [ %dec369, %while.body371 ], [ %len.3, %while.body371.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec369 = add nsw i64 %len.5687, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr372 = getelementptr inbounds i8, ptr %lc.6689, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %216 = load i8, ptr %lc.6689, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr374 = getelementptr inbounds i8, ptr %rc.6688, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %217 = load i8, ptr %rc.6688, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %xor376634 = xor i8 %217, %216 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr378 = getelementptr inbounds i8, ptr %dc.9690, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %xor376634, ptr %dc.9690, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool370.not = icmp eq i64 %dec369, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool370.not, label %mop_up.loopexit, label %while.body371 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_do_vop at line: doop.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%222> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%223> = load vp<%10>
    WIDEN ir<%xor376634> = xor ir<%223>, ir<%222>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%xor376634>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%263> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%264> = load vp<%10>
    WIDEN ir<%xor376634> = xor ir<%264>, ir<%263>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%xor376634>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%dc.8695> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.5694> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.5693> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.4692 = phi %dec356, %len.3, ir<-1>
    CLONE ir<%dec356> = add nsw ir<%len.4692>, ir<-1>
    CLONE ir<%incdec.ptr359> = getelementptr inbounds ir<%lc.5694>, ir<1>
    CLONE ir<%275> = load ir<%lc.5694>
    CLONE ir<%incdec.ptr361> = getelementptr inbounds ir<%rc.5693>, ir<1>
    CLONE ir<%276> = load ir<%rc.5693>
    CLONE ir<%and363635> = and ir<%276>, ir<%275>
    CLONE ir<%incdec.ptr365> = getelementptr inbounds ir<%dc.8695>, ir<1>
    CLONE store ir<%and363635>, ir<%dc.8695>
    CLONE ir<%tobool357.not> = icmp eq ir<%dec356>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.8695> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.5694> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.5693> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.4692 = phi %dec356, %len.3, ir<-1>
    CLONE ir<%dec356> = add nsw ir<%len.4692>, ir<-1>
    CLONE ir<%incdec.ptr359> = getelementptr inbounds ir<%lc.5694>, ir<1>
    vp<%3> = vector-pointer ir<%lc.5694>
    WIDEN ir<%275> = load vp<%3>
    CLONE ir<%incdec.ptr361> = getelementptr inbounds ir<%rc.5693>, ir<1>
    vp<%4> = vector-pointer ir<%rc.5693>
    WIDEN ir<%276> = load vp<%4>
    WIDEN ir<%and363635> = and ir<%276>, ir<%275>
    CLONE ir<%incdec.ptr365> = getelementptr inbounds ir<%dc.8695>, ir<1>
    vp<%5> = vector-pointer ir<%dc.8695>
    WIDEN store vp<%5>, ir<%and363635>
    CLONE ir<%tobool357.not> = icmp eq ir<%dec356>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dc.8695> = WIDEN-POINTER-INDUCTION ir<%dc.7>, 1
    EMIT ir<%lc.5694> = WIDEN-POINTER-INDUCTION ir<%lc.4>, 1
    EMIT ir<%rc.5693> = WIDEN-POINTER-INDUCTION ir<%rc.4>, 1
    WIDEN-INDUCTION %len.4692 = phi %dec356, %len.3, ir<-1>
    CLONE ir<%dec356> = add nsw ir<%len.4692>, ir<-1>
    CLONE ir<%incdec.ptr359> = getelementptr inbounds ir<%lc.5694>, ir<1>
    vp<%3> = vector-pointer ir<%lc.5694>
    WIDEN ir<%275> = load vp<%3>
    CLONE ir<%incdec.ptr361> = getelementptr inbounds ir<%rc.5693>, ir<1>
    vp<%4> = vector-pointer ir<%rc.5693>
    WIDEN ir<%276> = load vp<%4>
    WIDEN ir<%and363635> = and ir<%276>, ir<%275>
    CLONE ir<%incdec.ptr365> = getelementptr inbounds ir<%dc.8695>, ir<1>
    vp<%5> = vector-pointer ir<%dc.8695>
    WIDEN store vp<%5>, ir<%and363635>
    CLONE ir<%tobool357.not> = icmp eq ir<%dec356>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.8695 = phi ptr [ %incdec.ptr365, %while.body358 ], [ %dc.7, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.5694 = phi ptr [ %incdec.ptr359, %while.body358 ], [ %lc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.5693 = phi ptr [ %incdec.ptr361, %while.body358 ], [ %rc.4, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.4692 = phi i64 [ %dec356, %while.body358 ], [ %len.3, %while.body358.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec356 = add nsw i64 %len.4692, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %lc.5694, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %275 = load i8, ptr %lc.5694, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rc.5693, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %276 = load i8, ptr %rc.5693, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %and363635 = and i8 %276, %275 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %dc.8695, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %and363635, ptr %dc.8695, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool357.not = icmp eq i64 %dec356, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool357.not, label %finish.loopexit, label %while.body358 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_do_vop at line: doop.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%281> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%282> = load vp<%10>
    WIDEN ir<%and363635> = and ir<%282>, ir<%281>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%and363635>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len.3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%dc.7>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%lc.4>, vp<%5>
    vp<%7> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%8> = ptradd ir<%rc.4>, vp<%7>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%322> = load vp<%9>
    vp<%10> = vector-pointer vp<%8>
    WIDEN ir<%323> = load vp<%10>
    WIDEN ir<%and363635> = and ir<%323>, ir<%322>
    vp<%11> = vector-pointer vp<%4>
    WIDEN store vp<%11>, ir<%and363635>
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<%len.3>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 38
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dump.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        dump.c
MVT: v2i32
@@ Instruction =>  %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body635.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond586>) smax %max.01600) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1629 = phi %indvars.iv.next1630, %149, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01605> = phi ir<0.000000e+00>, ir<%add641>.1
    CLONE ir<%arrayidx637> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1629>
    CLONE ir<%154> = load ir<%arrayidx637>
    CLONE ir<%155> = trunc ir<%indvars.iv1629>
    CLONE ir<%mul638> = mul ir<%155>, ir<%155>
    CLONE ir<%mul639> = mul ir<%mul638>, ir<%154>
    CLONE ir<%conv640> = sitofp ir<%mul639>
    CLONE ir<%add641> = fadd ir<%sum.01605>, ir<%conv640>
    CLONE ir<%indvars.iv.next1630> = add nsw ir<%indvars.iv1629>, ir<-1>
    CLONE ir<%cmp633> = icmp sgt ir<%indvars.iv1629>, ir<1>
    REDUCE ir<%add641>.1 = ir<%sum.01605> + reduce.fadd (ir<%conv640>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.01605>, ir<%add641>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add641.lcssa = vp<%6>
}

========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body635.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond586>) smax %max.01600) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1629 = phi %indvars.iv.next1630, %149, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01605> = phi ir<0.000000e+00>, ir<%add641>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1629 = phi %indvars.iv.next1630, %149\l" +
    "  ir<%155>, ir<-1>
    CLONE ir<%arrayidx637> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1629>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx637>
    WIDEN ir<%154> = load vp<%4>
    WIDEN ir<%mul638> = mul ir<%155>, ir<%155>
    WIDEN ir<%mul639> = mul ir<%mul638>, ir<%154>
    WIDEN-CAST ir<%conv640> = sitofp  ir<%mul639> to double
    WIDEN ir<%add641> = fadd ir<%sum.01605>, ir<%conv640>
    WIDEN ir<%indvars.iv.next1630> = add nsw ir<%indvars.iv1629>, ir<-1>
    CLONE ir<%cmp633> = icmp sgt ir<%indvars.iv1629>, ir<1>
    REDUCE ir<%add641>.1 = ir<%sum.01605> + reduce.fadd (ir<%conv640>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.01605>, ir<%add641>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add641.lcssa = vp<%7>
}

========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body635.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond586>) smax %max.01600) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1629 = phi %indvars.iv.next1630, %149, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01605> = phi ir<0.000000e+00>, ir<%add641>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1629 = phi %indvars.iv.next1630, %149\l" +
    "  ir<%155>, ir<-1>
    CLONE ir<%arrayidx637> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1629>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx637>
    WIDEN ir<%154> = load vp<%4>
    WIDEN ir<%mul638> = mul ir<%155>, ir<%155>
    WIDEN ir<%mul639> = mul ir<%mul638>, ir<%154>
    WIDEN-CAST ir<%conv640> = sitofp  ir<%mul639> to double
    WIDEN ir<%add641> = fadd ir<%sum.01605>, ir<%conv640>
    WIDEN ir<%indvars.iv.next1630> = add nsw ir<%indvars.iv1629>, ir<-1>
    CLONE ir<%cmp633> = icmp sgt ir<%indvars.iv1629>, ir<1>
    REDUCE ir<%add641>.1 = ir<%sum.01605> + reduce.fadd (ir<%conv640>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.01605>, ir<%add641>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add641.lcssa = vp<%7>
}


-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 15032385530, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385530, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 4 for VF 4 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 15032385530
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5905580045, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905580045, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1629 = phi i64 [ %indvars.iv.next1630, %for.body635 ], [ %149, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sum.01605 = phi double [ %add641, %for.body635 ], [ 0.000000e+00, %for.body635.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx637 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1629 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %154 = load i32, ptr %arrayidx637, align 4, !tbaa !55 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %155 = trunc nuw nsw i64 %indvars.iv1629 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %mul638 = mul i32 %155, %155 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %mul639 = mul i32 %mul638, %154 of type:mul
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %conv640 = sitofp i32 %mul639 to double of type:sitofp
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add641 = fadd double %sum.01605, %conv640 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1630 = add nsw i64 %indvars.iv1629, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp633 = icmp sgt i64 %indvars.iv1629, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp633, label %for.body635, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4831838246, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4831838246, RTCostB: 5905580045
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Perl_do_sv_dump at line: dump.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body635.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond586>) smax %max.01600) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum.01605> = phi ir<0.000000e+00>, ir<%add641>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1629 = phi %indvars.iv.next1630, %149\l" +
    "  ir<%155>, ir<-1>
    vp<%4>    = DERIVED-IV ir<%149> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx637> = getelementptr inbounds ir<%freq>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx637>
    WIDEN ir<%154> = load vp<%6>
    WIDEN ir<%mul638> = mul ir<%155>, ir<%155>
    WIDEN ir<%mul639> = mul ir<%mul638>, ir<%154>
    WIDEN-CAST ir<%conv640> = sitofp  ir<%mul639> to double
    REDUCE ir<%add641> = ir<%sum.01605> + reduce.fadd (ir<%conv640>)
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum.01605>, ir<%add641>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add641.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o globals.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        globals.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o gv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        gv.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        hv.c
========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    CLONE ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%he.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    REPLICATE store ir<%add.ptr.ptr>, ir<%he.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    REPLICATE store ir<%add.ptr.ptr>, ir<%he.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    WIDEN store ir<%he.0.ptr13>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 2688, RTCostB: 672
A is not scalable.	B is not scalable.	
RTCostA: 2688, RTCostB: 672

-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 672
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 672

-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 1806, RTCostB: 672
A is scalable.	B is not scalable.	
RTCostA: 1806, RTCostB: 672
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: S_more_he at line: hv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<24>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<24>
    EMIT vp<%5> = ptradd ir<%incdec.ptr.ptr>, vp<%4>
    vp<%6>    = DERIVED-IV ir<24> + vp<%2> * ir<24>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<24>
    CLONE ir<%he.0.add> = add nuw nsw vp<%7>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    CLONE store ir<%add.ptr.ptr>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o locale.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        locale.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mg.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        mg.c
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i185.0882 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0881> = phi ir<0>, ir<%or204>
    WIDEN-REDUCTION-PHI ir<%accumulate.0880> = phi ir<0>, ir<%or200>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond196>, ir<%i185.0882>
    CLONE ir<%54> = load ir<%arrayidx>
    CLONE ir<%conv199> = zext ir<%54>
    CLONE ir<%or200> = or ir<%accumulate.0880>, ir<%conv199>
    CLONE ir<%and203> = and ir<%conv199>, ir<170>
    CLONE ir<%or204> = or ir<%and203>, ir<%any_fatals.0881>
    CLONE ir<%inc> = add nuw ir<%i185.0882>, ir<1>
    CLONE ir<%exitcond884.not> = icmp eq ir<%inc>, ir<%53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = compute-reduction-result ir<%any_fatals.0881>, ir<%or204>
  EMIT vp<%6> = compute-reduction-result ir<%accumulate.0880>, ir<%or200>
  EMIT vp<%7> = icmp eq ir<%53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or200.lcssa = vp<%6>
Live-out i32 %or204.lcssa = vp<%5>
}

========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i185.0882 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0881> = phi ir<0>, ir<%or204>
    WIDEN-REDUCTION-PHI ir<%accumulate.0880> = phi ir<0>, ir<%or200>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond196>, ir<%i185.0882>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%54> = load vp<%3>
    WIDEN-CAST ir<%conv199> = zext  ir<%54> to i32
    WIDEN ir<%or200> = or ir<%accumulate.0880>, ir<%conv199>
    WIDEN ir<%and203> = and ir<%conv199>, ir<170>
    WIDEN ir<%or204> = or ir<%and203>, ir<%any_fatals.0881>
    CLONE ir<%inc> = add nuw ir<%i185.0882>, ir<1>
    CLONE ir<%exitcond884.not> = icmp eq ir<%inc>, ir<%53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%any_fatals.0881>, ir<%or204>
  EMIT vp<%7> = compute-reduction-result ir<%accumulate.0880>, ir<%or200>
  EMIT vp<%8> = icmp eq ir<%53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or200.lcssa = vp<%7>
Live-out i32 %or204.lcssa = vp<%6>
}

========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i185.0882 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0881> = phi ir<0>, ir<%or204>
    WIDEN-REDUCTION-PHI ir<%accumulate.0880> = phi ir<0>, ir<%or200>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond196>, ir<%i185.0882>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%54> = load vp<%3>
    WIDEN-CAST ir<%conv199> = zext  ir<%54> to i32
    WIDEN ir<%or200> = or ir<%accumulate.0880>, ir<%conv199>
    WIDEN ir<%and203> = and ir<%conv199>, ir<170>
    WIDEN ir<%or204> = or ir<%and203>, ir<%any_fatals.0881>
    CLONE ir<%inc> = add nuw ir<%i185.0882>, ir<1>
    CLONE ir<%exitcond884.not> = icmp eq ir<%inc>, ir<%53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%any_fatals.0881>, ir<%or204>
  EMIT vp<%7> = compute-reduction-result ir<%accumulate.0880>, ir<%or200>
  EMIT vp<%8> = icmp eq ir<%53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or200.lcssa = vp<%7>
Live-out i32 %or204.lcssa = vp<%6>
}


-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 3 for VF 8 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 12
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 6 for VF 16 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 4 for VF 16 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 4 for VF 16 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 21
B VF: 8, EstimatedWidthB: 8, CostB: 12
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 21
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 42

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 21
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 84

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i185.0882 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %any_fatals.0881 = phi i32 [ %or204, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %accumulate.0880 = phi i32 [ %or200, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond196, i64 %i185.0882 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %54 = load i8, ptr %arrayidx, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv199 = zext i8 %54 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or200 = or i32 %accumulate.0880, %conv199 of type:or
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and203 = and i32 %conv199, 170 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or204 = or i32 %and203, %any_fatals.0881 of type:or
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = add nuw i64 %i185.0882, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond884.not = icmp eq i64 %inc, %53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond884.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 21
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: Perl_magic_set at line: mg.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0881> = phi ir<0>, ir<%or204>
    WIDEN-REDUCTION-PHI ir<%accumulate.0880> = phi ir<0>, ir<%or200>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond196>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%54> = load vp<%4>
    WIDEN-CAST ir<%conv199> = zext  ir<%54> to i32
    WIDEN ir<%or200> = or ir<%accumulate.0880>, ir<%conv199>
    WIDEN ir<%and203> = and ir<%conv199>, ir<170>
    WIDEN ir<%or204> = or ir<%and203>, ir<%any_fatals.0881>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%any_fatals.0881>, ir<%or204>
  EMIT vp<%8> = compute-reduction-result ir<%accumulate.0880>, ir<%or200>
  EMIT vp<%9> = icmp eq ir<%53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or200.lcssa = vp<%8>
Live-out i32 %or204.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o numeric.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        numeric.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o op.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        op.c
MVT: v2i32
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    CLONE ir<%7> = load ir<%add.ptr69>
    CLONE store ir<%7>, ir<%p.1169>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%p.1169>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%p.1169>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %7 = load i8, ptr %add.ptr69, align 1, !tbaa !10 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %7, ptr %p.1169, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_allocmy at line: op.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_allocmy at line: op.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%p.0>, vp<%5>
    CLONE ir<%add.ptr69> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%7> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%7>
    vp<%8> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%8>, ir<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_allocmy at line: op.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%p.0>, vp<%4>
    CLONE ir<%add.ptr69> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%6> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%50> = load vp<%6>
    vp<%7> = vector-pointer (reverse) vp<%5>
    WIDEN store vp<%7>, ir<%50>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pmtrans' from op.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body488.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %j.3) + %68)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.3932 = phi %inc495, 0, ir<1>
    CLONE ir<%add489> = add nsw ir<%i.3932>, ir<%j.3>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%cond14>, ir<%add489>
    CLONE ir<%69> = load ir<%arrayidx490>
    CLONE ir<%conv491> = zext ir<%69>
    CLONE ir<%add492> = add nuw nsw ir<%i.3932>, ir<257>
    CLONE ir<%arrayidx493> = getelementptr inbounds ir<%tbl.0>, ir<%add492>
    CLONE store ir<%conv491>, ir<%arrayidx493>
    CLONE ir<%inc495> = add nuw nsw ir<%i.3932>, ir<1>
    CLONE ir<%exitcond943.not> = icmp eq ir<%inc495>, ir<%sub481>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end583.loopexit975>, scalar.ph

ir-bb<if.end583.loopexit975>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pmtrans' from op.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body488.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %j.3) + %68)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.3932 = phi %inc495, 0, ir<1>
    CLONE ir<%add489> = add nsw ir<%i.3932>, ir<%j.3>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%cond14>, ir<%add489>
    vp<%4> = vector-pointer ir<%arrayidx490>
    WIDEN ir<%69> = load vp<%4>
    WIDEN-CAST ir<%conv491> = zext  ir<%69> to i16
    CLONE ir<%add492> = add nuw nsw ir<%i.3932>, ir<257>
    CLONE ir<%arrayidx493> = getelementptr inbounds ir<%tbl.0>, ir<%add492>
    vp<%5> = vector-pointer ir<%arrayidx493>
    WIDEN store vp<%5>, ir<%conv491>
    CLONE ir<%inc495> = add nuw nsw ir<%i.3932>, ir<1>
    CLONE ir<%exitcond943.not> = icmp eq ir<%inc495>, ir<%sub481>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end583.loopexit975>, scalar.ph

ir-bb<if.end583.loopexit975>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pmtrans' from op.c==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body488.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %j.3) + %68)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.3932 = phi %inc495, 0, ir<1>
    CLONE ir<%add489> = add nsw ir<%i.3932>, ir<%j.3>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%cond14>, ir<%add489>
    vp<%4> = vector-pointer ir<%arrayidx490>
    WIDEN ir<%69> = load vp<%4>
    WIDEN-CAST ir<%conv491> = zext  ir<%69> to i16
    CLONE ir<%add492> = add nuw nsw ir<%i.3932>, ir<257>
    CLONE ir<%arrayidx493> = getelementptr inbounds ir<%tbl.0>, ir<%add492>
    vp<%5> = vector-pointer ir<%arrayidx493>
    WIDEN store vp<%5>, ir<%conv491>
    CLONE ir<%inc495> = add nuw nsw ir<%i.3932>, ir<1>
    CLONE ir<%exitcond943.not> = icmp eq ir<%inc495>, ir<%sub481>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end583.loopexit975>, scalar.ph

ir-bb<if.end583.loopexit975>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 16 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF 16 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 16 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 72

-----------------Function that is being costed:'Perl_pmtrans' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.3932 = phi i64 [ %inc495, %for.body488 ], [ 0, %for.body488.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %add489 = add nsw i64 %i.3932, %j.3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx490 = getelementptr inbounds i8, ptr %cond14, i64 %add489 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %69 = load i8, ptr %arrayidx490, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv491 = zext i8 %69 to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %add492 = add nuw nsw i64 %i.3932, 257 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx493 = getelementptr inbounds i16, ptr %tbl.0, i64 %add492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %conv491, ptr %arrayidx493, align 2, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %inc495 = add nuw nsw i64 %i.3932, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond943.not = icmp eq i64 %inc495, %sub481 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond943.not, label %if.end583.loopexit975, label %for.body488 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 56
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: Perl_pmtrans at line: op.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: Perl_pmtrans at line: op.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body488.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %j.3) + %68)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%add489> = add nsw vp<%4>, ir<%j.3>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%cond14>, ir<%add489>
    vp<%5> = vector-pointer ir<%arrayidx490>
    WIDEN ir<%73> = load vp<%5>
    WIDEN-CAST ir<%conv491> = zext  ir<%73> to i16
    CLONE ir<%add492> = add nuw nsw vp<%4>, ir<257>
    CLONE ir<%arrayidx493> = getelementptr inbounds ir<%tbl.0>, ir<%add492>
    vp<%6> = vector-pointer ir<%arrayidx493>
    WIDEN store vp<%6>, ir<%conv491>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end583.loopexit975>, scalar.ph

ir-bb<if.end583.loopexit975>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: Perl_pmtrans at line: op.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub481> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%add489> = add nsw vp<%3>, ir<%j.3>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%cond14>, ir<%add489>
    vp<%4> = vector-pointer ir<%arrayidx490>
    WIDEN ir<%106> = load vp<%4>
    WIDEN-CAST ir<%conv491> = zext  ir<%106> to i16
    CLONE ir<%add492> = add nuw nsw vp<%3>, ir<257>
    CLONE ir<%arrayidx493> = getelementptr inbounds ir<%tbl.0>, ir<%add492>
    vp<%5> = vector-pointer ir<%arrayidx493>
    WIDEN store vp<%5>, ir<%conv491>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%sub481>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end583.loopexit975>, scalar.ph

ir-bb<if.end583.loopexit975>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 39
Loops Epilogues Vectorized: 2
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pad.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pad.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o perl.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        perl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o perlapi.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        perlapi.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o perlio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        perlio.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o perlmain.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        perlmain.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o perly.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        perly.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp.c
@@ Instruction =>  %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body209.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %anum.0.lcssa) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%tmpl.0378> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1377 = phi %sub, %anum.0.lcssa, ir<-8>
    CLONE ir<%44> = load ir<%tmpl.0378>
    CLONE ir<%not210> = xor ir<%44>, ir<-1>
    CLONE store ir<%not210>, ir<%tmpl.0378>
    CLONE ir<%sub> = add ir<%anum.1377>, ir<-8>
    CLONE ir<%incdec.ptr212> = getelementptr inbounds ir<%tmpl.0378>, ir<8>
    CLONE ir<%cmp207> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond214.preheader.loopexit>, scalar.ph

ir-bb<for.cond214.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr212.lcssa = ir<%incdec.ptr212>
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body209.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %anum.0.lcssa) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmpl.0378> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1377 = phi %sub, %anum.0.lcssa, ir<-8>
    vp<%4> = vector-pointer ir<%tmpl.0378>
    WIDEN ir<%44> = load vp<%4>
    WIDEN ir<%not210> = xor ir<%44>, ir<-1>
    vp<%5> = vector-pointer ir<%tmpl.0378>
    WIDEN store vp<%5>, ir<%not210>
    CLONE ir<%sub> = add ir<%anum.1377>, ir<-8>
    CLONE ir<%incdec.ptr212> = getelementptr inbounds ir<%tmpl.0378>, ir<8>
    CLONE ir<%cmp207> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond214.preheader.loopexit>, scalar.ph

ir-bb<for.cond214.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr212.lcssa = ir<%incdec.ptr212>
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body209.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %anum.0.lcssa) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmpl.0378> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1377 = phi %sub, %anum.0.lcssa, ir<-8>
    vp<%4> = vector-pointer ir<%tmpl.0378>
    WIDEN ir<%44> = load vp<%4>
    WIDEN ir<%not210> = xor ir<%44>, ir<-1>
    vp<%5> = vector-pointer ir<%tmpl.0378>
    WIDEN store vp<%5>, ir<%not210>
    CLONE ir<%sub> = add ir<%anum.1377>, ir<-8>
    CLONE ir<%incdec.ptr212> = getelementptr inbounds ir<%tmpl.0378>, ir<8>
    CLONE ir<%cmp207> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond214.preheader.loopexit>, scalar.ph

ir-bb<for.cond214.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr212.lcssa = ir<%incdec.ptr212>
}


-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmpl.0378 = phi ptr [ %incdec.ptr212, %for.body209 ], [ %tmps.3.lcssa, %for.body209.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %anum.1377 = phi i64 [ %sub, %for.body209 ], [ %anum.0.lcssa, %for.body209.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not210 = xor i64 %44, -1 of type:xor
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = add i64 %anum.1377, -8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr212 = getelementptr inbounds i8, ptr %tmpl.0378, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp207 = icmp ugt i64 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp207, label %for.body209, label %for.cond214.preheader.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmpl.0378 = phi ptr [ %incdec.ptr212, %for.body209 ], [ %tmps.3.lcssa, %for.body209.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %anum.1377 = phi i64 [ %sub, %for.body209 ], [ %anum.0.lcssa, %for.body209.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not210 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = add i64 %anum.1377, -8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr212 = getelementptr inbounds i8, ptr %tmpl.0378, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp207 = icmp ugt i64 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp207, label %for.body209, label %for.cond214.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmpl.0378 = phi ptr [ %incdec.ptr212, %for.body209 ], [ %tmps.3.lcssa, %for.body209.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %anum.1377 = phi i64 [ %sub, %for.body209 ], [ %anum.0.lcssa, %for.body209.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not210 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub = add i64 %anum.1377, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr212 = getelementptr inbounds i8, ptr %tmpl.0378, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp207 = icmp ugt i64 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp207, label %for.body209, label %for.cond214.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmpl.0378 = phi ptr [ %incdec.ptr212, %for.body209 ], [ %tmps.3.lcssa, %for.body209.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %anum.1377 = phi i64 [ %sub, %for.body209 ], [ %anum.0.lcssa, %for.body209.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %44 = load i64, ptr %tmpl.0378, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not210 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %not210, ptr %tmpl.0378, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = add i64 %anum.1377, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr212 = getelementptr inbounds i8, ptr %tmpl.0378, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp207 = icmp ugt i64 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp207, label %for.body209, label %for.cond214.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_complement at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body209.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %anum.0.lcssa) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%tmps.3.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<%anum.0.lcssa> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%44> = load vp<%9>
    WIDEN ir<%not210> = xor ir<%44>, ir<-1>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%not210>
    CLONE ir<%sub> = add vp<%8>, ir<-8>
    CLONE ir<%incdec.ptr212> = getelementptr inbounds vp<%6>, ir<8>
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.cond214.preheader.loopexit>, scalar.ph

ir-bb<for.cond214.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr212.lcssa = ir<%incdec.ptr212>
}
================ Final VPlan ================

@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%anum.1.lcssa> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%tmps.4383> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2382 = phi %dec222, %anum.1.lcssa, ir<-1>
    CLONE ir<%83> = load ir<%tmps.4383>
    CLONE ir<%not219> = xor ir<%83>, ir<-1>
    CLONE store ir<%not219>, ir<%tmps.4383>
    CLONE ir<%dec222> = add nsw ir<%anum.2382>, ir<-1>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmps.4383>, ir<1>
    CLONE ir<%cmp215> = icmp ugt ir<%anum.2382>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%anum.1.lcssa>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end224.loopexit>, scalar.ph

ir-bb<for.end224.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%anum.1.lcssa> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%tmps.4383> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2382 = phi %dec222, %anum.1.lcssa, ir<-1>
    vp<%3> = vector-pointer ir<%tmps.4383>
    WIDEN ir<%83> = load vp<%3>
    WIDEN ir<%not219> = xor ir<%83>, ir<-1>
    vp<%4> = vector-pointer ir<%tmps.4383>
    WIDEN store vp<%4>, ir<%not219>
    CLONE ir<%dec222> = add nsw ir<%anum.2382>, ir<-1>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmps.4383>, ir<1>
    CLONE ir<%cmp215> = icmp ugt ir<%anum.2382>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%anum.1.lcssa>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end224.loopexit>, scalar.ph

ir-bb<for.end224.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%anum.1.lcssa> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%tmps.4383> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2382 = phi %dec222, %anum.1.lcssa, ir<-1>
    vp<%3> = vector-pointer ir<%tmps.4383>
    WIDEN ir<%83> = load vp<%3>
    WIDEN ir<%not219> = xor ir<%83>, ir<-1>
    vp<%4> = vector-pointer ir<%tmps.4383>
    WIDEN store vp<%4>, ir<%not219>
    CLONE ir<%dec222> = add nsw ir<%anum.2382>, ir<-1>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmps.4383>, ir<1>
    CLONE ir<%cmp215> = icmp ugt ir<%anum.2382>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%anum.1.lcssa>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end224.loopexit>, scalar.ph

ir-bb<for.end224.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %tmps.4383 = phi ptr [ %incdec.ptr223, %for.body217 ], [ %tmpl.0.lcssa, %for.body217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %anum.2382 = phi i64 [ %dec222, %for.body217 ], [ %anum.1.lcssa, %for.body217.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %83 = load i8, ptr %tmps.4383, align 1, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %not219 = xor i8 %83, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %not219, ptr %tmps.4383, align 1, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec222 = add nsw i64 %anum.2382, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmps.4383, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp215 = icmp ugt i64 %anum.2382, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp215, label %for.body217, label %for.end224.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 44
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_pp_complement at line: pp.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_complement at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%anum.1.lcssa> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%tmpl.0.lcssa>, vp<%3>
    vp<%5> = vector-pointer vp<%4>
    WIDEN ir<%83> = load vp<%5>
    WIDEN ir<%not219> = xor ir<%83>, ir<-1>
    vp<%6> = vector-pointer vp<%4>
    WIDEN store vp<%6>, ir<%not219>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%anum.1.lcssa>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end224.loopexit>, scalar.ph

ir-bb<for.end224.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_pp_complement at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%anum.1.lcssa> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%tmpl.0.lcssa>, vp<%3>
    vp<%5> = vector-pointer vp<%4>
    WIDEN ir<%107> = load vp<%5>
    WIDEN ir<%not219> = xor ir<%107>, ir<-1>
    vp<%6> = vector-pointer vp<%4>
    WIDEN store vp<%6>, ir<%not219>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%anum.1.lcssa>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end224.loopexit>, scalar.ph

ir-bb<for.end224.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 19
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    CLONE ir<%47> = load ir<%s.1211>
    CLONE ir<%48> = add ir<%47>, ir<-97>
    CLONE ir<%or.cond204> = icmp ult ir<%48>, ir<26>
    CLONE ir<%sub124> = add nsw ir<%47>, ir<-32>
    CLONE ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%47>
    CLONE store ir<%spec.select>, ir<%s.1211>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    vp<%4> = vector-pointer ir<%s.1211>
    WIDEN ir<%47> = load vp<%4>
    WIDEN ir<%48> = add ir<%47>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%47>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%47>
    vp<%5> = vector-pointer ir<%s.1211>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    vp<%4> = vector-pointer ir<%s.1211>
    WIDEN ir<%47> = load vp<%4>
    WIDEN ir<%48> = add ir<%47>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%47>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%47>
    vp<%5> = vector-pointer ir<%s.1211>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %47 = load i8, ptr %s.1211, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %48 = add i8 %47, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or.cond204 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %sub124 = add nsw i8 %47, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %spec.select, ptr %s.1211, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 112
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_pp_uc at line: pp.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_uc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond108>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%47> = load vp<%6>
    WIDEN ir<%48> = add ir<%47>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%47>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%47>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%spec.select>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_pp_uc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%49> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%cond108>, vp<%3>
    vp<%5> = vector-pointer vp<%4>
    WIDEN ir<%80> = load vp<%5>
    WIDEN ir<%81> = add ir<%80>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%81>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%80>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%80>
    vp<%6> = vector-pointer vp<%4>
    WIDEN store vp<%6>, ir<%spec.select>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%49>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 22
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    CLONE ir<%47> = load ir<%s.1215>
    CLONE ir<%48> = add ir<%47>, ir<-65>
    CLONE ir<%or.cond208> = icmp ult ir<%48>, ir<26>
    CLONE ir<%narrow> = add nuw nsw ir<%47>, ir<32>
    CLONE ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%47>
    CLONE store ir<%spec.select>, ir<%s.1215>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    vp<%4> = vector-pointer ir<%s.1215>
    WIDEN ir<%47> = load vp<%4>
    WIDEN ir<%48> = add ir<%47>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%47>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%47>
    vp<%5> = vector-pointer ir<%s.1215>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    vp<%4> = vector-pointer ir<%s.1215>
    WIDEN ir<%47> = load vp<%4>
    WIDEN ir<%48> = add ir<%47>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%47>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%47>
    vp<%5> = vector-pointer ir<%s.1215>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %47 = load i8, ptr %s.1215, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %48 = add i8 %47, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or.cond208 = icmp ult i8 %48, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %narrow = add nuw nsw i8 %47, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %47 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %spec.select, ptr %s.1215, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 112
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_pp_lc at line: pp.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_lc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %46)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond112>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%47> = load vp<%6>
    WIDEN ir<%48> = add ir<%47>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%48>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%47>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%47>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%spec.select>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_pp_lc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%49> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%cond112>, vp<%3>
    vp<%5> = vector-pointer vp<%4>
    WIDEN ir<%80> = load vp<%5>
    WIDEN ir<%81> = add ir<%80>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%81>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%80>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%80>
    vp<%6> = vector-pointer vp<%4>
    WIDEN store vp<%6>, ir<%spec.select>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%49>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 24
Loops Epilogues Vectorized: 3
================================================
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    CLONE ir<%24> = load ir<%s.1195>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    CLONE store ir<%24>, ir<%d.1193>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    vp<%4> = vector-pointer ir<%s.1195>
    WIDEN ir<%24> = load vp<%4>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    vp<%5> = vector-pointer ir<%d.1193>
    WIDEN store vp<%5>, ir<%24>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    vp<%4> = vector-pointer ir<%s.1195>
    WIDEN ir<%24> = load vp<%4>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    vp<%5> = vector-pointer ir<%d.1193>
    WIDEN store vp<%5>, ir<%24>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}


-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %24 = load i8, ptr %s.1195, align 1, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %24, ptr %d.1193, align 1, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_quotemeta at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.0199>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%d.0198>, vp<%6>
    CLONE ir<%incdec.ptr> = getelementptr inbounds vp<%5>, ir<1>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%28> = load vp<%8>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%28>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 26
Loops Epilogues Vectorized: 3
================================================
MVT: v2i64
@@ Instruction =>  %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store ptr %114, ptr %dst.5723, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %114, ptr %dst.5723, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %114, ptr %dst.5723, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%after.0> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%src.1724> = WIDEN-POINTER-INDUCTION ir<%add.ptr409>, -8
    EMIT ir<%dst.5723> = WIDEN-POINTER-INDUCTION ir<%add.ptr407>, -8
    WIDEN-INDUCTION %i.5722 = phi %after.0, %dec416, ir<-1>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%src.1724>, ir<-8>
    CLONE ir<%114> = load ir<%src.1724>
    CLONE ir<%incdec.ptr414> = getelementptr inbounds ir<%dst.5723>, ir<-8>
    CLONE store ir<%114>, ir<%dst.5723>
    CLONE ir<%dec416> = add nsw ir<%i.5722>, ir<-1>
    CLONE ir<%tobool411.not> = icmp eq ir<%dec416>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%after.0>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end420.loopexit>, scalar.ph

ir-bb<if.end420.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%after.0> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%src.1724> = WIDEN-POINTER-INDUCTION ir<%add.ptr409>, -8
    EMIT ir<%dst.5723> = WIDEN-POINTER-INDUCTION ir<%add.ptr407>, -8
    WIDEN-INDUCTION %i.5722 = phi %after.0, %dec416, ir<-1>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%src.1724>, ir<-8>
    vp<%3> = vector-pointer (reverse) ir<%src.1724>
    WIDEN ir<%114> = load vp<%3>
    CLONE ir<%incdec.ptr414> = getelementptr inbounds ir<%dst.5723>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.5723>
    WIDEN store vp<%4>, ir<%114>
    CLONE ir<%dec416> = add nsw ir<%i.5722>, ir<-1>
    CLONE ir<%tobool411.not> = icmp eq ir<%dec416>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%after.0>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end420.loopexit>, scalar.ph

ir-bb<if.end420.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%after.0> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%src.1724> = WIDEN-POINTER-INDUCTION ir<%add.ptr409>, -8
    EMIT ir<%dst.5723> = WIDEN-POINTER-INDUCTION ir<%add.ptr407>, -8
    WIDEN-INDUCTION %i.5722 = phi %after.0, %dec416, ir<-1>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%src.1724>, ir<-8>
    vp<%3> = vector-pointer (reverse) ir<%src.1724>
    WIDEN ir<%114> = load vp<%3>
    CLONE ir<%incdec.ptr414> = getelementptr inbounds ir<%dst.5723>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.5723>
    WIDEN store vp<%4>, ir<%114>
    CLONE ir<%dec416> = add nsw ir<%i.5722>, ir<-1>
    CLONE ir<%tobool411.not> = icmp eq ir<%dec416>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%after.0>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end420.loopexit>, scalar.ph

ir-bb<if.end420.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.1724 = phi ptr [ %add.ptr409, %if.then402 ], [ %incdec.ptr413, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.5723 = phi ptr [ %add.ptr407, %if.then402 ], [ %incdec.ptr414, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.5722 = phi i64 [ %after.0, %if.then402 ], [ %dec416, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %src.1724, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr414 = getelementptr inbounds i8, ptr %dst.5723, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %114, ptr %dst.5723, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec416 = add nsw i64 %i.5722, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool411.not = icmp eq i64 %dec416, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool411.not, label %if.end420.loopexit, label %for.body412 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.1724 = phi ptr [ %add.ptr409, %if.then402 ], [ %incdec.ptr413, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.5723 = phi ptr [ %add.ptr407, %if.then402 ], [ %incdec.ptr414, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.5722 = phi i64 [ %after.0, %if.then402 ], [ %dec416, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %src.1724, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr414 = getelementptr inbounds i8, ptr %dst.5723, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %114, ptr %dst.5723, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec416 = add nsw i64 %i.5722, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool411.not = icmp eq i64 %dec416, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool411.not, label %if.end420.loopexit, label %for.body412 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.1724 = phi ptr [ %add.ptr409, %if.then402 ], [ %incdec.ptr413, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.5723 = phi ptr [ %add.ptr407, %if.then402 ], [ %incdec.ptr414, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.5722 = phi i64 [ %after.0, %if.then402 ], [ %dec416, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %src.1724, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr414 = getelementptr inbounds i8, ptr %dst.5723, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %114, ptr %dst.5723, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec416 = add nsw i64 %i.5722, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool411.not = icmp eq i64 %dec416, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool411.not, label %if.end420.loopexit, label %for.body412 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.1724 = phi ptr [ %add.ptr409, %if.then402 ], [ %incdec.ptr413, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.5723 = phi ptr [ %add.ptr407, %if.then402 ], [ %incdec.ptr414, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.5722 = phi i64 [ %after.0, %if.then402 ], [ %dec416, %for.body412 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %src.1724, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %114 = load ptr, ptr %src.1724, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr414 = getelementptr inbounds i8, ptr %dst.5723, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %114, ptr %dst.5723, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec416 = add nsw i64 %i.5722, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool411.not = icmp eq i64 %dec416, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool411.not, label %if.end420.loopexit, label %for.body412 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%after.0> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-8>
    EMIT vp<%5> = ptradd ir<%add.ptr409>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-8>
    EMIT vp<%8> = ptradd ir<%add.ptr407>, vp<%7>
    vp<%9> = vector-pointer (reverse) vp<%5>
    WIDEN ir<%130> = load vp<%9>
    vp<%10> = vector-pointer (reverse) vp<%8>
    WIDEN store vp<%10>, ir<%130>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%after.0>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end420.loopexit>, scalar.ph

ir-bb<if.end420.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store ptr %90, ptr %dst.3737, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %90, ptr %dst.3737, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %90, ptr %dst.3737, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset.2> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%src.0738> = WIDEN-POINTER-INDUCTION ir<%arrayidx287>, -8
    EMIT ir<%dst.3737> = WIDEN-POINTER-INDUCTION ir<%add.ptr288>, -8
    WIDEN-INDUCTION %i.3736 = phi %dec296, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr293> = getelementptr inbounds ir<%src.0738>, ir<-8>
    CLONE ir<%90> = load ir<%src.0738>
    CLONE ir<%incdec.ptr294> = getelementptr inbounds ir<%dst.3737>, ir<-8>
    CLONE store ir<%90>, ir<%dst.3737>
    CLONE ir<%dec296> = add nsw ir<%i.3736>, ir<-1>
    CLONE ir<%cmp290> = icmp ugt ir<%i.3736>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%offset.2>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end298.loopexit>, scalar.ph

ir-bb<if.end298.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset.2> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%src.0738> = WIDEN-POINTER-INDUCTION ir<%arrayidx287>, -8
    EMIT ir<%dst.3737> = WIDEN-POINTER-INDUCTION ir<%add.ptr288>, -8
    WIDEN-INDUCTION %i.3736 = phi %dec296, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr293> = getelementptr inbounds ir<%src.0738>, ir<-8>
    vp<%3> = vector-pointer (reverse) ir<%src.0738>
    WIDEN ir<%90> = load vp<%3>
    CLONE ir<%incdec.ptr294> = getelementptr inbounds ir<%dst.3737>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.3737>
    WIDEN store vp<%4>, ir<%90>
    CLONE ir<%dec296> = add nsw ir<%i.3736>, ir<-1>
    CLONE ir<%cmp290> = icmp ugt ir<%i.3736>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%offset.2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end298.loopexit>, scalar.ph

ir-bb<if.end298.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset.2> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%src.0738> = WIDEN-POINTER-INDUCTION ir<%arrayidx287>, -8
    EMIT ir<%dst.3737> = WIDEN-POINTER-INDUCTION ir<%add.ptr288>, -8
    WIDEN-INDUCTION %i.3736 = phi %dec296, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr293> = getelementptr inbounds ir<%src.0738>, ir<-8>
    vp<%3> = vector-pointer (reverse) ir<%src.0738>
    WIDEN ir<%90> = load vp<%3>
    CLONE ir<%incdec.ptr294> = getelementptr inbounds ir<%dst.3737>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.3737>
    WIDEN store vp<%4>, ir<%90>
    CLONE ir<%dec296> = add nsw ir<%i.3736>, ir<-1>
    CLONE ir<%cmp290> = icmp ugt ir<%i.3736>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%offset.2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end298.loopexit>, scalar.ph

ir-bb<if.end298.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.0738 = phi ptr [ %incdec.ptr293, %for.body292 ], [ %arrayidx287, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.3737 = phi ptr [ %incdec.ptr294, %for.body292 ], [ %add.ptr288, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3736 = phi i64 [ %dec296, %for.body292 ], [ %offset.2, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr293 = getelementptr inbounds i8, ptr %src.0738, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr294 = getelementptr inbounds i8, ptr %dst.3737, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %90, ptr %dst.3737, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec296 = add nsw i64 %i.3736, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp290 = icmp ugt i64 %i.3736, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp290, label %for.body292, label %if.end298.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.0738 = phi ptr [ %incdec.ptr293, %for.body292 ], [ %arrayidx287, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.3737 = phi ptr [ %incdec.ptr294, %for.body292 ], [ %add.ptr288, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3736 = phi i64 [ %dec296, %for.body292 ], [ %offset.2, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr293 = getelementptr inbounds i8, ptr %src.0738, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr294 = getelementptr inbounds i8, ptr %dst.3737, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %90, ptr %dst.3737, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec296 = add nsw i64 %i.3736, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp290 = icmp ugt i64 %i.3736, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp290, label %for.body292, label %if.end298.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.0738 = phi ptr [ %incdec.ptr293, %for.body292 ], [ %arrayidx287, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.3737 = phi ptr [ %incdec.ptr294, %for.body292 ], [ %add.ptr288, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3736 = phi i64 [ %dec296, %for.body292 ], [ %offset.2, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr293 = getelementptr inbounds i8, ptr %src.0738, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr294 = getelementptr inbounds i8, ptr %dst.3737, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %90, ptr %dst.3737, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec296 = add nsw i64 %i.3736, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp290 = icmp ugt i64 %i.3736, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp290, label %for.body292, label %if.end298.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.0738 = phi ptr [ %incdec.ptr293, %for.body292 ], [ %arrayidx287, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.3737 = phi ptr [ %incdec.ptr294, %for.body292 ], [ %add.ptr288, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3736 = phi i64 [ %dec296, %for.body292 ], [ %offset.2, %for.body292.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr293 = getelementptr inbounds i8, ptr %src.0738, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %90 = load ptr, ptr %src.0738, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr294 = getelementptr inbounds i8, ptr %dst.3737, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %90, ptr %dst.3737, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec296 = add nsw i64 %i.3736, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp290 = icmp ugt i64 %i.3736, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp290, label %for.body292, label %if.end298.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset.2> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-8>
    EMIT vp<%5> = ptradd ir<%arrayidx287>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-8>
    EMIT vp<%8> = ptradd ir<%add.ptr288>, vp<%7>
    vp<%9> = vector-pointer (reverse) vp<%5>
    WIDEN ir<%106> = load vp<%9>
    vp<%10> = vector-pointer (reverse) vp<%8>
    WIDEN store vp<%10>, ir<%106>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%offset.2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end298.loopexit>, scalar.ph

ir-bb<if.end298.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub327.pre-phi> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.4739 = phi %sub327.pre-phi, %dec329, ir<-1>
    CLONE ir<%dec329> = add nsw ir<%i.4739>, ir<-1>
    CLONE ir<%arrayidx330> = getelementptr inbounds ir<%dst.4>, ir<%dec329>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx330>
    CLONE ir<%tobool328.not> = icmp eq ir<%dec329>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%sub327.pre-phi>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub327.pre-phi> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.4739 = phi %sub327.pre-phi, %dec329, ir<-1>
    CLONE ir<%dec329> = add nsw ir<%i.4739>, ir<-1>
    CLONE ir<%arrayidx330> = getelementptr inbounds ir<%dst.4>, ir<%dec329>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx330>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool328.not> = icmp eq ir<%dec329>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%sub327.pre-phi>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub327.pre-phi> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.4739 = phi %sub327.pre-phi, %dec329, ir<-1>
    CLONE ir<%dec329> = add nsw ir<%i.4739>, ir<-1>
    CLONE ir<%arrayidx330> = getelementptr inbounds ir<%dst.4>, ir<%dec329>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx330>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool328.not> = icmp eq ir<%dec329>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%sub327.pre-phi>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.4739 = phi i64 [ %sub327.pre-phi, %if.end326 ], [ %dec329, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec329 = add nsw i64 %i.4739, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx330 = getelementptr inbounds ptr, ptr %dst.4, i64 %dec329 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool328.not = icmp eq i64 %dec329, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool328.not, label %while.end, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.4739 = phi i64 [ %sub327.pre-phi, %if.end326 ], [ %dec329, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec329 = add nsw i64 %i.4739, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx330 = getelementptr inbounds ptr, ptr %dst.4, i64 %dec329 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool328.not = icmp eq i64 %dec329, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool328.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.4739 = phi i64 [ %sub327.pre-phi, %if.end326 ], [ %dec329, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec329 = add nsw i64 %i.4739, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx330 = getelementptr inbounds ptr, ptr %dst.4, i64 %dec329 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool328.not = icmp eq i64 %dec329, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool328.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.4739 = phi i64 [ %sub327.pre-phi, %if.end326 ], [ %dec329, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec329 = add nsw i64 %i.4739, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx330 = getelementptr inbounds ptr, ptr %dst.4, i64 %dec329 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx330, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool328.not = icmp eq i64 %dec329, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool328.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub327.pre-phi> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%sub327.pre-phi> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec329> = add nsw vp<%4>, ir<-1>
    CLONE ir<%arrayidx330> = getelementptr inbounds ir<%dst.4>, ir<%dec329>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx330>
    WIDEN store vp<%5>, ir<@PL_sv_undef>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%sub327.pre-phi>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 48
Loops Epilogues Vectorized: 3
================================================
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
MVT: v2i64
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
MVT: v2i64
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
MVT: nxv2i64
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
MVT: nxv2i64
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
MVT: nxv2i64
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
MVT: nxv2i64
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * %3) + (-1 * (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    CLONE ir<%8> = load ir<%mark.0171>
    CLONE ir<%9> = load ir<%sp.0170>
    CLONE store ir<%9>, ir<%mark.0171>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    CLONE store ir<%8>, ir<%sp.0170>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp10> = icmp ult ir<%mark.0>, ir<%incdec.ptr13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * %3) + (-1 * (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    vp<%4> = vector-pointer ir<%mark.0171>
    WIDEN ir<%8> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN ir<%9> = load vp<%5>
    vp<%6> = vector-pointer ir<%mark.0171>
    WIDEN store vp<%6>, ir<%9>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    vp<%7> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN store vp<%7>, ir<%8>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp10> = icmp ult ir<%mark.0>, ir<%incdec.ptr13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * %3) + (-1 * (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * %3) + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %3) + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    vp<%4> = vector-pointer ir<%mark.0171>
    WIDEN ir<%8> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN ir<%9> = load vp<%5>
    vp<%6> = vector-pointer ir<%mark.0171>
    WIDEN store vp<%6>, ir<%9>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    vp<%7> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN store vp<%7>, ir<%8>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp10> = icmp ult ir<%mark.0>, ir<%incdec.ptr13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr13, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %9, ptr %mark.0171, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %8, ptr %sp.0170, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp10 = icmp ult ptr %mark.0, %incdec.ptr13 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp10, label %while.body, label %if.end107.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr13, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %9, ptr %mark.0171, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %8, ptr %sp.0170, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp10 = icmp ult ptr %mark.0, %incdec.ptr13 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp10, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr13, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %9, ptr %mark.0171, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %8, ptr %sp.0170, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp10 = icmp ult ptr %mark.0, %incdec.ptr13 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp10, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr13, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = load ptr, ptr %mark.0171, align 8, !tbaa !6 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load ptr, ptr %sp.0170, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %9, ptr %mark.0171, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %8, ptr %sp.0170, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp10 = icmp ult ptr %mark.0, %incdec.ptr13 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp10, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_reverse at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * %5) + (-1 * (1 umin (-16 + (-8 * %5) + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %5) + (ptrtoint ptr %2 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %5) + (ptrtoint ptr %2 to i64)))) /u 16) + (1 umin (-16 + (-8 * %5) + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * %5) + (ptrtoint ptr %2 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%mark.0168>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%0>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%25> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%9>
    WIDEN ir<%26> = load vp<%11>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%26>
    vp<%13> = vector-pointer (reverse) vp<%9>
    WIDEN store vp<%13>, ir<%25>
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 53
Loops Epilogues Vectorized: 3
================================================
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
MVT: nxv2i64
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp_ctl.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp_ctl.c
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11517, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21518, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%35> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%t.21518> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11517> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01516 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01516>, ir<-1>
    CLONE ir<%incdec.ptr159> = getelementptr inbounds ir<%f.11517>, ir<1>
    CLONE ir<%60> = load ir<%f.11517>
    CLONE ir<%incdec.ptr160> = getelementptr inbounds ir<%t.21518>, ir<1>
    CLONE store ir<%60>, ir<%t.21518>
    CLONE ir<%tobool158.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%35>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<sw.epilog1047.loopexit>, scalar.ph

ir-bb<sw.epilog1047.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr159.lcssa = ir<%incdec.ptr159>
Live-out ptr %incdec.ptr160.lcssa = ir<%incdec.ptr160>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%35> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%t.21518> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11517> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01516 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01516>, ir<-1>
    CLONE ir<%incdec.ptr159> = getelementptr inbounds ir<%f.11517>, ir<1>
    vp<%3> = vector-pointer ir<%f.11517>
    WIDEN ir<%60> = load vp<%3>
    CLONE ir<%incdec.ptr160> = getelementptr inbounds ir<%t.21518>, ir<1>
    vp<%4> = vector-pointer ir<%t.21518>
    WIDEN store vp<%4>, ir<%60>
    CLONE ir<%tobool158.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%35>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog1047.loopexit>, scalar.ph

ir-bb<sw.epilog1047.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr159.lcssa = ir<%incdec.ptr159>
Live-out ptr %incdec.ptr160.lcssa = ir<%incdec.ptr160>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%35> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%t.21518> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11517> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01516 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01516>, ir<-1>
    CLONE ir<%incdec.ptr159> = getelementptr inbounds ir<%f.11517>, ir<1>
    vp<%3> = vector-pointer ir<%f.11517>
    WIDEN ir<%60> = load vp<%3>
    CLONE ir<%incdec.ptr160> = getelementptr inbounds ir<%t.21518>, ir<1>
    vp<%4> = vector-pointer ir<%t.21518>
    WIDEN store vp<%4>, ir<%60>
    CLONE ir<%tobool158.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%35>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog1047.loopexit>, scalar.ph

ir-bb<sw.epilog1047.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr159.lcssa = ir<%incdec.ptr159>
Live-out ptr %incdec.ptr160.lcssa = ir<%incdec.ptr160>
}


-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %t.21518 = phi ptr [ %incdec.ptr160, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %f.11517 = phi ptr [ %incdec.ptr159, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arg.01516 = phi i64 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i64 %arg.01516, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr159 = getelementptr inbounds i8, ptr %f.11517, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %60 = load i8, ptr %f.11517, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr160 = getelementptr inbounds i8, ptr %t.21518, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %60, ptr %t.21518, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool158.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool158.not, label %sw.epilog1047.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_formline at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%35> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%t.1>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%f.0>, vp<%5>
    CLONE ir<%incdec.ptr159> = getelementptr inbounds vp<%6>, ir<1>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%64> = load vp<%7>
    CLONE ir<%incdec.ptr160> = getelementptr inbounds vp<%4>, ir<1>
    vp<%8> = vector-pointer vp<%4>
    WIDEN store vp<%8>, ir<%64>
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<%35>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog1047.loopexit>, scalar.ph

ir-bb<sw.epilog1047.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr159.lcssa = ir<%incdec.ptr159>
Live-out ptr %incdec.ptr160.lcssa = ir<%incdec.ptr160>
}
================ Final VPlan ================

@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %187 = load i8, ptr %s.151482, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%152> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%t.161483> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151482> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41481 = phi %dec658, %152, ir<-1>
    CLONE ir<%dec658> = add nsw ir<%arg.41481>, ir<-1>
    CLONE ir<%incdec.ptr661> = getelementptr inbounds ir<%s.151482>, ir<1>
    CLONE ir<%187> = load ir<%s.151482>
    CLONE ir<%incdec.ptr662> = getelementptr inbounds ir<%t.161483>, ir<1>
    CLONE ir<%spec.select1417> = call @llvm.umax.i8(ir<%187>, ir<32>)
    CLONE store ir<%spec.select1417>, ir<%t.161483>
    CLONE ir<%tobool659.not> = icmp eq ir<%dec658>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%152>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<sw.epilog1047.loopexit1592>, scalar.ph

ir-bb<sw.epilog1047.loopexit1592>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr662.lcssa = ir<%incdec.ptr662>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%152> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%t.161483> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151482> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41481 = phi %dec658, %152, ir<-1>
    CLONE ir<%dec658> = add nsw ir<%arg.41481>, ir<-1>
    CLONE ir<%incdec.ptr661> = getelementptr inbounds ir<%s.151482>, ir<1>
    vp<%3> = vector-pointer ir<%s.151482>
    WIDEN ir<%187> = load vp<%3>
    CLONE ir<%incdec.ptr662> = getelementptr inbounds ir<%t.161483>, ir<1>
    WIDEN-CALL ir<%spec.select1417> = call @llvm.umax.i8(ir<%187>, ir<32>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%t.161483>
    WIDEN store vp<%4>, ir<%spec.select1417>
    CLONE ir<%tobool659.not> = icmp eq ir<%dec658>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%152>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog1047.loopexit1592>, scalar.ph

ir-bb<sw.epilog1047.loopexit1592>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr662.lcssa = ir<%incdec.ptr662>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%152> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%t.161483> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151482> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41481 = phi %dec658, %152, ir<-1>
    CLONE ir<%dec658> = add nsw ir<%arg.41481>, ir<-1>
    CLONE ir<%incdec.ptr661> = getelementptr inbounds ir<%s.151482>, ir<1>
    vp<%3> = vector-pointer ir<%s.151482>
    WIDEN ir<%187> = load vp<%3>
    CLONE ir<%incdec.ptr662> = getelementptr inbounds ir<%t.161483>, ir<1>
    WIDEN-CALL ir<%spec.select1417> = call @llvm.umax.i8(ir<%187>, ir<32>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%t.161483>
    WIDEN store vp<%4>, ir<%spec.select1417>
    CLONE ir<%tobool659.not> = icmp eq ir<%dec658>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%152>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog1047.loopexit1592>, scalar.ph

ir-bb<sw.epilog1047.loopexit1592>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr662.lcssa = ir<%incdec.ptr662>
}


-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %t.161483 = phi ptr [ %incdec.ptr662, %while.body660 ], [ %t.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.151482 = phi ptr [ %incdec.ptr661, %while.body660 ], [ %item.0, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arg.41481 = phi i64 [ %dec658, %while.body660 ], [ %152, %while.body660.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec658 = add nsw i64 %arg.41481, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr661 = getelementptr inbounds i8, ptr %s.151482, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %187 = load i8, ptr %s.151482, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr662 = getelementptr inbounds i8, ptr %t.161483, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %spec.select1417 = call i8 @llvm.umax.i8(i8 %187, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %spec.select1417, ptr %t.161483, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool659.not = icmp eq i64 %dec658, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool659.not, label %sw.epilog1047.loopexit1592, label %while.body660 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 256
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_formline at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%152> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%t.0>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%item.0>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%191> = load vp<%7>
    CLONE ir<%incdec.ptr662> = getelementptr inbounds vp<%4>, ir<1>
    WIDEN-CALL ir<%spec.select1417> = call @llvm.umax.i8(ir<%191>, ir<32>) (using vector intrinsic)
    vp<%8> = vector-pointer vp<%4>
    WIDEN store vp<%8>, ir<%spec.select1417>
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<%152>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog1047.loopexit1592>, scalar.ph

ir-bb<sw.epilog1047.loopexit1592>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr662.lcssa = ir<%incdec.ptr662>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
MVT: v2i64
@@ Instruction =>  %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store ptr %13, ptr %dst.0188, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %13, ptr %dst.0188, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %13, ptr %dst.0188, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %7) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dst.0188> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0187> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0186 = phi %dec, %sub38, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0186>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0187>, ir<-8>
    CLONE ir<%13> = load ir<%src.0187>
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%dst.0188>, ir<-8>
    CLONE store ir<%13>, ir<%dst.0188>
    CLONE ir<%tobool56.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end58.loopexit>, scalar.ph

ir-bb<if.end58.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %7) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dst.0188> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0187> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0186 = phi %dec, %sub38, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0186>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0187>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0187>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%dst.0188>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.0188>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%tobool56.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end58.loopexit>, scalar.ph

ir-bb<if.end58.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %7) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dst.0188> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0187> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0186 = phi %dec, %sub38, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0186>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0187>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0187>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%dst.0188>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.0188>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%tobool56.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end58.loopexit>, scalar.ph

ir-bb<if.end58.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.0188 = phi ptr [ %incdec.ptr57, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.0187 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count.0186 = phi i64 [ %dec, %while.body ], [ %sub38, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %count.0186, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0187, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %dst.0188, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %13, ptr %dst.0188, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool56.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool56.not, label %if.end58.loopexit, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.0188 = phi ptr [ %incdec.ptr57, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.0187 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count.0186 = phi i64 [ %dec, %while.body ], [ %sub38, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %count.0186, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0187, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %dst.0188, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %13, ptr %dst.0188, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool56.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool56.not, label %if.end58.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.0188 = phi ptr [ %incdec.ptr57, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.0187 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count.0186 = phi i64 [ %dec, %while.body ], [ %sub38, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %count.0186, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0187, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %dst.0188, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %13, ptr %dst.0188, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool56.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool56.not, label %if.end58.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.0188 = phi ptr [ %incdec.ptr57, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.0187 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count.0186 = phi i64 [ %dec, %while.body ], [ %sub38, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %count.0186, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0187, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %13 = load ptr, ptr %src.0187, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %dst.0188, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %13, ptr %dst.0188, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool56.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool56.not, label %if.end58.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_mapwhile at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %7) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%add.ptr>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%sp.0>, vp<%8>
    vp<%10> = vector-pointer (reverse) vp<%9>
    WIDEN ir<%28> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%11>, ir<%28>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end58.loopexit>, scalar.ph

ir-bb<if.end58.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin ((-1 * %6) + %sub.ptr.div)))<nuw><nsw> + (-1 * %6) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %items.1191 = phi %dec83, %sub, ir<-1>
    EMIT ir<%dst.2190> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -8
    CLONE ir<%dec83> = add nsw ir<%items.1191>, ir<-1>
    CLONE ir<%incdec.ptr88> = getelementptr inbounds ir<%dst.2190>, ir<-8>
    CLONE store ir<@PL_sv_undef>, ir<%dst.2190>
    CLONE ir<%cmp84> = icmp ugt ir<%items.1191>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end91.loopexit199>, scalar.ph

ir-bb<if.end91.loopexit199>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin ((-1 * %6) + %sub.ptr.div)))<nuw><nsw> + (-1 * %6) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %items.1191 = phi %dec83, %sub, ir<-1>
    EMIT ir<%dst.2190> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -8
    CLONE ir<%dec83> = add nsw ir<%items.1191>, ir<-1>
    CLONE ir<%incdec.ptr88> = getelementptr inbounds ir<%dst.2190>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.2190>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp84> = icmp ugt ir<%items.1191>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end91.loopexit199>, scalar.ph

ir-bb<if.end91.loopexit199>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin ((-1 * %6) + %sub.ptr.div)))<nuw><nsw> + (-1 * %6) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %items.1191 = phi %dec83, %sub, ir<-1>
    EMIT ir<%dst.2190> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -8
    CLONE ir<%dec83> = add nsw ir<%items.1191>, ir<-1>
    CLONE ir<%incdec.ptr88> = getelementptr inbounds ir<%dst.2190>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.2190>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp84> = icmp ugt ir<%items.1191>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end91.loopexit199>, scalar.ph

ir-bb<if.end91.loopexit199>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.1191 = phi i64 [ %dec83, %while.body86 ], [ %sub, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.2190 = phi ptr [ %incdec.ptr88, %while.body86 ], [ %add.ptr62, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec83 = add nsw i64 %items.1191, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr88 = getelementptr inbounds i8, ptr %dst.2190, i64 -8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp84 = icmp ugt i64 %items.1191, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp84, label %while.body86, label %if.end91.loopexit199 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.1191 = phi i64 [ %dec83, %while.body86 ], [ %sub, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.2190 = phi ptr [ %incdec.ptr88, %while.body86 ], [ %add.ptr62, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec83 = add nsw i64 %items.1191, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr88 = getelementptr inbounds i8, ptr %dst.2190, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp84 = icmp ugt i64 %items.1191, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp84, label %while.body86, label %if.end91.loopexit199 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.1191 = phi i64 [ %dec83, %while.body86 ], [ %sub, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.2190 = phi ptr [ %incdec.ptr88, %while.body86 ], [ %add.ptr62, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec83 = add nsw i64 %items.1191, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr88 = getelementptr inbounds i8, ptr %dst.2190, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp84 = icmp ugt i64 %items.1191, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp84, label %while.body86, label %if.end91.loopexit199 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.1191 = phi i64 [ %dec83, %while.body86 ], [ %sub, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.2190 = phi ptr [ %incdec.ptr88, %while.body86 ], [ %add.ptr62, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec83 = add nsw i64 %items.1191, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr88 = getelementptr inbounds i8, ptr %dst.2190, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %dst.2190, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp84 = icmp ugt i64 %items.1191, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp84, label %while.body86, label %if.end91.loopexit199 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_mapwhile at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin ((-1 * %6) + %sub.ptr.div)))<nuw><nsw> + (-1 * %6) + %sub.ptr.div)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%add.ptr62>, vp<%5>
    vp<%7> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%7>, ir<@PL_sv_undef>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end91.loopexit199>, scalar.ph

ir-bb<if.end91.loopexit199>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 31
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp_hot.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp_hot.c
MVT: v2i32
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%80> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%s.21136> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01135 = phi %80, %dec, ir<-1>
    EMIT ir<%d.01134> = WIDEN-POINTER-INDUCTION ir<%add.ptr300>, -1
    CLONE ir<%dec> = add nsw ir<%i.01135>, ir<-1>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds ir<%s.21136>, ir<-1>
    CLONE ir<%87> = load ir<%incdec.ptr305>
    CLONE ir<%incdec.ptr306> = getelementptr inbounds ir<%d.01134>, ir<-1>
    CLONE store ir<%87>, ir<%incdec.ptr306>
    CLONE ir<%tobool304.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%80>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%80> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.21136> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01135 = phi %80, %dec, ir<-1>
    EMIT ir<%d.01134> = WIDEN-POINTER-INDUCTION ir<%add.ptr300>, -1
    CLONE ir<%dec> = add nsw ir<%i.01135>, ir<-1>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds ir<%s.21136>, ir<-1>
    vp<%3> = vector-pointer (reverse) ir<%incdec.ptr305>
    WIDEN ir<%87> = load vp<%3>
    CLONE ir<%incdec.ptr306> = getelementptr inbounds ir<%d.01134>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr306>
    WIDEN store vp<%4>, ir<%87>
    CLONE ir<%tobool304.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%80>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%80> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.21136> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01135 = phi %80, %dec, ir<-1>
    EMIT ir<%d.01134> = WIDEN-POINTER-INDUCTION ir<%add.ptr300>, -1
    CLONE ir<%dec> = add nsw ir<%i.01135>, ir<-1>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds ir<%s.21136>, ir<-1>
    vp<%3> = vector-pointer (reverse) ir<%incdec.ptr305>
    WIDEN ir<%87> = load vp<%3>
    CLONE ir<%incdec.ptr306> = getelementptr inbounds ir<%d.01134>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr306>
    WIDEN store vp<%4>, ir<%87>
    CLONE ir<%tobool304.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%80>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.21136 = phi ptr [ %add.ptr263, %if.then299 ], [ %incdec.ptr305, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.01135 = phi i64 [ %80, %if.then299 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.01134 = phi ptr [ %add.ptr300, %if.then299 ], [ %incdec.ptr306, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i64 %i.01135, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr305 = getelementptr inbounds i8, ptr %s.21136, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %87 = load i8, ptr %incdec.ptr305, align 1, !tbaa !32 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr306 = getelementptr inbounds i8, ptr %d.01134, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %87, ptr %incdec.ptr306, align 1, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool304.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool304.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_pp_subst at line: pp_hot.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_pp_subst at line: pp_hot.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%80> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%add.ptr263>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-1>
    EMIT vp<%8> = ptradd ir<%add.ptr300>, vp<%7>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%9> = vector-pointer (reverse) ir<%incdec.ptr305>
    WIDEN ir<%104> = load vp<%9>
    CLONE ir<%incdec.ptr306> = getelementptr inbounds vp<%8>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr306>
    WIDEN store vp<%10>, ir<%104>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%80>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_pp_subst at line: pp_hot.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%80> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%add.ptr263>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-1>
    EMIT vp<%8> = ptradd ir<%add.ptr300>, vp<%7>
    CLONE ir<%incdec.ptr305> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%9> = vector-pointer (reverse) ir<%incdec.ptr305>
    WIDEN ir<%153> = load vp<%9>
    CLONE ir<%incdec.ptr306> = getelementptr inbounds vp<%8>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr306>
    WIDEN store vp<%10>, ir<%153>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%80>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp_pack.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp_pack.c
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body344.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %len.17) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.addr.62155> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182154 = phi %len.17, %sub350, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22153> = phi ir<%cuv.1>, ir<%add349>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%s.addr.62155>, ir<1>
    CLONE ir<%56> = load ir<%s.addr.62155>
    CLONE ir<%idxprom346> = zext ir<%56>
    CLONE ir<%arrayidx347> = getelementptr inbounds ir<%55>, ir<%idxprom346>
    CLONE ir<%57> = load ir<%arrayidx347>
    CLONE ir<%conv348> = zext ir<%57>
    CLONE ir<%add349> = add ir<%cuv.22153>, ir<%conv348>
    CLONE ir<%sub350> = add nsw ir<%len.182154>, ir<-8>
    CLONE ir<%cmp342> = icmp ugt ir<%len.182154>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%cuv.22153>, ir<%add349>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end351.loopexit>, scalar.ph

ir-bb<while.end351.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr345.lcssa = ir<%incdec.ptr345>
Live-out i64 %add349.lcssa = vp<%6>
Live-out i64 %sub350.lcssa = ir<%sub350>
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body344.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %len.17) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.addr.62155> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182154 = phi %len.17, %sub350, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22153> = phi ir<%cuv.1>, ir<%add349>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%s.addr.62155>, ir<1>
    vp<%4> = vector-pointer ir<%s.addr.62155>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%idxprom346> = zext  ir<%56> to i64
    REPLICATE ir<%arrayidx347> = getelementptr inbounds ir<%55>, ir<%idxprom346>
    REPLICATE ir<%57> = load ir<%arrayidx347>
    WIDEN-CAST ir<%conv348> = zext  ir<%57> to i64
    WIDEN ir<%add349> = add ir<%cuv.22153>, ir<%conv348>
    CLONE ir<%sub350> = add nsw ir<%len.182154>, ir<-8>
    CLONE ir<%cmp342> = icmp ugt ir<%len.182154>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%cuv.22153>, ir<%add349>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end351.loopexit>, scalar.ph

ir-bb<while.end351.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr345.lcssa = ir<%incdec.ptr345>
Live-out i64 %add349.lcssa = vp<%7>
Live-out i64 %sub350.lcssa = ir<%sub350>
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body344.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %len.17) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.addr.62155> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182154 = phi %len.17, %sub350, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22153> = phi ir<%cuv.1>, ir<%add349>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%s.addr.62155>, ir<1>
    vp<%4> = vector-pointer ir<%s.addr.62155>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%idxprom346> = zext  ir<%56> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx347> = getelementptr inbounds ir<%55>, ir<%idxprom346>
    REPLICATE ir<%57> = load ir<%arrayidx347>
    WIDEN-CAST ir<%conv348> = zext  ir<%57> to i64
    WIDEN ir<%add349> = add ir<%cuv.22153>, ir<%conv348>
    CLONE ir<%sub350> = add nsw ir<%len.182154>, ir<-8>
    CLONE ir<%cmp342> = icmp ugt ir<%len.182154>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%cuv.22153>, ir<%add349>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end351.loopexit>, scalar.ph

ir-bb<while.end351.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr345.lcssa = ir<%incdec.ptr345>
Live-out i64 %add349.lcssa = vp<%7>
Live-out i64 %sub350.lcssa = ir<%sub350>
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body344.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %len.17) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.addr.62155> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182154 = phi %len.17, %sub350, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22153> = phi ir<%cuv.1>, ir<%add349>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%s.addr.62155>, ir<1>
    vp<%4> = vector-pointer ir<%s.addr.62155>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%idxprom346> = zext  ir<%56> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx347> = getelementptr inbounds ir<%55>, ir<%idxprom346>
    WIDEN ir<%57> = load ir<%arrayidx347>
    WIDEN-CAST ir<%conv348> = zext  ir<%57> to i64
    WIDEN ir<%add349> = add ir<%cuv.22153>, ir<%conv348>
    CLONE ir<%sub350> = add nsw ir<%len.182154>, ir<-8>
    CLONE ir<%cmp342> = icmp ugt ir<%len.182154>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%cuv.22153>, ir<%add349>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end351.loopexit>, scalar.ph

ir-bb<while.end351.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr345.lcssa = ir<%incdec.ptr345>
Live-out i64 %add349.lcssa = vp<%7>
Live-out i64 %sub350.lcssa = ir<%sub350>
}


-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 39
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 39, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 39
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 39, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width 4 costs: 18
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 72
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 72
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 7 for VF 8 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 7 for VF 8 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width 8 costs: 17
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 141
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 141, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 141
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 141, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 15 for VF 16 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 15 for VF 16 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 8 for VF 16 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width 16 costs: 17
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 281
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 281, CostB * EstimatedWidthA: 112
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 281
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 281, CostB * EstimatedWidthA: 112

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.addr.62155 = phi ptr [ %s.addr.1, %while.body344.lr.ph ], [ %incdec.ptr345, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.182154 = phi i64 [ %len.17, %while.body344.lr.ph ], [ %sub350, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %cuv.22153 = phi i64 [ %cuv.1, %while.body344.lr.ph ], [ %add349, %while.body344 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %s.addr.62155, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %56 = load i8, ptr %s.addr.62155, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom346 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx347 = getelementptr inbounds i8, ptr %55, i64 %idxprom346 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %57 = load i8, ptr %arrayidx347, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv348 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add349 = add i64 %cuv.22153, %conv348 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub350 = add nsw i64 %len.182154, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp342 = icmp ugt i64 %len.182154, 15 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp342, label %while.body344, label %while.end351.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 28
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: S_unpack_rec at line: pp_pack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body344.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-8 + %len.17) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%cuv.22153> = phi ir<%cuv.1>, ir<%add349>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.addr.1>, vp<%4>
    vp<%6>    = DERIVED-IV ir<%len.17> + vp<%3> * ir<-8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-8>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds vp<%5>, ir<1>
    CLONE ir<%56> = load vp<%5>
    CLONE ir<%idxprom346> = zext ir<%56>
    CLONE ir<%arrayidx347> = getelementptr inbounds ir<%55>, ir<%idxprom346>
    CLONE ir<%57> = load ir<%arrayidx347>
    CLONE ir<%conv348> = zext ir<%57>
    CLONE ir<%add349> = add ir<%cuv.22153>, ir<%conv348>
    CLONE ir<%sub350> = add nsw vp<%7>, ir<-8>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%cuv.22153>, ir<%add349>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end351.loopexit>, scalar.ph

ir-bb<while.end351.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr345.lcssa = ir<%incdec.ptr345>
Live-out i64 %add349.lcssa = vp<%10>
Live-out i64 %sub350.lcssa = ir<%sub350>
}
================ Final VPlan ================

@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1068>, ir<1>
    CLONE ir<%arrayidx1070> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    CLONE ir<%148> = load ir<%arrayidx1070>
    CLONE ir<%idxprom1071> = zext ir<%148>
    CLONE ir<%arrayidx1072> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1071>
    CLONE store ir<%conv1068>, ir<%arrayidx1072>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end1075>, scalar.ph

ir-bb<for.end1075>:
No successors

scalar.ph:
No successors
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1068>, ir<1>
    CLONE ir<%arrayidx1070> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx1070>
    WIDEN ir<%148> = load vp<%3>
    WIDEN-CAST ir<%idxprom1071> = zext  ir<%148> to i64
    REPLICATE ir<%arrayidx1072> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1071>
    REPLICATE store ir<%conv1068>, ir<%arrayidx1072>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1075>, scalar.ph

ir-bb<for.end1075>:
No successors

scalar.ph:
No successors
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1068>, ir<1>
    CLONE ir<%arrayidx1070> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx1070>
    WIDEN ir<%148> = load vp<%3>
    WIDEN-CAST ir<%idxprom1071> = zext  ir<%148> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1072> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1071>
    REPLICATE store ir<%conv1068>, ir<%arrayidx1072>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1075>, scalar.ph

ir-bb<for.end1075>:
No successors

scalar.ph:
No successors
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1068>, ir<1>
    CLONE ir<%arrayidx1070> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx1070>
    WIDEN ir<%148> = load vp<%3>
    WIDEN-CAST ir<%idxprom1071> = zext  ir<%148> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1072> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1071>
    WIDEN store ir<%arrayidx1072>, ir<%conv1068>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1075>, scalar.ph

ir-bb<for.end1075>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 1190, RTCostB: 390
A is not scalable.	B is not scalable.	
RTCostA: 1190, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 1094, RTCostB: 390
A is not scalable.	B is not scalable.	
RTCostA: 1094, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 7 for VF 8 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width 8 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 1070, RTCostB: 390
A is not scalable.	B is not scalable.	
RTCostA: 1070, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 15 for VF 16 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width 16 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 1066, RTCostB: 390
A is not scalable.	B is not scalable.	
RTCostA: 1066, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 390
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 710, RTCostB: 390
A is scalable.	B is not scalable.	
RTCostA: 710, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 694, RTCostB: 390
A is scalable.	B is not scalable.	
RTCostA: 694, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 686, RTCostB: 390
A is scalable.	B is not scalable.	
RTCostA: 686, RTCostB: 390

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1067 ], [ 0, %for.body1067.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv1068 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1070 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %148 = load i8, ptr %arrayidx1070, align 1, !tbaa !21 of type:load
LV: Found an estimated cost of 14 for VF vscale x 16 For instruction:   %idxprom1071 = zext i8 %148 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1072 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1071 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 %conv1068, ptr %arrayidx1072, align 1, !tbaa !21 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end1075, label %for.body1067 of type:br
LV: Vector loop of width vscale x 16 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 696, RTCostB: 390
A is scalable.	B is not scalable.	
RTCostA: 696, RTCostB: 390
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: S_unpack_rec at line: pp_pack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
  SCALAR-CAST vp<%2> = trunc ir<1> to i8
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    SCALAR-CAST vp<%5> = trunc vp<%3> to i8
    vp<%6> = SCALAR-STEPS vp<%5>, vp<%2>
    CLONE ir<%arrayidx1070> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, vp<%4>
    CLONE ir<%148> = load ir<%arrayidx1070>
    CLONE ir<%idxprom1071> = zext ir<%148>
    CLONE ir<%arrayidx1072> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1071>
    CLONE store vp<%6>, ir<%arrayidx1072>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end1075>, scalar.ph

ir-bb<for.end1075>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 34
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp_sort.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp_sort.c
@@ Instruction =>  %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %27, ptr %f2.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %27, ptr %f2.4, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %27, ptr %f2.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then160>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %26 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr161>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr162>, 8
    CLONE ir<%incdec.ptr169> = getelementptr inbounds ir<%f1.4>, ir<8>
    CLONE ir<%27> = load ir<%f1.4>
    CLONE ir<%incdec.ptr170> = getelementptr inbounds ir<%f2.4>, ir<8>
    CLONE store ir<%27>, ir<%f2.4>
    CLONE ir<%cmp172> = icmp ult ir<%incdec.ptr169>, ir<%add.ptr167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end174>, scalar.ph

ir-bb<do.end174>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then160>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %26 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr161>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr162>, 8
    CLONE ir<%incdec.ptr169> = getelementptr inbounds ir<%f1.4>, ir<8>
    vp<%4> = vector-pointer ir<%f1.4>
    WIDEN ir<%27> = load vp<%4>
    CLONE ir<%incdec.ptr170> = getelementptr inbounds ir<%f2.4>, ir<8>
    vp<%5> = vector-pointer ir<%f2.4>
    WIDEN store vp<%5>, ir<%27>
    CLONE ir<%cmp172> = icmp ult ir<%incdec.ptr169>, ir<%add.ptr167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end174>, scalar.ph

ir-bb<do.end174>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then160>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %26 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr161>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr162>, 8
    CLONE ir<%incdec.ptr169> = getelementptr inbounds ir<%f1.4>, ir<8>
    vp<%4> = vector-pointer ir<%f1.4>
    WIDEN ir<%27> = load vp<%4>
    CLONE ir<%incdec.ptr170> = getelementptr inbounds ir<%f2.4>, ir<8>
    vp<%5> = vector-pointer ir<%f2.4>
    WIDEN store vp<%5>, ir<%27>
    CLONE ir<%cmp172> = icmp ult ir<%incdec.ptr169>, ir<%add.ptr167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end174>, scalar.ph

ir-bb<do.end174>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.4 = phi ptr [ %add.ptr161, %if.then160 ], [ %incdec.ptr169, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.4 = phi ptr [ %add.ptr162, %if.then160 ], [ %incdec.ptr170, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr169 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr170 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %27, ptr %f2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp172 = icmp ult ptr %incdec.ptr169, %add.ptr167 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp172, label %do.body168, label %do.end174 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.4 = phi ptr [ %add.ptr161, %if.then160 ], [ %incdec.ptr169, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.4 = phi ptr [ %add.ptr162, %if.then160 ], [ %incdec.ptr170, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr169 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr170 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %27, ptr %f2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp172 = icmp ult ptr %incdec.ptr169, %add.ptr167 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp172, label %do.body168, label %do.end174 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.4 = phi ptr [ %add.ptr161, %if.then160 ], [ %incdec.ptr169, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.4 = phi ptr [ %add.ptr162, %if.then160 ], [ %incdec.ptr170, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr169 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr170 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %27, ptr %f2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp172 = icmp ult ptr %incdec.ptr169, %add.ptr167 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp172, label %do.body168, label %do.end174 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.4 = phi ptr [ %add.ptr161, %if.then160 ], [ %incdec.ptr169, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.4 = phi ptr [ %add.ptr162, %if.then160 ], [ %incdec.ptr170, %do.body168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr169 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %27 = load ptr, ptr %f1.4, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr170 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %27, ptr %f2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp172 = icmp ult ptr %incdec.ptr169, %add.ptr167 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp172, label %do.body168, label %do.end174 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then160>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %27 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%add.ptr161>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%add.ptr162>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%31> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%31>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end174>, scalar.ph

ir-bb<do.end174>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %73, ptr %f2.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %73, ptr %f2.5, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %73, ptr %f2.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then187>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %72 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr188>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr189>, 8
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%f1.5>, ir<8>
    CLONE ir<%73> = load ir<%f1.5>
    CLONE ir<%incdec.ptr202> = getelementptr inbounds ir<%f2.5>, ir<8>
    CLONE store ir<%73>, ir<%f2.5>
    CLONE ir<%cmp204> = icmp ult ir<%incdec.ptr201>, ir<%add.ptr199>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end206>, scalar.ph

ir-bb<do.end206>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then187>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %72 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr188>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr189>, 8
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%f1.5>, ir<8>
    vp<%4> = vector-pointer ir<%f1.5>
    WIDEN ir<%73> = load vp<%4>
    CLONE ir<%incdec.ptr202> = getelementptr inbounds ir<%f2.5>, ir<8>
    vp<%5> = vector-pointer ir<%f2.5>
    WIDEN store vp<%5>, ir<%73>
    CLONE ir<%cmp204> = icmp ult ir<%incdec.ptr201>, ir<%add.ptr199>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end206>, scalar.ph

ir-bb<do.end206>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then187>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %72 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr188>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr189>, 8
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%f1.5>, ir<8>
    vp<%4> = vector-pointer ir<%f1.5>
    WIDEN ir<%73> = load vp<%4>
    CLONE ir<%incdec.ptr202> = getelementptr inbounds ir<%f2.5>, ir<8>
    vp<%5> = vector-pointer ir<%f2.5>
    WIDEN store vp<%5>, ir<%73>
    CLONE ir<%cmp204> = icmp ult ir<%incdec.ptr201>, ir<%add.ptr199>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end206>, scalar.ph

ir-bb<do.end206>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.5 = phi ptr [ %add.ptr188, %if.then187 ], [ %incdec.ptr201, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.5 = phi ptr [ %add.ptr189, %if.then187 ], [ %incdec.ptr202, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr202 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %73, ptr %f2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp204 = icmp ult ptr %incdec.ptr201, %add.ptr199 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp204, label %do.body200, label %do.end206 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.5 = phi ptr [ %add.ptr188, %if.then187 ], [ %incdec.ptr201, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.5 = phi ptr [ %add.ptr189, %if.then187 ], [ %incdec.ptr202, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr202 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %73, ptr %f2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp204 = icmp ult ptr %incdec.ptr201, %add.ptr199 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp204, label %do.body200, label %do.end206 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.5 = phi ptr [ %add.ptr188, %if.then187 ], [ %incdec.ptr201, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.5 = phi ptr [ %add.ptr189, %if.then187 ], [ %incdec.ptr202, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr202 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %73, ptr %f2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp204 = icmp ult ptr %incdec.ptr201, %add.ptr199 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp204, label %do.body200, label %do.end206 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.5 = phi ptr [ %add.ptr188, %if.then187 ], [ %incdec.ptr201, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.5 = phi ptr [ %add.ptr189, %if.then187 ], [ %incdec.ptr202, %do.body200 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %73 = load ptr, ptr %f1.5, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr202 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %73, ptr %f2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp204 = icmp ult ptr %incdec.ptr201, %add.ptr199 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp204, label %do.body200, label %do.end206 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then187>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %72 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%add.ptr188>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%add.ptr189>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%76> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%76>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end206>, scalar.ph

ir-bb<do.end206>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body110.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr111> = getelementptr inbounds ir<%f2.3>, ir<8>
    CLONE ir<%29> = load ir<%f2.3>
    CLONE ir<%incdec.ptr112> = getelementptr inbounds ir<%tp2.4>, ir<8>
    CLONE store ir<%29>, ir<%tp2.4>
    CLONE ir<%cmp114> = icmp ult ir<%incdec.ptr111>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end126.loopexit>, scalar.ph

ir-bb<if.end126.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr112.lcssa = ir<%incdec.ptr112>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body110.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr111> = getelementptr inbounds ir<%f2.3>, ir<8>
    vp<%4> = vector-pointer ir<%f2.3>
    WIDEN ir<%29> = load vp<%4>
    CLONE ir<%incdec.ptr112> = getelementptr inbounds ir<%tp2.4>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.4>
    WIDEN store vp<%5>, ir<%29>
    CLONE ir<%cmp114> = icmp ult ir<%incdec.ptr111>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end126.loopexit>, scalar.ph

ir-bb<if.end126.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr112.lcssa = ir<%incdec.ptr112>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body110.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr111> = getelementptr inbounds ir<%f2.3>, ir<8>
    vp<%4> = vector-pointer ir<%f2.3>
    WIDEN ir<%29> = load vp<%4>
    CLONE ir<%incdec.ptr112> = getelementptr inbounds ir<%tp2.4>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.4>
    WIDEN store vp<%5>, ir<%29>
    CLONE ir<%cmp114> = icmp ult ir<%incdec.ptr111>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end126.loopexit>, scalar.ph

ir-bb<if.end126.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr112.lcssa = ir<%incdec.ptr112>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.3 = phi ptr [ %incdec.ptr111, %do.body110 ], [ %f2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr112, %do.body110 ], [ %tp2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr111 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr112 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %29, ptr %tp2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp114 = icmp ult ptr %incdec.ptr111, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp114, label %do.body110, label %if.end126.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.3 = phi ptr [ %incdec.ptr111, %do.body110 ], [ %f2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr112, %do.body110 ], [ %tp2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr111 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr112 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %29, ptr %tp2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp114 = icmp ult ptr %incdec.ptr111, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp114, label %do.body110, label %if.end126.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.3 = phi ptr [ %incdec.ptr111, %do.body110 ], [ %f2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr112, %do.body110 ], [ %tp2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr111 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr112 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %29, ptr %tp2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp114 = icmp ult ptr %incdec.ptr111, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp114, label %do.body110, label %if.end126.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.3 = phi ptr [ %incdec.ptr111, %do.body110 ], [ %f2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr112, %do.body110 ], [ %tp2.0.lcssa, %do.body110.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr111 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %29 = load ptr, ptr %f2.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr112 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %29, ptr %tp2.4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp114 = icmp ult ptr %incdec.ptr111, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp114, label %do.body110, label %if.end126.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body110.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f2.0.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0.lcssa>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%33> = load vp<%10>
    CLONE ir<%incdec.ptr112> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%33>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end126.loopexit>, scalar.ph

ir-bb<if.end126.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr112.lcssa = ir<%incdec.ptr112>
}
================ Final VPlan ================

@@ Instruction =>  %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %72, ptr %tp2.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %72, ptr %tp2.5, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %72, ptr %tp2.5, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body119.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr120> = getelementptr inbounds ir<%f1.3>, ir<8>
    CLONE ir<%72> = load ir<%f1.3>
    CLONE ir<%incdec.ptr121> = getelementptr inbounds ir<%tp2.5>, ir<8>
    CLONE store ir<%72>, ir<%tp2.5>
    CLONE ir<%cmp123> = icmp ult ir<%incdec.ptr120>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end126.loopexit435>, scalar.ph

ir-bb<if.end126.loopexit435>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr121.lcssa = ir<%incdec.ptr121>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body119.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr120> = getelementptr inbounds ir<%f1.3>, ir<8>
    vp<%4> = vector-pointer ir<%f1.3>
    WIDEN ir<%72> = load vp<%4>
    CLONE ir<%incdec.ptr121> = getelementptr inbounds ir<%tp2.5>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.5>
    WIDEN store vp<%5>, ir<%72>
    CLONE ir<%cmp123> = icmp ult ir<%incdec.ptr120>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end126.loopexit435>, scalar.ph

ir-bb<if.end126.loopexit435>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr121.lcssa = ir<%incdec.ptr121>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body119.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr120> = getelementptr inbounds ir<%f1.3>, ir<8>
    vp<%4> = vector-pointer ir<%f1.3>
    WIDEN ir<%72> = load vp<%4>
    CLONE ir<%incdec.ptr121> = getelementptr inbounds ir<%tp2.5>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.5>
    WIDEN store vp<%5>, ir<%72>
    CLONE ir<%cmp123> = icmp ult ir<%incdec.ptr120>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end126.loopexit435>, scalar.ph

ir-bb<if.end126.loopexit435>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr121.lcssa = ir<%incdec.ptr121>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.3 = phi ptr [ %incdec.ptr120, %do.body119 ], [ %f1.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr121, %do.body119 ], [ %tp2.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr120 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr121 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %72, ptr %tp2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp123 = icmp ult ptr %incdec.ptr120, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp123, label %do.body119, label %if.end126.loopexit435 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.3 = phi ptr [ %incdec.ptr120, %do.body119 ], [ %f1.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr121, %do.body119 ], [ %tp2.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr120 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr121 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %72, ptr %tp2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp123 = icmp ult ptr %incdec.ptr120, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp123, label %do.body119, label %if.end126.loopexit435 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.3 = phi ptr [ %incdec.ptr120, %do.body119 ], [ %f1.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr121, %do.body119 ], [ %tp2.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr120 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr121 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %72, ptr %tp2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp123 = icmp ult ptr %incdec.ptr120, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp123, label %do.body119, label %if.end126.loopexit435 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.3 = phi ptr [ %incdec.ptr120, %do.body119 ], [ %f1.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr121, %do.body119 ], [ %tp2.0.lcssa, %do.body119.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr120 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %72 = load ptr, ptr %f1.3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr121 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %72, ptr %tp2.5, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp123 = icmp ult ptr %incdec.ptr120, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp123, label %do.body119, label %if.end126.loopexit435 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body119.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f1.0.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0.lcssa>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%76> = load vp<%10>
    CLONE ir<%incdec.ptr121> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%76>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end126.loopexit435>, scalar.ph

ir-bb<if.end126.loopexit435>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr121.lcssa = ir<%incdec.ptr121>
}
================ Final VPlan ================

@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body85.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0408 to i64)) + ((8 + (ptrtoint ptr %f2.0408 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0408>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr86> = getelementptr inbounds ir<%f2.1>, ir<8>
    CLONE ir<%25> = load ir<%f2.1>
    CLONE ir<%incdec.ptr87> = getelementptr inbounds ir<%tp2.1>, ir<8>
    CLONE store ir<%25>, ir<%tp2.1>
    CLONE ir<%cmp88> = icmp ult ir<%incdec.ptr86>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr86.lcssa = ir<%incdec.ptr86>
Live-out ptr %incdec.ptr87.lcssa = ir<%incdec.ptr87>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body85.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0408 to i64)) + ((8 + (ptrtoint ptr %f2.0408 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0408>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr86> = getelementptr inbounds ir<%f2.1>, ir<8>
    vp<%4> = vector-pointer ir<%f2.1>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr87> = getelementptr inbounds ir<%tp2.1>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.1>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp88> = icmp ult ir<%incdec.ptr86>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr86.lcssa = ir<%incdec.ptr86>
Live-out ptr %incdec.ptr87.lcssa = ir<%incdec.ptr87>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body85.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0408 to i64)) + ((8 + (ptrtoint ptr %f2.0408 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0408>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr86> = getelementptr inbounds ir<%f2.1>, ir<8>
    vp<%4> = vector-pointer ir<%f2.1>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr87> = getelementptr inbounds ir<%tp2.1>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.1>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp88> = icmp ult ir<%incdec.ptr86>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr86.lcssa = ir<%incdec.ptr86>
Live-out ptr %incdec.ptr87.lcssa = ir<%incdec.ptr87>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.1 = phi ptr [ %incdec.ptr86, %do.body85 ], [ %f2.0408, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr87, %do.body85 ], [ %tp2.0409, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr86 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr87 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %25, ptr %tp2.1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp88 = icmp ult ptr %incdec.ptr86, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp88, label %do.body85, label %do.end of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.1 = phi ptr [ %incdec.ptr86, %do.body85 ], [ %f2.0408, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr87, %do.body85 ], [ %tp2.0409, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr86 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr87 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %25, ptr %tp2.1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp88 = icmp ult ptr %incdec.ptr86, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp88, label %do.body85, label %do.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.1 = phi ptr [ %incdec.ptr86, %do.body85 ], [ %f2.0408, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr87, %do.body85 ], [ %tp2.0409, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr86 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr87 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %25, ptr %tp2.1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp88 = icmp ult ptr %incdec.ptr86, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp88, label %do.body85, label %do.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.1 = phi ptr [ %incdec.ptr86, %do.body85 ], [ %f2.0408, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr87, %do.body85 ], [ %tp2.0409, %do.body85.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr86 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %25 = load ptr, ptr %f2.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr87 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %25, ptr %tp2.1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp88 = icmp ult ptr %incdec.ptr86, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp88, label %do.body85, label %do.end of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body85.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0408 to i64)) + ((8 + (ptrtoint ptr %f2.0408 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f2.0408>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0409>, vp<%8>
    CLONE ir<%incdec.ptr86> = getelementptr inbounds vp<%6>, ir<8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%29> = load vp<%10>
    CLONE ir<%incdec.ptr87> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%29>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr86.lcssa = ir<%incdec.ptr86>
Live-out ptr %incdec.ptr87.lcssa = ir<%incdec.ptr87>
}
================ Final VPlan ================

@@ Instruction =>  %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %69, ptr %tp2.2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %69, ptr %tp2.2, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %69, ptr %tp2.2, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body93.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0407 to i64)) + ((8 + (ptrtoint ptr %f1.0407 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0407>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr94> = getelementptr inbounds ir<%f1.1>, ir<8>
    CLONE ir<%69> = load ir<%f1.1>
    CLONE ir<%incdec.ptr95> = getelementptr inbounds ir<%tp2.2>, ir<8>
    CLONE store ir<%69>, ir<%tp2.2>
    CLONE ir<%cmp97> = icmp ult ir<%incdec.ptr94>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end99>, scalar.ph

ir-bb<do.end99>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr94.lcssa = ir<%incdec.ptr94>
Live-out ptr %incdec.ptr95.lcssa = ir<%incdec.ptr95>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body93.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0407 to i64)) + ((8 + (ptrtoint ptr %f1.0407 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0407>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr94> = getelementptr inbounds ir<%f1.1>, ir<8>
    vp<%4> = vector-pointer ir<%f1.1>
    WIDEN ir<%69> = load vp<%4>
    CLONE ir<%incdec.ptr95> = getelementptr inbounds ir<%tp2.2>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.2>
    WIDEN store vp<%5>, ir<%69>
    CLONE ir<%cmp97> = icmp ult ir<%incdec.ptr94>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end99>, scalar.ph

ir-bb<do.end99>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr94.lcssa = ir<%incdec.ptr94>
Live-out ptr %incdec.ptr95.lcssa = ir<%incdec.ptr95>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body93.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0407 to i64)) + ((8 + (ptrtoint ptr %f1.0407 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0407>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0409>, 8
    CLONE ir<%incdec.ptr94> = getelementptr inbounds ir<%f1.1>, ir<8>
    vp<%4> = vector-pointer ir<%f1.1>
    WIDEN ir<%69> = load vp<%4>
    CLONE ir<%incdec.ptr95> = getelementptr inbounds ir<%tp2.2>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.2>
    WIDEN store vp<%5>, ir<%69>
    CLONE ir<%cmp97> = icmp ult ir<%incdec.ptr94>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end99>, scalar.ph

ir-bb<do.end99>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr94.lcssa = ir<%incdec.ptr94>
Live-out ptr %incdec.ptr95.lcssa = ir<%incdec.ptr95>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.1 = phi ptr [ %incdec.ptr94, %do.body93 ], [ %f1.0407, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr95, %do.body93 ], [ %tp2.0409, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr94 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr95 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %69, ptr %tp2.2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp97 = icmp ult ptr %incdec.ptr94, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp97, label %do.body93, label %do.end99 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.1 = phi ptr [ %incdec.ptr94, %do.body93 ], [ %f1.0407, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr95, %do.body93 ], [ %tp2.0409, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr94 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr95 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %69, ptr %tp2.2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp97 = icmp ult ptr %incdec.ptr94, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp97, label %do.body93, label %do.end99 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.1 = phi ptr [ %incdec.ptr94, %do.body93 ], [ %f1.0407, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr95, %do.body93 ], [ %tp2.0409, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr94 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr95 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %69, ptr %tp2.2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp97 = icmp ult ptr %incdec.ptr94, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp97, label %do.body93, label %do.end99 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.1 = phi ptr [ %incdec.ptr94, %do.body93 ], [ %f1.0407, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr95, %do.body93 ], [ %tp2.0409, %do.body93.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr94 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %69 = load ptr, ptr %f1.1, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr95 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %69, ptr %tp2.2, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp97 = icmp ult ptr %incdec.ptr94, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp97, label %do.body93, label %do.end99 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body93.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0407 to i64)) + ((8 + (ptrtoint ptr %f1.0407 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f1.0407>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0409>, vp<%8>
    CLONE ir<%incdec.ptr94> = getelementptr inbounds vp<%6>, ir<8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%73> = load vp<%10>
    CLONE ir<%incdec.ptr95> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%73>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end99>, scalar.ph

ir-bb<do.end99>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr94.lcssa = ir<%incdec.ptr94>
Live-out ptr %incdec.ptr95.lcssa = ir<%incdec.ptr95>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%pp.0108> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0107> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0106 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0106>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%q.0107>, ir<8>
    CLONE ir<%incdec.ptr19> = getelementptr inbounds ir<%pp.0108>, ir<8>
    CLONE store ir<%q.0107>, ir<%pp.0108>
    CLONE ir<%tobool18.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%pp.0108> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0107> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0106 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0106>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%q.0107>, ir<8>
    CLONE ir<%incdec.ptr19> = getelementptr inbounds ir<%pp.0108>, ir<8>
    vp<%3> = vector-pointer ir<%pp.0108>
    WIDEN store vp<%3>, ir<%q.0107>
    CLONE ir<%tobool18.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%pp.0108> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0107> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0106 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0106>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%q.0107>, ir<8>
    CLONE ir<%incdec.ptr19> = getelementptr inbounds ir<%pp.0108>, ir<8>
    vp<%3> = vector-pointer ir<%pp.0108>
    WIDEN store vp<%3>, ir<%q.0107>
    CLONE ir<%tobool18.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %pp.0108 = phi ptr [ %indir.0, %if.end17 ], [ %incdec.ptr19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.0107 = phi ptr [ %list1, %if.end17 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.0106 = phi i64 [ %nmemb, %if.end17 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %n.0106, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0107, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %pp.0108, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool18.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool18.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %pp.0108 = phi ptr [ %indir.0, %if.end17 ], [ %incdec.ptr19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.0107 = phi ptr [ %list1, %if.end17 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.0106 = phi i64 [ %nmemb, %if.end17 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %n.0106, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0107, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %pp.0108, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool18.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool18.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %pp.0108 = phi ptr [ %indir.0, %if.end17 ], [ %incdec.ptr19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.0107 = phi ptr [ %list1, %if.end17 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.0106 = phi i64 [ %nmemb, %if.end17 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %n.0106, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0107, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %pp.0108, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool18.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool18.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %pp.0108 = phi ptr [ %indir.0, %if.end17 ], [ %incdec.ptr19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.0107 = phi ptr [ %list1, %if.end17 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.0106 = phi i64 [ %nmemb, %if.end17 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %n.0106, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0107, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %pp.0108, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %q.0107, ptr %pp.0108, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool18.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool18.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_qsortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%q.0107> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%indir.0>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%q.0107>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199.us> = phi ir<%runs.2>, ir<%inc88.us>
    EMIT ir<%p2.3198.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    CLONE ir<%add.ptr87.us> = getelementptr inbounds ir<%p2.3198.us>, ir<16>
    CLONE store ir<%add.ptr87.us>, ir<%p2.3198.us>
    CLONE ir<%inc88.us> = add ir<%runs.3199.us>, ir<1>
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5197.us>, ir<16>
    CLONE ir<%cmp84.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199.us>, ir<%inc88.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit>, scalar.ph

ir-bb<while.end97.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.us.lcssa = ir<%add.ptr87.us>
Live-out i64 %inc88.us.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199.us> = phi ir<%runs.2>, ir<%inc88.us>
    EMIT ir<%p2.3198.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87.us> = getelementptr inbounds ir<%p2.3198.us>, ir<16>
    REPLICATE store ir<%add.ptr87.us>, ir<%p2.3198.us>
    WIDEN ir<%inc88.us> = add ir<%runs.3199.us>, ir<1>
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5197.us>, ir<16>
    CLONE ir<%cmp84.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199.us>, ir<%inc88.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit>, scalar.ph

ir-bb<while.end97.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.us.lcssa = ir<%add.ptr87.us>
Live-out i64 %inc88.us.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199.us> = phi ir<%runs.2>, ir<%inc88.us>
    EMIT ir<%p2.3198.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87.us> = getelementptr inbounds ir<%p2.3198.us>, ir<16>
    REPLICATE store ir<%add.ptr87.us>, ir<%p2.3198.us>
    WIDEN ir<%inc88.us> = add ir<%runs.3199.us>, ir<1>
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5197.us>, ir<16>
    CLONE ir<%cmp84.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199.us>, ir<%inc88.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit>, scalar.ph

ir-bb<while.end97.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.us.lcssa = ir<%add.ptr87.us>
Live-out i64 %inc88.us.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199.us> = phi ir<%runs.2>, ir<%inc88.us>
    EMIT ir<%p2.3198.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87.us> = getelementptr inbounds ir<%p2.3198.us>, ir<16>
    WIDEN store ir<%p2.3198.us>, ir<%add.ptr87.us>
    WIDEN ir<%inc88.us> = add ir<%runs.3199.us>, ir<1>
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5197.us>, ir<16>
    CLONE ir<%cmp84.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199.us>, ir<%inc88.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit>, scalar.ph

ir-bb<while.end97.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.us.lcssa = ir<%add.ptr87.us>
Live-out i64 %inc88.us.lcssa = vp<%6>
}


-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %runs.3199.us = phi i64 [ %inc88.us, %while.body86.us ], [ %runs.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p2.3198.us = phi ptr [ %add.ptr87.us, %while.body86.us ], [ %p2.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.5197.us = phi ptr [ %q.6.us, %while.body86.us ], [ %q.4, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr87.us = getelementptr inbounds i8, ptr %p2.3198.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr87.us, ptr %p2.3198.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc88.us = add nsw i64 %runs.3199.us, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5197.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp84.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp84.us, label %while.body86.us, label %while.end97.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %runs.3199.us = phi i64 [ %inc88.us, %while.body86.us ], [ %runs.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p2.3198.us = phi ptr [ %add.ptr87.us, %while.body86.us ], [ %p2.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.5197.us = phi ptr [ %q.6.us, %while.body86.us ], [ %q.4, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr87.us = getelementptr inbounds i8, ptr %p2.3198.us, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr87.us, ptr %p2.3198.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc88.us = add nsw i64 %runs.3199.us, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5197.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp84.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp84.us, label %while.body86.us, label %while.end97.loopexit of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 32
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 32
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %runs.3199.us = phi i64 [ %inc88.us, %while.body86.us ], [ %runs.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p2.3198.us = phi ptr [ %add.ptr87.us, %while.body86.us ], [ %p2.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.5197.us = phi ptr [ %q.6.us, %while.body86.us ], [ %q.4, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr87.us = getelementptr inbounds i8, ptr %p2.3198.us, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr87.us, ptr %p2.3198.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc88.us = add nsw i64 %runs.3199.us, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5197.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp84.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp84.us, label %while.body86.us, label %while.end97.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %runs.3199.us = phi i64 [ %inc88.us, %while.body86.us ], [ %runs.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p2.3198.us = phi ptr [ %add.ptr87.us, %while.body86.us ], [ %p2.2, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.5197.us = phi ptr [ %q.6.us, %while.body86.us ], [ %q.4, %while.body86.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr87.us = getelementptr inbounds i8, ptr %p2.3198.us, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr87.us, ptr %p2.3198.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc88.us = add nsw i64 %runs.3199.us, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5197.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp84.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp84.us, label %while.body86.us, label %while.end97.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: dynprep at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%runs.3199.us> = phi ir<%runs.2>, ir<%inc88.us>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%p2.2>, vp<%5>
    CLONE ir<%add.ptr87.us> = getelementptr inbounds vp<%6>, ir<16>
    CLONE store ir<%add.ptr87.us>, vp<%6>
    CLONE ir<%inc88.us> = add ir<%runs.3199.us>, ir<1>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%runs.3199.us>, ir<%inc88.us>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end97.loopexit>, scalar.ph

ir-bb<while.end97.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.us.lcssa = ir<%add.ptr87.us>
Live-out i64 %inc88.us.lcssa = vp<%9>
}
================ Final VPlan ================

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199> = phi ir<%runs.2>, ir<%inc88>
    EMIT ir<%p2.3198> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    CLONE ir<%add.ptr87> = getelementptr inbounds ir<%p2.3198>, ir<16>
    CLONE store ir<%add.ptr87>, ir<%p2.3198>
    CLONE ir<%inc88> = add ir<%runs.3199>, ir<1>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%q.5197>, ir<8>
    CLONE ir<%26> = load ir<%q.5197>
    CLONE ir<%27> = load ir<%incdec.ptr91>
    CLONE store ir<%27>, ir<%q.5197>
    CLONE store ir<%26>, ir<%incdec.ptr91>
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5197>, ir<16>
    CLONE ir<%cmp84> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199>, ir<%inc88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit211>, scalar.ph

ir-bb<while.end97.loopexit211>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.lcssa = ir<%add.ptr87>
Live-out i64 %inc88.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199> = phi ir<%runs.2>, ir<%inc88>
    EMIT ir<%p2.3198> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87> = getelementptr inbounds ir<%p2.3198>, ir<16>
    REPLICATE store ir<%add.ptr87>, ir<%p2.3198>
    WIDEN ir<%inc88> = add ir<%runs.3199>, ir<1>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%q.5197>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %26, ir<%q.5197>
      ir<%26> = load from index 0
      ir<%27> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr91>
      store ir<%27> to index 0
      store ir<%26> to index 1
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5197>, ir<16>
    CLONE ir<%cmp84> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199>, ir<%inc88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit211>, scalar.ph

ir-bb<while.end97.loopexit211>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.lcssa = ir<%add.ptr87>
Live-out i64 %inc88.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199> = phi ir<%runs.2>, ir<%inc88>
    EMIT ir<%p2.3198> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87> = getelementptr inbounds ir<%p2.3198>, ir<16>
    REPLICATE store ir<%add.ptr87>, ir<%p2.3198>
    WIDEN ir<%inc88> = add ir<%runs.3199>, ir<1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr91> = getelementptr inbounds ir<%q.5197>, ir<8>
    REPLICATE ir<%26> = load ir<%q.5197>
    REPLICATE ir<%27> = load ir<%incdec.ptr91>
    REPLICATE store ir<%27>, ir<%q.5197>
    REPLICATE store ir<%26>, ir<%incdec.ptr91>
    WIDEN-GEP Var[Inv] ir<%q.6> = getelementptr inbounds ir<%q.5197>, ir<16>
    CLONE ir<%cmp84> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199>, ir<%inc88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit211>, scalar.ph

ir-bb<while.end97.loopexit211>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.lcssa = ir<%add.ptr87>
Live-out i64 %inc88.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3199> = phi ir<%runs.2>, ir<%inc88>
    EMIT ir<%p2.3198> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5197> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr87> = getelementptr inbounds ir<%p2.3198>, ir<16>
    WIDEN store ir<%p2.3198>, ir<%add.ptr87>
    WIDEN ir<%inc88> = add ir<%runs.3199>, ir<1>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%q.5197>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %26, ir<%q.5197>
      ir<%26> = load from index 0
      ir<%27> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr91>
      store ir<%27> to index 0
      store ir<%26> to index 1
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5197>, ir<16>
    CLONE ir<%cmp84> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3199>, ir<%inc88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end97.loopexit211>, scalar.ph

ir-bb<while.end97.loopexit211>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.lcssa = ir<%add.ptr87>
Live-out i64 %inc88.lcssa = vp<%6>
}


-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %runs.3199 = phi i64 [ %inc88, %while.body86 ], [ %runs.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p2.3198 = phi ptr [ %add.ptr87, %while.body86 ], [ %p2.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.5197 = phi ptr [ %q.6, %while.body86 ], [ %q.4, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr87 = getelementptr inbounds i8, ptr %p2.3198, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr87, ptr %p2.3198, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc88 = add nsw i64 %runs.3199, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %q.5197, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %26 = load ptr, ptr %q.5197, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %27 = load ptr, ptr %incdec.ptr91, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %27, ptr %q.5197, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %26, ptr %incdec.ptr91, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5197, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp84 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp84, label %while.body86, label %while.end97.loopexit211 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %runs.3199 = phi i64 [ %inc88, %while.body86 ], [ %runs.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p2.3198 = phi ptr [ %add.ptr87, %while.body86 ], [ %p2.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.5197 = phi ptr [ %q.6, %while.body86 ], [ %q.4, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr87 = getelementptr inbounds i8, ptr %p2.3198, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr87, ptr %p2.3198, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc88 = add nsw i64 %runs.3199, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %q.5197, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %26 = load ptr, ptr %q.5197, align 8, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %27 = load ptr, ptr %incdec.ptr91, align 8, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %27, ptr %q.5197, align 8, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %26, ptr %incdec.ptr91, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5197, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp84 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp84, label %while.body86, label %while.end97.loopexit211 of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 36
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 36
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %runs.3199 = phi i64 [ %inc88, %while.body86 ], [ %runs.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p2.3198 = phi ptr [ %add.ptr87, %while.body86 ], [ %p2.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.5197 = phi ptr [ %q.6, %while.body86 ], [ %q.4, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr87 = getelementptr inbounds i8, ptr %p2.3198, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr87, ptr %p2.3198, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc88 = add nsw i64 %runs.3199, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %q.5197, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %26 = load ptr, ptr %q.5197, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %27 = load ptr, ptr %incdec.ptr91, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %27, ptr %q.5197, align 8, !tbaa !6 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %26, ptr %incdec.ptr91, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5197, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp84 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp84, label %while.body86, label %while.end97.loopexit211 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %runs.3199 = phi i64 [ %inc88, %while.body86 ], [ %runs.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p2.3198 = phi ptr [ %add.ptr87, %while.body86 ], [ %p2.2, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.5197 = phi ptr [ %q.6, %while.body86 ], [ %q.4, %while.body86.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr87 = getelementptr inbounds i8, ptr %p2.3198, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr87, ptr %p2.3198, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc88 = add nsw i64 %runs.3199, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %q.5197, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load ptr, ptr %q.5197, align 8, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %27 = load ptr, ptr %incdec.ptr91, align 8, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %27, ptr %q.5197, align 8, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %26, ptr %incdec.ptr91, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5197, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp84 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp84, label %while.body86, label %while.end97.loopexit211 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 11.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: dynprep at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body86.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%runs.3199> = phi ir<%runs.2>, ir<%inc88>
    EMIT ir<%p2.3198> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%q.4>, vp<%5>
    WIDEN-GEP Var[Inv] ir<%add.ptr87> = getelementptr inbounds ir<%p2.3198>, ir<16>
    WIDEN store ir<%p2.3198>, ir<%add.ptr87>
    WIDEN ir<%inc88> = add ir<%runs.3199>, ir<1>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds vp<%6>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %31, vp<%6>
      ir<%31> = load from index 0
      ir<%32> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr91>
      store ir<%32> to index 0
      store ir<%31> to index 1
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%runs.3199>, ir<%inc88>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end97.loopexit211>, scalar.ph

ir-bb<while.end97.loopexit211>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr87.lcssa = ir<%add.ptr87>
Live-out i64 %inc88.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 25
Loops Epilogues Vectorized: 0
================================================
MVT: v2i64
@@ Instruction =>  %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body484.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j457.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond459.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv942 = phi %indvars.iv.next943, %indvars.iv934, ir<-1>
    CLONE ir<%arrayidx486> = getelementptr inbounds ir<%array>, ir<%indvars.iv942>
    CLONE ir<%68> = load ir<%arrayidx486>
    CLONE ir<%arrayidx489> = getelementptr ir<%arrayidx486>, ir<8>
    CLONE store ir<%68>, ir<%arrayidx489>
    CLONE ir<%indvars.iv.next943> = add nsw ir<%indvars.iv942>, ir<-1>
    CLONE ir<%cmp482.not.not> = icmp sgt ir<%indvars.iv.next943>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end492.loopexit>, scalar.ph

ir-bb<for.end492.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body484.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j457.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond459.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv942 = phi %indvars.iv.next943, %indvars.iv934, ir<-1>
    CLONE ir<%arrayidx486> = getelementptr inbounds ir<%array>, ir<%indvars.iv942>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx486>
    WIDEN ir<%68> = load vp<%4>
    CLONE ir<%arrayidx489> = getelementptr ir<%arrayidx486>, ir<8>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx489>
    WIDEN store vp<%5>, ir<%68>
    CLONE ir<%indvars.iv.next943> = add nsw ir<%indvars.iv942>, ir<-1>
    CLONE ir<%cmp482.not.not> = icmp sgt ir<%indvars.iv.next943>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end492.loopexit>, scalar.ph

ir-bb<for.end492.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body484.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j457.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond459.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv942 = phi %indvars.iv.next943, %indvars.iv934, ir<-1>
    CLONE ir<%arrayidx486> = getelementptr inbounds ir<%array>, ir<%indvars.iv942>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx486>
    WIDEN ir<%68> = load vp<%4>
    CLONE ir<%arrayidx489> = getelementptr ir<%arrayidx486>, ir<8>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx489>
    WIDEN store vp<%5>, ir<%68>
    CLONE ir<%indvars.iv.next943> = add nsw ir<%indvars.iv942>, ir<-1>
    CLONE ir<%cmp482.not.not> = icmp sgt ir<%indvars.iv.next943>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end492.loopexit>, scalar.ph

ir-bb<for.end492.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv942 = phi i64 [ %indvars.iv.next943, %for.body484 ], [ %indvars.iv934, %for.body484.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx486 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv942 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx489 = getelementptr i8, ptr %arrayidx486, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next943 = add nsw i64 %indvars.iv942, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp482.not.not = icmp sgt i64 %indvars.iv.next943, %67 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp482.not.not, label %for.body484, label %for.end492.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv942 = phi i64 [ %indvars.iv.next943, %for.body484 ], [ %indvars.iv934, %for.body484.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx486 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv942 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx489 = getelementptr i8, ptr %arrayidx486, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next943 = add nsw i64 %indvars.iv942, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp482.not.not = icmp sgt i64 %indvars.iv.next943, %67 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp482.not.not, label %for.body484, label %for.end492.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv942 = phi i64 [ %indvars.iv.next943, %for.body484 ], [ %indvars.iv934, %for.body484.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx486 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv942 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx489 = getelementptr i8, ptr %arrayidx486, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next943 = add nsw i64 %indvars.iv942, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp482.not.not = icmp sgt i64 %indvars.iv.next943, %67 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp482.not.not, label %for.body484, label %for.end492.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv942 = phi i64 [ %indvars.iv.next943, %for.body484 ], [ %indvars.iv934, %for.body484.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx486 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv942 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %68 = load ptr, ptr %arrayidx486, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx489 = getelementptr i8, ptr %arrayidx486, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %68, ptr %arrayidx489, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next943 = add nsw i64 %indvars.iv942, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp482.not.not = icmp sgt i64 %indvars.iv.next943, %67 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp482.not.not, label %for.body484, label %for.end492.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_qsortsvu at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body484.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j457.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond459.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%indvars.iv934> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx486> = getelementptr inbounds ir<%array>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx486>
    WIDEN ir<%68> = load vp<%6>
    CLONE ir<%arrayidx489> = getelementptr ir<%arrayidx486>, ir<8>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx489>
    WIDEN store vp<%7>, ir<%68>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end492.loopexit>, scalar.ph

ir-bb<for.end492.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 30
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pp_sys.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        pp_sys.c
@@ Instruction =>  %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%sp.1303> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0302> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0301 = phi %dec, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec> = add ir<%items.0301>, ir<-1>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%mark.0302>, ir<8>
    CLONE ir<%34> = load ir<%mark.0302>
    CLONE ir<%incdec.ptr62> = getelementptr inbounds ir<%sp.1303>, ir<8>
    CLONE store ir<%34>, ir<%incdec.ptr62>
    CLONE ir<%tobool60.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr62.lcssa = ir<%incdec.ptr62>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.1303> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0302> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0301 = phi %dec, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec> = add ir<%items.0301>, ir<-1>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%mark.0302>, ir<8>
    vp<%3> = vector-pointer ir<%mark.0302>
    WIDEN ir<%34> = load vp<%3>
    CLONE ir<%incdec.ptr62> = getelementptr inbounds ir<%sp.1303>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr62>
    WIDEN store vp<%4>, ir<%34>
    CLONE ir<%tobool60.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr62.lcssa = ir<%incdec.ptr62>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.1303> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0302> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0301 = phi %dec, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec> = add ir<%items.0301>, ir<-1>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%mark.0302>, ir<8>
    vp<%3> = vector-pointer ir<%mark.0302>
    WIDEN ir<%34> = load vp<%3>
    CLONE ir<%incdec.ptr62> = getelementptr inbounds ir<%sp.1303>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr62>
    WIDEN store vp<%4>, ir<%34>
    CLONE ir<%tobool60.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr62.lcssa = ir<%incdec.ptr62>
}


-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.1303 = phi ptr [ %incdec.ptr62, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0302 = phi ptr [ %incdec.ptr61, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.0301 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div15, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %items.0301, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %mark.0302, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr62 = getelementptr inbounds i8, ptr %sp.1303, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool60.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool60.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.1303 = phi ptr [ %incdec.ptr62, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0302 = phi ptr [ %incdec.ptr61, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.0301 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div15, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %items.0301, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %mark.0302, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr62 = getelementptr inbounds i8, ptr %sp.1303, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool60.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool60.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.1303 = phi ptr [ %incdec.ptr62, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0302 = phi ptr [ %incdec.ptr61, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.0301 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div15, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %items.0301, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %mark.0302, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr62 = getelementptr inbounds i8, ptr %sp.1303, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool60.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool60.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.1303 = phi ptr [ %incdec.ptr62, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0302 = phi ptr [ %incdec.ptr61, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.0301 = phi i64 [ %dec, %while.body ], [ %sub.ptr.div15, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %items.0301, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %mark.0302, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %34 = load ptr, ptr %mark.0302, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr62 = getelementptr inbounds i8, ptr %sp.1303, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %34, ptr %incdec.ptr62, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool60.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool60.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_tie at line: pp_sys.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%sp.0>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<8>
    EMIT vp<%8> = ptradd ir<%incdec.ptr11>, vp<%7>
    vp<%9> = vector-pointer vp<%8>
    WIDEN ir<%42> = load vp<%9>
    CLONE ir<%incdec.ptr62> = getelementptr inbounds vp<%5>, ir<8>
    vp<%10> = vector-pointer ir<%incdec.ptr62>
    WIDEN store vp<%10>, ir<%42>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr62.lcssa = ir<%incdec.ptr62>
}
================ Final VPlan ================

@@ Instruction =>  %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%sp.3307> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1306> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1305 = phi %dec126, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec126> = add ir<%items.1305>, ir<-1>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%mark.1306>, ir<8>
    CLONE ir<%98> = load ir<%mark.1306>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%sp.3307>, ir<8>
    CLONE store ir<%98>, ir<%incdec.ptr130>
    CLONE ir<%tobool127.not> = icmp eq ir<%dec126>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end131.loopexit>, scalar.ph

ir-bb<while.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr130.lcssa = ir<%incdec.ptr130>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.3307> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1306> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1305 = phi %dec126, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec126> = add ir<%items.1305>, ir<-1>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%mark.1306>, ir<8>
    vp<%3> = vector-pointer ir<%mark.1306>
    WIDEN ir<%98> = load vp<%3>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%sp.3307>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr130>
    WIDEN store vp<%4>, ir<%98>
    CLONE ir<%tobool127.not> = icmp eq ir<%dec126>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end131.loopexit>, scalar.ph

ir-bb<while.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr130.lcssa = ir<%incdec.ptr130>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.3307> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1306> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1305 = phi %dec126, %sub.ptr.div15, ir<-1>
    CLONE ir<%dec126> = add ir<%items.1305>, ir<-1>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%mark.1306>, ir<8>
    vp<%3> = vector-pointer ir<%mark.1306>
    WIDEN ir<%98> = load vp<%3>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%sp.3307>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr130>
    WIDEN store vp<%4>, ir<%98>
    CLONE ir<%tobool127.not> = icmp eq ir<%dec126>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end131.loopexit>, scalar.ph

ir-bb<while.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr130.lcssa = ir<%incdec.ptr130>
}


-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.3307 = phi ptr [ %incdec.ptr130, %while.body128 ], [ %sp.2, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.1306 = phi ptr [ %incdec.ptr129, %while.body128 ], [ %incdec.ptr11, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.1305 = phi i64 [ %dec126, %while.body128 ], [ %sub.ptr.div15, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec126 = add i64 %items.1305, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %mark.1306, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %sp.3307, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool127.not = icmp eq i64 %dec126, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool127.not, label %while.end131.loopexit, label %while.body128 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.3307 = phi ptr [ %incdec.ptr130, %while.body128 ], [ %sp.2, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.1306 = phi ptr [ %incdec.ptr129, %while.body128 ], [ %incdec.ptr11, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.1305 = phi i64 [ %dec126, %while.body128 ], [ %sub.ptr.div15, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec126 = add i64 %items.1305, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %mark.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %sp.3307, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool127.not = icmp eq i64 %dec126, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool127.not, label %while.end131.loopexit, label %while.body128 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.3307 = phi ptr [ %incdec.ptr130, %while.body128 ], [ %sp.2, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.1306 = phi ptr [ %incdec.ptr129, %while.body128 ], [ %incdec.ptr11, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.1305 = phi i64 [ %dec126, %while.body128 ], [ %sub.ptr.div15, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec126 = add i64 %items.1305, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %mark.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %sp.3307, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool127.not = icmp eq i64 %dec126, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool127.not, label %while.end131.loopexit, label %while.body128 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.3307 = phi ptr [ %incdec.ptr130, %while.body128 ], [ %sp.2, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.1306 = phi ptr [ %incdec.ptr129, %while.body128 ], [ %incdec.ptr11, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.1305 = phi i64 [ %dec126, %while.body128 ], [ %sub.ptr.div15, %while.body128.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec126 = add i64 %items.1305, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %mark.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %98 = load ptr, ptr %mark.1306, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %sp.3307, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %98, ptr %incdec.ptr130, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool127.not = icmp eq i64 %dec126, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool127.not, label %while.end131.loopexit, label %while.body128 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: Perl_pp_tie at line: pp_sys.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%sub.ptr.div15> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%sp.2>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<8>
    EMIT vp<%8> = ptradd ir<%incdec.ptr11>, vp<%7>
    vp<%9> = vector-pointer vp<%8>
    WIDEN ir<%105> = load vp<%9>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds vp<%5>, ir<8>
    vp<%10> = vector-pointer ir<%incdec.ptr130>
    WIDEN store vp<%10>, ir<%105>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%sub.ptr.div15>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end131.loopexit>, scalar.ph

ir-bb<while.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr130.lcssa = ir<%incdec.ptr130>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o regcomp.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        regcomp.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o regexec.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        regexec.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o run.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        run.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o scope.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        scope.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        sv.c
========== Loop: Perl_sv_add_arena' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-48 + (-1 * (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64)))) /u 24) + (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sv.024> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 24
    CLONE ir<%add.ptr3> = getelementptr inbounds ir<%sv.024>, ir<24>
    CLONE store ir<%add.ptr3>, ir<%sv.024>
    CLONE ir<%sv_refcnt5> = getelementptr inbounds ir<%sv.024>, ir<8>
    CLONE store ir<0>, ir<%sv_refcnt5>
    CLONE ir<%sv_flags6> = getelementptr inbounds ir<%sv.024>, ir<16>
    CLONE store ir<255>, ir<%sv_flags6>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr3>, ir<%arrayidx>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr3.lcssa = ir<%add.ptr3>
}

========== Loop: Perl_sv_add_arena' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-48 + (-1 * (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64)))) /u 24) + (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sv.024> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 24
    WIDEN-GEP Var[Inv] ir<%add.ptr3> = getelementptr inbounds ir<%sv.024>, ir<24>
    CLONE ir<%sv_refcnt5> = getelementptr inbounds ir<%sv.024>, ir<8>
    CLONE ir<%sv_flags6> = getelementptr inbounds ir<%sv.024>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%sv_flags6>
      store ir<%add.ptr3> to index 0
      store ir<0> to index 1
      store ir<255> to index 2
    CLONE ir<%cmp> = icmp ult ir<%add.ptr3>, ir<%arrayidx>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr3.lcssa = ir<%add.ptr3>
}

========== Loop: Perl_sv_add_arena' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-48 + (-1 * (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64)))) /u 24) + (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sv.024> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 24
    WIDEN-GEP Var[Inv] ir<%add.ptr3> = getelementptr inbounds ir<%sv.024>, ir<24>
    REPLICATE store ir<%add.ptr3>, ir<%sv.024>
    WIDEN-GEP Var[Inv] ir<%sv_refcnt5> = getelementptr inbounds ir<%sv.024>, ir<8>
    REPLICATE store ir<0>, ir<%sv_refcnt5>
    WIDEN-GEP Var[Inv] ir<%sv_flags6> = getelementptr inbounds ir<%sv.024>, ir<16>
    REPLICATE store ir<255>, ir<%sv_flags6>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr3>, ir<%arrayidx>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr3.lcssa = ir<%add.ptr3>
}

========== Loop: Perl_sv_add_arena' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-48 + (-1 * (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64)))) /u 24) + (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sv.024> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 24
    WIDEN-GEP Var[Inv] ir<%add.ptr3> = getelementptr inbounds ir<%sv.024>, ir<24>
    WIDEN store ir<%sv.024>, ir<%add.ptr3>
    WIDEN-GEP Var[Inv] ir<%sv_refcnt5> = getelementptr inbounds ir<%sv.024>, ir<8>
    WIDEN store ir<%sv_refcnt5>, ir<0>
    WIDEN-GEP Var[Inv] ir<%sv_flags6> = getelementptr inbounds ir<%sv.024>, ir<16>
    WIDEN store ir<%sv_flags6>, ir<255>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr3>, ir<%arrayidx>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr3.lcssa = ir<%add.ptr3>
}


-----------------Function that is being costed:'Perl_sv_add_arena' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sv.024 = phi ptr [ %add.ptr3, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr3 = getelementptr inbounds i8, ptr %sv.024, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr3, ptr %sv.024, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sv_refcnt5 = getelementptr inbounds i8, ptr %sv.024, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 0, ptr %sv_refcnt5, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sv_flags6 = getelementptr inbounds i8, ptr %sv.024, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 255, ptr %sv_flags6, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult ptr %add.ptr3, %arrayidx of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_sv_add_arena' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sv.024 = phi ptr [ %add.ptr3, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr3 = getelementptr inbounds i8, ptr %sv.024, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %add.ptr3, ptr %sv.024, align 8, !tbaa !10 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 0, ptr %sv_refcnt5, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sv_flags6 = getelementptr inbounds i8, ptr %sv.024, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   store i64 255, ptr %sv_flags6, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult ptr %add.ptr3, %arrayidx of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_sv_add_arena' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sv.024 = phi ptr [ %add.ptr3, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr3 = getelementptr inbounds i8, ptr %sv.024, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %add.ptr3, ptr %sv.024, align 8, !tbaa !10 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 0, ptr %sv_refcnt5, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sv_flags6 = getelementptr inbounds i8, ptr %sv.024, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 255, ptr %sv_flags6, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult ptr %add.ptr3, %arrayidx of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_sv_add_arena' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sv.024 = phi ptr [ %add.ptr3, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr3 = getelementptr inbounds i8, ptr %sv.024, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %add.ptr3, ptr %sv.024, align 8, !tbaa !10 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 0, ptr %sv_refcnt5, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sv_flags6 = getelementptr inbounds i8, ptr %sv.024, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   store i64 255, ptr %sv_flags6, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult ptr %add.ptr3, %arrayidx of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 124, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 248, CostB * EstimatedWidthA: 16
LV: Selecting VF: 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=2 at function: Perl_sv_add_arena at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-48 + (-1 * (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64)))) /u 24) + (1 umin (-48 + (-1 * (ptrtoint ptr %ptr to i64)) + ((48 + (ptrtoint ptr %ptr to i64)) umax (-24 + (24 * (%size /u 24))<nuw> + (ptrtoint ptr %ptr to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sv.024> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 24
    WIDEN-GEP Var[Inv] ir<%add.ptr3> = getelementptr inbounds ir<%sv.024>, ir<24>
    CLONE ir<%sv_flags6> = getelementptr inbounds ir<%sv.024>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%sv_flags6>
      store ir<%add.ptr3> to index 0
      store ir<0> to index 1
      store ir<255> to index 2
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr3.lcssa = ir<%add.ptr3>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
MVT: v2i32
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%big.0278> = WIDEN-POINTER-INDUCTION ir<%add.ptr80>, -1
    WIDEN-INDUCTION %i.0277 = phi %offset, %dec, ir<-1>
    EMIT ir<%midend.1276> = WIDEN-POINTER-INDUCTION ir<%add.ptr130>, -1
    CLONE ir<%dec> = add nsw ir<%i.0277>, ir<-1>
    CLONE ir<%incdec.ptr137> = getelementptr inbounds ir<%big.0278>, ir<-1>
    CLONE ir<%26> = load ir<%incdec.ptr137>
    CLONE ir<%incdec.ptr138> = getelementptr inbounds ir<%midend.1276>, ir<-1>
    CLONE store ir<%26>, ir<%incdec.ptr138>
    CLONE ir<%tobool135.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%offset>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end139>, scalar.ph

ir-bb<while.end139>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%big.0278> = WIDEN-POINTER-INDUCTION ir<%add.ptr80>, -1
    WIDEN-INDUCTION %i.0277 = phi %offset, %dec, ir<-1>
    EMIT ir<%midend.1276> = WIDEN-POINTER-INDUCTION ir<%add.ptr130>, -1
    CLONE ir<%dec> = add nsw ir<%i.0277>, ir<-1>
    CLONE ir<%incdec.ptr137> = getelementptr inbounds ir<%big.0278>, ir<-1>
    vp<%3> = vector-pointer (reverse) ir<%incdec.ptr137>
    WIDEN ir<%26> = load vp<%3>
    CLONE ir<%incdec.ptr138> = getelementptr inbounds ir<%midend.1276>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr138>
    WIDEN store vp<%4>, ir<%26>
    CLONE ir<%tobool135.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%offset>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end139>, scalar.ph

ir-bb<while.end139>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%big.0278> = WIDEN-POINTER-INDUCTION ir<%add.ptr80>, -1
    WIDEN-INDUCTION %i.0277 = phi %offset, %dec, ir<-1>
    EMIT ir<%midend.1276> = WIDEN-POINTER-INDUCTION ir<%add.ptr130>, -1
    CLONE ir<%dec> = add nsw ir<%i.0277>, ir<-1>
    CLONE ir<%incdec.ptr137> = getelementptr inbounds ir<%big.0278>, ir<-1>
    vp<%3> = vector-pointer (reverse) ir<%incdec.ptr137>
    WIDEN ir<%26> = load vp<%3>
    CLONE ir<%incdec.ptr138> = getelementptr inbounds ir<%midend.1276>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr138>
    WIDEN store vp<%4>, ir<%26>
    CLONE ir<%tobool135.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%offset>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end139>, scalar.ph

ir-bb<while.end139>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %big.0278 = phi ptr [ %add.ptr80, %if.then129 ], [ %incdec.ptr137, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0277 = phi i64 [ %offset, %if.then129 ], [ %dec, %while.body136 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %midend.1276 = phi ptr [ %add.ptr130, %if.then129 ], [ %incdec.ptr138, %while.body136 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i64 %i.0277, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr137 = getelementptr inbounds i8, ptr %big.0278, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %26 = load i8, ptr %incdec.ptr137, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr138 = getelementptr inbounds i8, ptr %midend.1276, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %26, ptr %incdec.ptr138, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool135.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool135.not, label %while.end139, label %while.body136 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_sv_insert at line: sv.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%add.ptr80>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-1>
    EMIT vp<%8> = ptradd ir<%add.ptr130>, vp<%7>
    CLONE ir<%incdec.ptr137> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%9> = vector-pointer (reverse) ir<%incdec.ptr137>
    WIDEN ir<%43> = load vp<%9>
    CLONE ir<%incdec.ptr138> = getelementptr inbounds vp<%8>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr138>
    WIDEN store vp<%10>, ir<%43>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%offset>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end139>, scalar.ph

ir-bb<while.end139>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%offset> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%add.ptr80>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-1>
    EMIT vp<%8> = ptradd ir<%add.ptr130>, vp<%7>
    CLONE ir<%incdec.ptr137> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%9> = vector-pointer (reverse) ir<%incdec.ptr137>
    WIDEN ir<%92> = load vp<%9>
    CLONE ir<%incdec.ptr138> = getelementptr inbounds vp<%8>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr138>
    WIDEN store vp<%10>, ir<%92>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%offset>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end139>, scalar.ph

ir-bb<while.end139>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%bigend.0281> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -1
    EMIT ir<%midend.0280> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0280>, ir<-1>
    CLONE ir<%17> = load ir<%incdec.ptr>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%bigend.0281>, ir<-1>
    CLONE store ir<%17>, ir<%incdec.ptr64>
    CLONE ir<%cmp63> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%bigend.0281> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -1
    EMIT ir<%midend.0280> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0280>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%17> = load vp<%4>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%bigend.0281>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr64>
    WIDEN store vp<%5>, ir<%17>
    CLONE ir<%cmp63> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%bigend.0281> = WIDEN-POINTER-INDUCTION ir<%add.ptr62>, -1
    EMIT ir<%midend.0280> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0280>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%17> = load vp<%4>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%bigend.0281>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr64>
    WIDEN store vp<%5>, ir<%17>
    CLONE ir<%cmp63> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %bigend.0281 = phi ptr [ %incdec.ptr64, %while.body ], [ %add.ptr62, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %midend.0280 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr61, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0280, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %bigend.0281, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %17, ptr %incdec.ptr64, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp63 = icmp ugt ptr %incdec.ptr, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp63, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 112
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: Perl_sv_insert at line: sv.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%add.ptr62>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-1>
    EMIT vp<%9> = ptradd ir<%add.ptr61>, vp<%8>
    CLONE ir<%incdec.ptr> = getelementptr inbounds vp<%9>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%37> = load vp<%10>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%11> = vector-pointer (reverse) ir<%incdec.ptr64>
    WIDEN store vp<%11>, ir<%37>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%18> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%add.ptr62>, vp<%4>
    vp<%6>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-1>
    EMIT vp<%8> = ptradd ir<%add.ptr61>, vp<%7>
    CLONE ir<%incdec.ptr> = getelementptr inbounds vp<%8>, ir<-1>
    vp<%9> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%88> = load vp<%9>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr64>
    WIDEN store vp<%10>, ir<%88>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%18>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 30
Loops Epilogues Vectorized: 2
================================================
MVT: v2i64
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8, !tbaa !24 -> Cost: 11 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8, !tbaa !24 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + %6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.016 = phi %dec, %6, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%i.016>
    CLONE ir<%7> = load ir<%arrayidx>
    CLONE ir<%cmp4> = icmp eq ir<%7>, ir<%sv>
  Successor(s): if.then5

  if.then5:
    CLONE store ir<null>, ir<%arrayidx>, ir<%cmp4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp4>
    EMIT vp<%5> = or vp<%4>, ir<%cmp4>
    CLONE ir<%dec> = add nsw ir<%i.016>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%i.016>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + %6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.016 = phi %dec, %6, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, ir<%i.016>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%7> = load vp<%4>
    WIDEN ir<%cmp4> = icmp eq ir<%7>, ir<%sv>
  Successor(s): if.then5

  if.then5:
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<null>, ir<%cmp4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp4>
    EMIT vp<%7> = or vp<%6>, ir<%cmp4>
    CLONE ir<%dec> = add nsw ir<%i.016>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%i.016>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + %6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.016 = phi %dec, %6, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, ir<%i.016>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%7> = load vp<%4>
    WIDEN ir<%cmp4> = icmp eq ir<%7>, ir<%sv>
  Successor(s): if.then5

  if.then5:
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<null>, ir<%cmp4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp4>
    EMIT vp<%7> = or vp<%6>, ir<%cmp4>
    CLONE ir<%dec> = add nsw ir<%i.016>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%i.016>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.016 = phi i64 [ %dec, %for.inc ], [ %6, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %i.016 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4 = icmp eq ptr %7, %sv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp4, label %if.then5, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %arrayidx, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %i.016, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp sgt i64 %i.016, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.016 = phi i64 [ %dec, %for.inc ], [ %6, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %i.016 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4 = icmp eq ptr %7, %sv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp4, label %if.then5, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 2 For instruction:   store ptr null, ptr %arrayidx, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %i.016, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp sgt i64 %i.016, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.016 = phi i64 [ %dec, %for.inc ], [ %6, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %i.016 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4 = icmp eq ptr %7, %sv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp4, label %if.then5, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %i.016, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp sgt i64 %i.016, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.016 = phi i64 [ %dec, %for.inc ], [ %6, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %i.016 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp4 = icmp eq ptr %7, %sv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp4, label %if.then5, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %i.016, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp sgt i64 %i.016, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_sv_del_backref at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + %6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%6> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%7> = load vp<%6>
    WIDEN ir<%cmp4> = icmp eq ir<%7>, ir<%sv>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%7>, ir<null>, ir<%cmp4>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 32
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    CLONE ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xiv.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%3> = vector-pointer ir<%xiv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%3> = vector-pointer ir<%xiv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 2024
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 2024
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2024
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 759

-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 386, RTCostB: 2024
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 386, RTCostB: 759
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_more_xiv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 66
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    CLONE ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xnv.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%3> = vector-pointer ir<%xnv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%3> = vector-pointer ir<%xnv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 760, RTCostB: 2020
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 760, RTCostB: 2020
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2020
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 760

-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 2020
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 760
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_more_xnv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 67
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    CLONE ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xrv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%3> = vector-pointer ir<%xrv.0.ptr14>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%3> = vector-pointer ir<%xrv.0.ptr14>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 2024
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 2024
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2024
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 759

-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 386, RTCostB: 2024
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 386, RTCostB: 759
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: S_more_xrv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 68
Loops Epilogues Vectorized: 2
================================================
========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    CLONE ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%xpv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    REPLICATE store ir<%add.ptr.ptr>, ir<%xpv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    REPLICATE store ir<%add.ptr.ptr>, ir<%xpv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    WIDEN store ir<%xpv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 2688, RTCostB: 672
A is not scalable.	B is not scalable.	
RTCostA: 2688, RTCostB: 672

-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 672
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 672

-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 1806, RTCostB: 672
A is scalable.	B is not scalable.	
RTCostA: 1806, RTCostB: 672
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: S_more_xpv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<24>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<24>
    EMIT vp<%5> = ptradd ir<%incdec.ptr.ptr>, vp<%4>
    vp<%6>    = DERIVED-IV ir<24> + vp<%2> * ir<24>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<24>
    CLONE ir<%xpv.0.add> = add nuw nsw vp<%7>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    CLONE store ir<%add.ptr.ptr>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 69
Loops Epilogues Vectorized: 2
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o taint.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        taint.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o toke.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        toke.c
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body538.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c532.01434> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01433> = phi ir<0>, ir<%spec.select1352>
    CLONE ir<%106> = load ir<%c532.01434>
    CLONE ir<%.lobit> = lshr ir<%106>, ir<7>
    CLONE ir<%inc543> = zext nneg ir<%.lobit>
    CLONE ir<%spec.select1352> = add ir<%hicount.01433>, ir<%inc543>
    CLONE ir<%incdec.ptr546> = getelementptr inbounds ir<%c532.01434>, ir<1>
    CLONE ir<%exitcond1492.not> = icmp eq ir<%incdec.ptr546>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hicount.01433>, ir<%spec.select1352>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end547>, scalar.ph

ir-bb<for.end547>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1352.lcssa = vp<%6>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body538.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%c532.01434> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01433> = phi ir<0>, ir<%spec.select1352>
    vp<%4> = vector-pointer ir<%c532.01434>
    WIDEN ir<%106> = load vp<%4>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc543> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1352> = add ir<%hicount.01433>, ir<%inc543>
    CLONE ir<%incdec.ptr546> = getelementptr inbounds ir<%c532.01434>, ir<1>
    CLONE ir<%exitcond1492.not> = icmp eq ir<%incdec.ptr546>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hicount.01433>, ir<%spec.select1352>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end547>, scalar.ph

ir-bb<for.end547>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1352.lcssa = vp<%7>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body538.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%c532.01434> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01433> = phi ir<0>, ir<%spec.select1352>
    vp<%4> = vector-pointer ir<%c532.01434>
    WIDEN ir<%106> = load vp<%4>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc543> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1352> = add ir<%hicount.01433>, ir<%inc543>
    CLONE ir<%incdec.ptr546> = getelementptr inbounds ir<%c532.01434>, ir<1>
    CLONE ir<%exitcond1492.not> = icmp eq ir<%incdec.ptr546>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hicount.01433>, ir<%spec.select1352>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end547>, scalar.ph

ir-bb<for.end547>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1352.lcssa = vp<%7>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 8
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 3 for VF 8 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 6 for VF 16 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 13
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 104, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c532.01434 = phi ptr [ %incdec.ptr546, %for.body538 ], [ %104, %for.body538.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %hicount.01433 = phi i32 [ %spec.select1352, %for.body538 ], [ 0, %for.body538.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %106 = load i8, ptr %c532.01434, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc543 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select1352 = add nuw nsw i32 %hicount.01433, %inc543 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr546 = getelementptr inbounds i8, ptr %c532.01434, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1492.not = icmp eq ptr %incdec.ptr546, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1492.not, label %for.end547, label %for.body538 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 104
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body538.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hicount.01433> = phi ir<0>, ir<%spec.select1352>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%104>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%106> = load vp<%6>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc543> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1352> = add ir<%hicount.01433>, ir<%inc543>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hicount.01433>, ir<%spec.select1352>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end547>, scalar.ph

ir-bb<for.end547>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1352.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i8 %22 to i64) + (-1 * (zext i8 %21 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%d.11430> = WIDEN-POINTER-INDUCTION ir<%add.ptr63>, 1
    WIDEN-INDUCTION %i.01429 = phi %inc, %conv64, ir<1>
    CLONE ir<%conv76> = trunc ir<%i.01429>
    CLONE ir<%incdec.ptr77> = getelementptr inbounds ir<%d.11430>, ir<1>
    CLONE store ir<%conv76>, ir<%d.11430>
    CLONE ir<%inc> = add nuw nsw ir<%i.01429>, ir<1>
    CLONE ir<%exitcond1489.not> = icmp eq ir<%i.01429>, ir<%conv65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr77.lcssa = ir<%incdec.ptr77>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i8 %22 to i64) + (-1 * (zext i8 %21 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%d.11430> = WIDEN-POINTER-INDUCTION ir<%add.ptr63>, 1
    WIDEN-INDUCTION %i.01429 = phi %inc, %conv64, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.01429 = phi %inc, %conv64\l" +
    "  ir<%conv76>, ir<1>
    CLONE ir<%incdec.ptr77> = getelementptr inbounds ir<%d.11430>, ir<1>
    vp<%4> = vector-pointer ir<%d.11430>
    WIDEN store vp<%4>, ir<%conv76>
    WIDEN ir<%inc> = add nuw nsw ir<%i.01429>, ir<1>
    CLONE ir<%exitcond1489.not> = icmp eq ir<%i.01429>, ir<%conv65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr77.lcssa = ir<%incdec.ptr77>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i8 %22 to i64) + (-1 * (zext i8 %21 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%d.11430> = WIDEN-POINTER-INDUCTION ir<%add.ptr63>, 1
    WIDEN-INDUCTION %i.01429 = phi %inc, %conv64, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.01429 = phi %inc, %conv64\l" +
    "  ir<%conv76>, ir<1>
    CLONE ir<%incdec.ptr77> = getelementptr inbounds ir<%d.11430>, ir<1>
    vp<%4> = vector-pointer ir<%d.11430>
    WIDEN store vp<%4>, ir<%conv76>
    WIDEN ir<%inc> = add nuw nsw ir<%i.01429>, ir<1>
    CLONE ir<%exitcond1489.not> = icmp eq ir<%i.01429>, ir<%conv65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr77.lcssa = ir<%incdec.ptr77>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: vscale x 4, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.11430 = phi ptr [ %incdec.ptr77, %for.body ], [ %add.ptr63, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.01429 = phi i64 [ %inc, %for.body ], [ %conv64, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv76 = trunc nuw i64 %i.01429 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr77 = getelementptr inbounds i8, ptr %d.11430, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %conv76, ptr %d.11430, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %inc = add nuw nsw i64 %i.01429, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond1489.not = icmp eq i64 %i.01429, %conv65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond1489.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i8 %22 to i64) + (-1 * (zext i8 %21 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %i.01429 = phi %inc, %conv64\l" +
    "  ir<%conv76>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%add.ptr63>, vp<%4>
    CLONE ir<%incdec.ptr77> = getelementptr inbounds vp<%5>, ir<1>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%conv76>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr77.lcssa = ir<%incdec.ptr77>
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %16, ptr %e.01427, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call36 to i64)) + (ptrtoint ptr %d.01446 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.01427> = WIDEN-POINTER-INDUCTION ir<%d.01446>, -1
    CLONE ir<%incdec.ptr38> = getelementptr inbounds ir<%e.01427>, ir<-1>
    CLONE ir<%16> = load ir<%incdec.ptr38>
    CLONE store ir<%16>, ir<%e.01427>
    CLONE ir<%cmp39> = icmp ugt ir<%incdec.ptr38>, ir<%call36>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call36 to i64)) + (ptrtoint ptr %d.01446 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.01427> = WIDEN-POINTER-INDUCTION ir<%d.01446>, -1
    CLONE ir<%incdec.ptr38> = getelementptr inbounds ir<%e.01427>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr38>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%e.01427>
    WIDEN store vp<%5>, ir<%16>
    CLONE ir<%cmp39> = icmp ugt ir<%incdec.ptr38>, ir<%call36>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call36 to i64)) + (ptrtoint ptr %d.01446 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.01427> = WIDEN-POINTER-INDUCTION ir<%d.01446>, -1
    CLONE ir<%incdec.ptr38> = getelementptr inbounds ir<%e.01427>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr38>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%e.01427>
    WIDEN store vp<%5>, ir<%16>
    CLONE ir<%cmp39> = icmp ugt ir<%incdec.ptr38>, ir<%call36>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %e.01427 = phi ptr [ %incdec.ptr38, %while.body41 ], [ %d.01446, %while.body41.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr38 = getelementptr inbounds i8, ptr %e.01427, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %16 = load i8, ptr %incdec.ptr38, align 1, !tbaa !22 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %16, ptr %e.01427, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp39 = icmp ugt ptr %incdec.ptr38, %call36 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp39, label %while.body41, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 112
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: S_scan_const at line: toke.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call36 to i64)) + (ptrtoint ptr %d.01446 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%d.01446>, vp<%5>
    CLONE ir<%incdec.ptr38> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%7> = vector-pointer (reverse) ir<%incdec.ptr38>
    WIDEN ir<%16> = load vp<%7>
    vp<%8> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%8>, ir<%16>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    EMIT vp<%5> = ptradd ir<%d.01446>, vp<%4>
    CLONE ir<%incdec.ptr38> = getelementptr inbounds vp<%5>, ir<-1>
    vp<%6> = vector-pointer (reverse) ir<%incdec.ptr38>
    WIDEN ir<%58> = load vp<%6>
    vp<%7> = vector-pointer (reverse) vp<%5>
    WIDEN store vp<%7>, ir<%58>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%16>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %120 = load i8, ptr %s.21416, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %120, ptr %d.41415, align 1, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body199.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp191.not to i64) + (-1 * (ptrtoint ptr %s.01447 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.21416> = WIDEN-POINTER-INDUCTION ir<%s.01447>, 1
    EMIT ir<%d.41415> = WIDEN-POINTER-INDUCTION ir<%d.01446>, 1
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%s.21416>, ir<1>
    CLONE ir<%120> = load ir<%s.21416>
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%d.41415>, ir<1>
    CLONE store ir<%120>, ir<%d.41415>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr200>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end328thread-pre-split.loopexit1543>, scalar.ph

ir-bb<if.end328thread-pre-split.loopexit1543>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
Live-out ptr %incdec.ptr201.lcssa = ir<%incdec.ptr201>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body199.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp191.not to i64) + (-1 * (ptrtoint ptr %s.01447 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21416> = WIDEN-POINTER-INDUCTION ir<%s.01447>, 1
    EMIT ir<%d.41415> = WIDEN-POINTER-INDUCTION ir<%d.01446>, 1
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%s.21416>, ir<1>
    vp<%4> = vector-pointer ir<%s.21416>
    WIDEN ir<%120> = load vp<%4>
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%d.41415>, ir<1>
    vp<%5> = vector-pointer ir<%d.41415>
    WIDEN store vp<%5>, ir<%120>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr200>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end328thread-pre-split.loopexit1543>, scalar.ph

ir-bb<if.end328thread-pre-split.loopexit1543>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
Live-out ptr %incdec.ptr201.lcssa = ir<%incdec.ptr201>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body199.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp191.not to i64) + (-1 * (ptrtoint ptr %s.01447 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21416> = WIDEN-POINTER-INDUCTION ir<%s.01447>, 1
    EMIT ir<%d.41415> = WIDEN-POINTER-INDUCTION ir<%d.01446>, 1
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%s.21416>, ir<1>
    vp<%4> = vector-pointer ir<%s.21416>
    WIDEN ir<%120> = load vp<%4>
    CLONE ir<%incdec.ptr201> = getelementptr inbounds ir<%d.41415>, ir<1>
    vp<%5> = vector-pointer ir<%d.41415>
    WIDEN store vp<%5>, ir<%120>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr200>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end328thread-pre-split.loopexit1543>, scalar.ph

ir-bb<if.end328thread-pre-split.loopexit1543>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
Live-out ptr %incdec.ptr201.lcssa = ir<%incdec.ptr201>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.21416 = phi ptr [ %incdec.ptr200, %while.body199 ], [ %s.01447, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.41415 = phi ptr [ %incdec.ptr201, %while.body199 ], [ %d.01446, %while.body199.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %s.21416, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %120 = load i8, ptr %s.21416, align 1, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr201 = getelementptr inbounds i8, ptr %d.41415, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %120, ptr %d.41415, align 1, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr200, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end328thread-pre-split.loopexit1543, label %while.body199 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body199.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp191.not to i64) + (-1 * (ptrtoint ptr %s.01447 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.01447>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%d.01446>, vp<%6>
    CLONE ir<%incdec.ptr200> = getelementptr inbounds vp<%5>, ir<1>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%124> = load vp<%8>
    CLONE ir<%incdec.ptr201> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%124>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end328thread-pre-split.loopexit1543>, scalar.ph

ir-bb<if.end328thread-pre-split.loopexit1543>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
Live-out ptr %incdec.ptr201.lcssa = ir<%incdec.ptr201>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 65
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o universal.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        universal.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o utf8.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        utf8.c
========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    CLONE ir<%0> = load ir<%s.014>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    CLONE ir<%1> = load ir<%arrayidx1>
    CLONE store ir<%1>, ir<%s.014>
    CLONE store ir<%0>, ir<%arrayidx1>
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    INTERLEAVE-GROUP with factor 2 at %0, ir<%s.014>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    REPLICATE ir<%0> = load ir<%s.014>
    WIDEN-GEP Var[Inv] ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    REPLICATE ir<%1> = load ir<%arrayidx1>
    REPLICATE store ir<%1>, ir<%s.014>
    REPLICATE store ir<%0>, ir<%arrayidx1>
    WIDEN-GEP Var[Inv] ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    WIDEN ir<%0> = load ir<%s.014>
    WIDEN-GEP Var[Inv] ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    WIDEN ir<%1> = load ir<%arrayidx1>
    WIDEN store ir<%s.014>, ir<%1>
    WIDEN store ir<%arrayidx1>, ir<%0>
    WIDEN-GEP Var[Inv] ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 16 to 32==========
VPlan 'Initial VPlan for VF={vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    INTERLEAVE-GROUP with factor 2 at %0, ir<%s.014>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 18 for VF 2 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 18 for VF 2 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 37
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 37, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 37
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 37, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 33 for VF 4 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 33 for VF 4 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 16
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 67
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 67, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 67
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 67, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 8 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 16 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 16 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 16 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 16 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 41
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 165
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 2640, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 162 for VF vscale x 4 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 162 for VF vscale x 4 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 40
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 325
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 325, CostB * EstimatedWidthA: 72
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 325
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 5200, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 322 for VF vscale x 8 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 322 for VF vscale x 8 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 40
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 645
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 645, CostB * EstimatedWidthA: 144
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 645
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 10320, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %0 = load i8, ptr %s.014, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %1 = load i8, ptr %arrayidx1, align 1, !tbaa !6 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   store i8 %1, ptr %s.014, align 1, !tbaa !6 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %0, ptr %arrayidx1, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = 16 at function: Perl_utf16_to_utf8_reversed at line: utf8.c
LEV: EpilogueVF.Width: 16
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_utf16_to_utf8_reversed at line: utf8.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((ptrtoint ptr %p to i64) + %bytelen))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<2>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<2>
    EMIT vp<%6> = ptradd ir<%p>, vp<%5>
    INTERLEAVE-GROUP with factor 2 at %0, vp<%6>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds vp<%6>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=16, UF=1 at function: Perl_utf16_to_utf8_reversed at line: utf8.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%5> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<2>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<2>
    EMIT vp<%5> = ptradd ir<%p>, vp<%4>
    INTERLEAVE-GROUP with factor 2 at %29, vp<%5>
      ir<%29> = load from index 0
      ir<%30> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds vp<%5>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%30> to index 0
      store ir<%29> to index 1
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%5>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o util.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        util.c
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    CLONE ir<%0> = load ir<%from.addr.121.us>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    CLONE store ir<%0>, ir<%to.addr.222.us>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%len>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}

========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    vp<%3> = vector-pointer ir<%from.addr.121.us>
    WIDEN ir<%0> = load vp<%3>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    vp<%4> = vector-pointer ir<%to.addr.222.us>
    WIDEN store vp<%4>, ir<%0>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%len>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}

========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    vp<%3> = vector-pointer ir<%from.addr.121.us>
    WIDEN ir<%0> = load vp<%3>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    vp<%4> = vector-pointer ir<%to.addr.222.us>
    WIDEN store vp<%4>, ir<%0>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%len>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}


-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %todo.020.us = phi i64 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec9.us = add nsw i64 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp6.us = icmp sgt i64 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: Perl_repeatcpy at line: util.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%len> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%to.addr.125.us>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%from>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%5> = load vp<%7>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds vp<%4>, ir<1>
    vp<%8> = vector-pointer vp<%4>
    WIDEN store vp<%8>, ir<%5>
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<%len>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xsutils.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        xsutils.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Base64.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Base64.c
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load i8, ptr %c.0186, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %25, ptr %r.1185, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %24)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c.0186> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1185> = WIDEN-POINTER-INDUCTION ir<%r.0189>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%c.0186>, ir<1>
    CLONE ir<%25> = load ir<%c.0186>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1185>, ir<1>
    CLONE store ir<%25>, ir<%r.1185>
    CLONE ir<%cmp59> = icmp ult ir<%incdec.ptr60>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %24)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c.0186> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1185> = WIDEN-POINTER-INDUCTION ir<%r.0189>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%c.0186>, ir<1>
    vp<%4> = vector-pointer ir<%c.0186>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1185>, ir<1>
    vp<%5> = vector-pointer ir<%r.1185>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp59> = icmp ult ir<%incdec.ptr60>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %24)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c.0186> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1185> = WIDEN-POINTER-INDUCTION ir<%r.0189>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%c.0186>, ir<1>
    vp<%4> = vector-pointer ir<%c.0186>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1185>, ir<1>
    vp<%5> = vector-pointer ir<%r.1185>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp59> = icmp ult ir<%incdec.ptr60>, ir<%add.ptr58>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}


-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %c.0186 = phi ptr [ %incdec.ptr60, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.1185 = phi ptr [ %incdec.ptr61, %while.body ], [ %r.0189, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %c.0186, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %25 = load i8, ptr %c.0186, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1185, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %25, ptr %r.1185, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp59 = icmp ult ptr %incdec.ptr60, %add.ptr58 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp59, label %while.body, label %if.end62.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: XS_MIME__Base64_encode_base64 at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %25)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%eol.0>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%r.0189>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%30> = load vp<%8>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%30>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}
================ Final VPlan ================

@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %73, ptr %r.4194, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body127.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %72)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c121.0195> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4194> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr128> = getelementptr inbounds ir<%c121.0195>, ir<1>
    CLONE ir<%73> = load ir<%c121.0195>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%r.4194>, ir<1>
    CLONE store ir<%73>, ir<%r.4194>
    CLONE ir<%cmp125> = icmp ult ir<%incdec.ptr128>, ir<%add.ptr123>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr129.lcssa = ir<%incdec.ptr129>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body127.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %72)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c121.0195> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4194> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr128> = getelementptr inbounds ir<%c121.0195>, ir<1>
    vp<%4> = vector-pointer ir<%c121.0195>
    WIDEN ir<%73> = load vp<%4>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%r.4194>, ir<1>
    vp<%5> = vector-pointer ir<%r.4194>
    WIDEN store vp<%5>, ir<%73>
    CLONE ir<%cmp125> = icmp ult ir<%incdec.ptr128>, ir<%add.ptr123>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr129.lcssa = ir<%incdec.ptr129>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body127.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %72)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c121.0195> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4194> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr128> = getelementptr inbounds ir<%c121.0195>, ir<1>
    vp<%4> = vector-pointer ir<%c121.0195>
    WIDEN ir<%73> = load vp<%4>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%r.4194>, ir<1>
    vp<%5> = vector-pointer ir<%r.4194>
    WIDEN store vp<%5>, ir<%73>
    CLONE ir<%cmp125> = icmp ult ir<%incdec.ptr128>, ir<%add.ptr123>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr129.lcssa = ir<%incdec.ptr129>
}


-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %c121.0195 = phi ptr [ %incdec.ptr128, %while.body127 ], [ %eol.0, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.4194 = phi ptr [ %incdec.ptr129, %while.body127 ], [ %r.0.lcssa, %while.body127.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr128 = getelementptr inbounds i8, ptr %c121.0195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %73 = load i8, ptr %c121.0195, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %r.4194, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %73, ptr %r.4194, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp125 = icmp ult ptr %incdec.ptr128, %add.ptr123 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp125, label %while.body127, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: XS_MIME__Base64_encode_base64 at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body127.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %72)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%eol.0>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%r.0.lcssa>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%77> = load vp<%8>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%77>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr129.lcssa = ir<%incdec.ptr129>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %18, ptr %r.1296, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body54.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0302 to i64)) + (ptrtoint ptr %str.0304 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.1296> = WIDEN-POINTER-INDUCTION ir<%r.0303>, 1
    EMIT ir<%whitespace.2295> = WIDEN-POINTER-INDUCTION ir<%whitespace.0302>, 1
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%whitespace.2295>, ir<1>
    CLONE ir<%18> = load ir<%whitespace.2295>
    CLONE ir<%incdec.ptr56> = getelementptr inbounds ir<%r.1296>, ir<1>
    CLONE store ir<%18>, ir<%r.1296>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr55>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr56.lcssa = ir<%incdec.ptr56>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body54.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0302 to i64)) + (ptrtoint ptr %str.0304 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.1296> = WIDEN-POINTER-INDUCTION ir<%r.0303>, 1
    EMIT ir<%whitespace.2295> = WIDEN-POINTER-INDUCTION ir<%whitespace.0302>, 1
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%whitespace.2295>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.2295>
    WIDEN ir<%18> = load vp<%4>
    CLONE ir<%incdec.ptr56> = getelementptr inbounds ir<%r.1296>, ir<1>
    vp<%5> = vector-pointer ir<%r.1296>
    WIDEN store vp<%5>, ir<%18>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr55>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr56.lcssa = ir<%incdec.ptr56>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body54.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0302 to i64)) + (ptrtoint ptr %str.0304 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.1296> = WIDEN-POINTER-INDUCTION ir<%r.0303>, 1
    EMIT ir<%whitespace.2295> = WIDEN-POINTER-INDUCTION ir<%whitespace.0302>, 1
    CLONE ir<%incdec.ptr55> = getelementptr inbounds ir<%whitespace.2295>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.2295>
    WIDEN ir<%18> = load vp<%4>
    CLONE ir<%incdec.ptr56> = getelementptr inbounds ir<%r.1296>, ir<1>
    vp<%5> = vector-pointer ir<%r.1296>
    WIDEN store vp<%5>, ir<%18>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr55>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr56.lcssa = ir<%incdec.ptr56>
}


-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.1296 = phi ptr [ %incdec.ptr56, %while.body54 ], [ %r.0303, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %whitespace.2295 = phi ptr [ %incdec.ptr55, %while.body54 ], [ %whitespace.0302, %while.body54.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr55 = getelementptr inbounds i8, ptr %whitespace.2295, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %18 = load i8, ptr %whitespace.2295, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr56 = getelementptr inbounds i8, ptr %r.1296, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %18, ptr %r.1296, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr55, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end57.loopexit, label %while.body54 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: XS_MIME__QuotedPrint_decode_qp at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body54.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0302 to i64)) + (ptrtoint ptr %str.0304 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%r.0303>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%whitespace.0302>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%22> = load vp<%8>
    CLONE ir<%incdec.ptr56> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%22>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr56.lcssa = ir<%incdec.ptr56>
}
================ Final VPlan ================

@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %62, ptr %r.5310, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body191.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.5310> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5309> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr192> = getelementptr inbounds ir<%whitespace.5309>, ir<1>
    CLONE ir<%62> = load ir<%whitespace.5309>
    CLONE ir<%incdec.ptr193> = getelementptr inbounds ir<%r.5310>, ir<1>
    CLONE store ir<%62>, ir<%r.5310>
    CLONE ir<%exitcond326.not> = icmp eq ir<%incdec.ptr192>, ir<%scevgep325>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end195.loopexit>, scalar.ph

ir-bb<if.end195.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr193.lcssa = ir<%incdec.ptr193>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body191.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.5310> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5309> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr192> = getelementptr inbounds ir<%whitespace.5309>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.5309>
    WIDEN ir<%62> = load vp<%4>
    CLONE ir<%incdec.ptr193> = getelementptr inbounds ir<%r.5310>, ir<1>
    vp<%5> = vector-pointer ir<%r.5310>
    WIDEN store vp<%5>, ir<%62>
    CLONE ir<%exitcond326.not> = icmp eq ir<%incdec.ptr192>, ir<%scevgep325>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end195.loopexit>, scalar.ph

ir-bb<if.end195.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr193.lcssa = ir<%incdec.ptr193>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body191.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.5310> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5309> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr192> = getelementptr inbounds ir<%whitespace.5309>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.5309>
    WIDEN ir<%62> = load vp<%4>
    CLONE ir<%incdec.ptr193> = getelementptr inbounds ir<%r.5310>, ir<1>
    vp<%5> = vector-pointer ir<%r.5310>
    WIDEN store vp<%5>, ir<%62>
    CLONE ir<%exitcond326.not> = icmp eq ir<%incdec.ptr192>, ir<%scevgep325>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end195.loopexit>, scalar.ph

ir-bb<if.end195.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr193.lcssa = ir<%incdec.ptr193>
}


-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.5310 = phi ptr [ %incdec.ptr193, %while.body191 ], [ %r.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %whitespace.5309 = phi ptr [ %incdec.ptr192, %while.body191 ], [ %whitespace.4.lcssa, %while.body191.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr192 = getelementptr inbounds i8, ptr %whitespace.5309, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %62 = load i8, ptr %whitespace.5309, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr193 = getelementptr inbounds i8, ptr %r.5310, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %62, ptr %r.5310, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond326.not = icmp eq ptr %incdec.ptr192, %scevgep325 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond326.not, label %if.end195.loopexit, label %while.body191 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: XS_MIME__QuotedPrint_decode_qp at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body191.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%r.4.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%whitespace.4.lcssa>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%66> = load vp<%8>
    CLONE ir<%incdec.ptr193> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%66>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end195.loopexit>, scalar.ph

ir-bb<if.end195.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr193.lcssa = ir<%incdec.ptr193>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Cwd.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Cwd.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Dumper.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Dumper.c
MVT: v2i32
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin %n))<nuw><nsw> + %n)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %n.addr.060 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.060>, ir<-1>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%add.ptr>, ir<%dec>
    CLONE store ir<%.pre>, ir<%arrayidx24>
    CLONE ir<%cmp22> = icmp ugt ir<%n.addr.060>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end32.loopexit>, scalar.ph

ir-bb<if.end32.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin %n))<nuw><nsw> + %n)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %n.addr.060 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.060>, ir<-1>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%add.ptr>, ir<%dec>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx24>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%cmp22> = icmp ugt ir<%n.addr.060>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end32.loopexit>, scalar.ph

ir-bb<if.end32.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin %n))<nuw><nsw> + %n)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %n.addr.060 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.060>, ir<-1>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%add.ptr>, ir<%dec>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx24>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%cmp22> = icmp ugt ir<%n.addr.060>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end32.loopexit>, scalar.ph

ir-bb<if.end32.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %n.addr.060 = phi i64 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i64 %n.addr.060, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx24 = getelementptr inbounds i8, ptr %add.ptr, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %.pre, ptr %arrayidx24, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp22 = icmp ugt i64 %n.addr.060, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp22, label %while.body, label %if.end32.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: sv_x at line: Dumper.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: sv_x at line: Dumper.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (-1 * (1 umin %n))<nuw><nsw> + %n)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%n> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%dec> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%add.ptr>, ir<%dec>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx24>
    WIDEN store vp<%6>, ir<%.pre>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end32.loopexit>, scalar.ph

ir-bb<if.end32.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: sv_x at line: Dumper.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%n> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec> = add nsw vp<%4>, ir<-1>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%add.ptr>, ir<%dec>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx24>
    WIDEN store vp<%5>, ir<%.pre>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end32.loopexit>, scalar.ph

ir-bb<if.end32.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o HiRes.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        HiRes.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o IO.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        IO.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Peek.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Peek.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o attrs.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        attrs.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o poll.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        poll.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stdio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        stdio.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o DynaLoader.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        DynaLoader.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MD5.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        MD5.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Storable.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Storable.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Parser.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Parser.c
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre471498 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    CLONE ir<%60> = load ir<%ent_start.0451>
    CLONE ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    CLONE store ir<%incdec.ptr282>, ir<%t>
    CLONE store ir<%60>, ir<%incdec.ptr282448450>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre471498>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}

========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre471498 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    vp<%4> = vector-pointer ir<%ent_start.0451>
    WIDEN ir<%60> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%5> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%5>, ir<%60>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre471498>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}

========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre471498 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    vp<%4> = vector-pointer ir<%ent_start.0451>
    WIDEN ir<%60> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%5> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%5>, ir<%60>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre471498>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}


-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 8 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 16 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %60 = load i8, ptr %ent_start.0451, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8, !tbaa !17 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %60, ptr %incdec.ptr282448450, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre471498 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28
LV: Selecting VF: 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=16, UF=1 at function: decode_entities at line: Parser.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre471498 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%incdec.ptr.ptr.lcssa>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%64> = load vp<%6>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%7> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%7>, ir<%64>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o specrand.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        specrand.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Hostname.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Hostname.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Opcode.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions        -DSPEC_CPU_LINUX        Opcode.c
MVT: v2i32
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%6> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %len.034 = phi %dec, %6, ir<-1>
    CLONE ir<%dec> = add ir<%len.034>, ir<-1>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%8>, ir<%dec>
    CLONE ir<%9> = load ir<%arrayidx8>
    CLONE ir<%not> = xor ir<%9>, ir<-1>
    CLONE store ir<%not>, ir<%arrayidx8>
    CLONE ir<%cmp7.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%6>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%6> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %len.034 = phi %dec, %6, ir<-1>
    CLONE ir<%dec> = add ir<%len.034>, ir<-1>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%8>, ir<%dec>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN ir<%9> = load vp<%3>
    WIDEN ir<%not> = xor ir<%9>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN store vp<%4>, ir<%not>
    CLONE ir<%cmp7.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%6>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%6> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %len.034 = phi %dec, %6, ir<-1>
    CLONE ir<%dec> = add ir<%len.034>, ir<-1>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%8>, ir<%dec>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN ir<%9> = load vp<%3>
    WIDEN ir<%not> = xor ir<%9>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN store vp<%4>, ir<%not>
    CLONE ir<%cmp7.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%6>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 72

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.034 = phi i64 [ %dec, %while.body ], [ %6, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %len.034, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %9 = load i8, ptr %arrayidx8, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %not = xor i8 %9, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %not, ptr %arrayidx8, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp7.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp7.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 112
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 72
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 144
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: XS_Opcode_invert_opset at line: Opcode.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: XS_Opcode_invert_opset at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%6> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%6> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%8>, ir<%dec>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN ir<%9> = load vp<%5>
    WIDEN ir<%not> = xor ir<%9>, ir<-1>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN store vp<%6>, ir<%not>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%6>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: XS_Opcode_invert_opset at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%6> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%6> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%8>, ir<%dec>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN ir<%54> = load vp<%5>
    WIDEN ir<%not> = xor ir<%54>, ir<-1>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx8>
    WIDEN store vp<%6>, ir<%not>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%6>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 1
================================================
MVT: v2i32
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %dec117.in = phi %dec117, %8, ir<-1>
    CLONE ir<%dec117> = add ir<%dec117.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec117>
    CLONE ir<%11> = load ir<%arrayidx56>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec117>
    CLONE ir<%12> = load ir<%arrayidx58>
    CLONE ir<%or60112> = or ir<%12>, ir<%11>
    CLONE store ir<%or60112>, ir<%arrayidx58>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec117>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end82.loopexit123>, scalar.ph

ir-bb<if.end82.loopexit123>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec117.in = phi %dec117, %8, ir<-1>
    CLONE ir<%dec117> = add ir<%dec117.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec117>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%3>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec117>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%or60112> = or ir<%12>, ir<%11>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%5>, ir<%or60112>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec117>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end82.loopexit123>, scalar.ph

ir-bb<if.end82.loopexit123>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec117.in = phi %dec117, %8, ir<-1>
    CLONE ir<%dec117> = add ir<%dec117.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec117>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%3>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec117>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%or60112> = or ir<%12>, ir<%11>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%5>, ir<%or60112>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec117>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end82.loopexit123>, scalar.ph

ir-bb<if.end82.loopexit123>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 12
B VF: 8, EstimatedWidthB: 8, CostB: 9
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 96

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dec117.in = phi i64 [ %dec117, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec117 = add i64 %dec117.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %11 = load i8, ptr %arrayidx56, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec117 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %12 = load i8, ptr %arrayidx58, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or60112 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %or60112, ptr %arrayidx58, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp54.not = icmp eq i64 %dec117, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp54.not, label %if.end82.loopexit123, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 9
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 288
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 96
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 12
B VF: 8, EstimatedWidthB: 8, CostB: 9
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 144
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 12
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 192
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: set_opset_bits at line: Opcode.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec117> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec117>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%5>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec117>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%6>
    WIDEN ir<%or60112> = or ir<%12>, ir<%11>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%7>, ir<%or60112>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end82.loopexit123>, scalar.ph

ir-bb<if.end82.loopexit123>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec117> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec117>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%70> = load vp<%5>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec117>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%71> = load vp<%6>
    WIDEN ir<%or60112> = or ir<%71>, ir<%70>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%7>, ir<%or60112>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end82.loopexit123>, scalar.ph

ir-bb<if.end82.loopexit123>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %dec64120.in = phi %dec64120, %8, ir<-1>
    CLONE ir<%dec64120> = add ir<%dec64120.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64120>
    CLONE ir<%102> = load ir<%arrayidx68>
    CLONE ir<%not70> = xor ir<%102>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64120>
    CLONE ir<%103> = load ir<%arrayidx71>
    CLONE ir<%and73> = and ir<%103>, ir<%not70>
    CLONE store ir<%and73>, ir<%arrayidx71>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64120>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end82.loopexit>, scalar.ph

ir-bb<if.end82.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec64120.in = phi %dec64120, %8, ir<-1>
    CLONE ir<%dec64120> = add ir<%dec64120.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64120>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%102> = load vp<%3>
    WIDEN ir<%not70> = xor ir<%102>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64120>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%103> = load vp<%4>
    WIDEN ir<%and73> = and ir<%103>, ir<%not70>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%5>, ir<%and73>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64120>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end82.loopexit>, scalar.ph

ir-bb<if.end82.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec64120.in = phi %dec64120, %8, ir<-1>
    CLONE ir<%dec64120> = add ir<%dec64120.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64120>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%102> = load vp<%3>
    WIDEN ir<%not70> = xor ir<%102>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64120>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%103> = load vp<%4>
    WIDEN ir<%and73> = and ir<%103>, ir<%not70>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%5>, ir<%and73>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64120>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end82.loopexit>, scalar.ph

ir-bb<if.end82.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 2, EstimatedWidthB: 2, CostB: 19
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 76
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 104
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 13
B VF: 8, EstimatedWidthB: 8, CostB: 10
CostA * EstimatedWidthB: 104, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 104

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 208
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dec64120.in = phi i64 [ %dec64120, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec64120 = add i64 %dec64120.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %102 = load i8, ptr %arrayidx68, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %not70 = xor i8 %102, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64120 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %103 = load i8, ptr %arrayidx71, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %and73 = and i8 %103, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %and73, ptr %arrayidx71, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp65.not = icmp eq i64 %dec64120, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp65.not, label %if.end82.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 320
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 2, EstimatedWidthB: 2, CostB: 19
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 76
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 104
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 13
B VF: 8, EstimatedWidthB: 8, CostB: 10
CostA * EstimatedWidthB: 104, CostB * EstimatedWidthA: 160
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 52
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 104
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 13
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 208
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: set_opset_bits at line: Opcode.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec64120> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64120>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%102> = load vp<%5>
    WIDEN ir<%not70> = xor ir<%102>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64120>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%103> = load vp<%6>
    WIDEN ir<%and73> = and ir<%103>, ir<%not70>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%7>, ir<%and73>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end82.loopexit>, scalar.ph

ir-bb<if.end82.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec64120> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64120>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%163> = load vp<%5>
    WIDEN ir<%not70> = xor ir<%163>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64120>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%164> = load vp<%6>
    WIDEN ir<%and73> = and ir<%164>, ir<%not70>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%7>, ir<%and73>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end82.loopexit>, scalar.ph

ir-bb<if.end82.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 5
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions   -DSPEC_CPU_LINUX       av.o deb.o doio.o doop.o dump.o globals.o gv.o hv.o locale.o mg.o numeric.o op.o pad.o perl.o perlapi.o perlio.o perlmain.o perly.o pp.o pp_ctl.o pp_hot.o pp_pack.o pp_sort.o pp_sys.o regcomp.o regexec.o run.o scope.o sv.o taint.o toke.o universal.o utf8.o util.o xsutils.o Base64.o Cwd.o Dumper.o HiRes.o IO.o Peek.o attrs.o poll.o stdio.o DynaLoader.o MD5.o Storable.o Parser.o specrand.o Hostname.o Opcode.o             -lm        -o perlbench
