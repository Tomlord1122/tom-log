/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o alloca.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                alloca.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o asprintf.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                asprintf.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vasprintf.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                vasprintf.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-parse.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-parse.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-lang.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-lang.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o attribs.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                attribs.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-errors.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-errors.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-lex.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-lex.c
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader168>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader168>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader168>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 178, RTCostB: 236
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 178, RTCostB: 236
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 68, RTCostB: 236
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 68, RTCostB: 178
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 33, RTCostB: 236
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 33, RTCostB: 68
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 53, RTCostB: 236
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 53, RTCostB: 33

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 236
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 33

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 54, RTCostB: 236
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 54, RTCostB: 33

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 33, RTCostB: 236
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 33, RTCostB: 33
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 53, RTCostB: 236
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 53, RTCostB: 33

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader168 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 0, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !13 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 111, RTCostB: 236
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 111, RTCostB: 33
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: lex_string at line: c-lex.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader168>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<4> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<0>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-pragma.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-pragma.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-decl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-decl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-typeck.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-typeck.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-convert.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-convert.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-aux-info.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-aux-info.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-common.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-common.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-format.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-format.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-semantics.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-semantics.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o c-objc-common.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                c-objc-common.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o main.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                main.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cpplib.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cpplib.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cpplex.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cpplex.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cppmacro.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cppmacro.c
MVT: v2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 4 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 8 -> VectorType: <8 x ptr> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(4) = LT.first(4) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 4 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 8 -> VectorType: <8 x ptr> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(4) = LT.first(4) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _cpp_create_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %41, %42, ir<-1>
    CLONE ir<%42> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx234> = getelementptr inbounds ir<%40>, ir<%42>
    CLONE ir<%43> = load ir<%arrayidx234>
    CLONE ir<%arg_index> = getelementptr inbounds ir<%43>, ir<16>
    CLONE store ir<0>, ir<%arg_index>
    CLONE ir<%cmp230.not.wide> = icmp eq ir<%42>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _cpp_create_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %41, %42, ir<-1>
    CLONE ir<%42> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx234> = getelementptr inbounds ir<%40>, ir<%42>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx234>
    WIDEN ir<%43> = load vp<%4>
    REPLICATE ir<%arg_index> = getelementptr inbounds ir<%43>, ir<16>
    REPLICATE store ir<0>, ir<%arg_index>
    CLONE ir<%cmp230.not.wide> = icmp eq ir<%42>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _cpp_create_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %41, %42, ir<-1>
    CLONE ir<%42> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx234> = getelementptr inbounds ir<%40>, ir<%42>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx234>
    WIDEN ir<%43> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%arg_index> = getelementptr inbounds ir<%43>, ir<16>
    REPLICATE store ir<0>, ir<%arg_index>
    CLONE ir<%cmp230.not.wide> = icmp eq ir<%42>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _cpp_create_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %41, %42, ir<-1>
    CLONE ir<%42> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx234> = getelementptr inbounds ir<%40>, ir<%42>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx234>
    WIDEN ir<%43> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%arg_index> = getelementptr inbounds ir<%43>, ir<16>
    WIDEN store ir<%arg_index>, ir<0>
    CLONE ir<%cmp230.not.wide> = icmp eq ir<%42>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 983016, RTCostB: 393210
A is not scalable.	B is not scalable.	
RTCostA: 983016, RTCostB: 393210

-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 950232, RTCostB: 393210
A is not scalable.	B is not scalable.	
RTCostA: 950232, RTCostB: 393210

-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 8 for VF 8 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 933816, RTCostB: 393210
A is not scalable.	B is not scalable.	
RTCostA: 933816, RTCostB: 393210

-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 393210
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 393210

-----------------Function that is being costed:'_cpp_create_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %41, %for.body.lr.ph ], [ %42, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %42 = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx234 = getelementptr inbounds ptr, ptr %40, i64 %42 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %43 = load ptr, ptr %arrayidx234, align 8, !tbaa !48 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arg_index = getelementptr inbounds i8, ptr %43, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i16 0, ptr %arg_index, align 8, !tbaa !49 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp230.not.wide = icmp eq i64 %42, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp230.not.wide, label %for.end235.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 737253, RTCostB: 393210
A is scalable.	B is not scalable.	
RTCostA: 737253, RTCostB: 393210
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _cpp_create_definition at line: cppmacro.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%41> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%42> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx234> = getelementptr inbounds ir<%40>, ir<%42>
    CLONE ir<%43> = load ir<%arrayidx234>
    CLONE ir<%arg_index> = getelementptr inbounds ir<%43>, ir<16>
    CLONE store ir<0>, ir<%arg_index>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE ir<%6> = load ir<%arrayidx>
    CLONE ir<%7> = load ir<%6>
    CLONE ir<%add15> = add ir<%len.0276>, ir<1>
    CLONE ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%6>
}

========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%4>
    REPLICATE ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}

========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%4>
    REPLICATE ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}

========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%4>
    WIDEN ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}


-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i32, ptr %6, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %7 = load i32, ptr %6, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 1146853, RTCostB: 524280
A is not scalable.	B is not scalable.	
RTCostA: 1146853, RTCostB: 524280

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %7 = load i32, ptr %6, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 1081302, RTCostB: 524280
A is not scalable.	B is not scalable.	
RTCostA: 1081302, RTCostB: 524280

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i32, ptr %6, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 524280
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 524280

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load ptr, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load i32, ptr %6, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 753642, RTCostB: 524280
A is scalable.	B is not scalable.	
RTCostA: 753642, RTCostB: 524280
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: cpp_macro_definition at line: cppmacro.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, vp<%4>
    CLONE ir<%6> = load ir<%arrayidx>
    CLONE ir<%7> = load ir<%6>
    CLONE ir<%add15> = add ir<%len.0276>, ir<1>
    CLONE ir<%add16> = add ir<%add15>, ir<%7>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 14
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cppexp.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cppexp.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cppfiles.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cppfiles.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cpphash.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cpphash.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cpperror.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cpperror.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cppinit.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cppinit.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cppdefault.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cppdefault.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o line-map.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                line-map.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mkdeps.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                mkdeps.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o prefix.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                prefix.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o version.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                version.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mbchar.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                mbchar.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o alias.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                alias.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bb-reorder.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                bb-reorder.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bitmap.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                bitmap.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o builtins.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                builtins.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o caller-save.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                caller-save.c
@@ Instruction =>  %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count382)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv378 = phi 2, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx211> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv385>, ir<%indvars.iv378>
    CLONE ir<%24> = load ir<%arrayidx211>
    CLONE ir<%idxprom212> = zext ir<%24>
    CLONE ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv385>, ir<%idxprom212>
    CLONE ir<%25> = load ir<%arrayidx213>
    CLONE ir<%cmp214> = icmp eq ir<%25>, ir<-1>
  Successor(s): if.then216

  if.then216:
    CLONE store ir<0>, ir<%arrayidx211>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%4> = not ir<%cmp214>
    EMIT vp<%5> = or ir<%cmp214>, vp<%4>
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next379>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count382)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv378 = phi 2, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv385>, ir<%indvars.iv378>
    vp<%4> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%24> = load vp<%4>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%24> to i64
    REPLICATE ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv385>, ir<%idxprom212>
    REPLICATE ir<%25> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%25>, ir<-1>
  Successor(s): if.then216

  if.then216:
    vp<%5> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%5>, ir<0>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%6> = not ir<%cmp214>
    EMIT vp<%7> = or ir<%cmp214>, vp<%6>
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next379>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count382)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv378 = phi 2, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv385>, ir<%indvars.iv378>
    vp<%4> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%24> = load vp<%4>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%24> to i64
    WIDEN-GEP Inv[Inv][Inv][Var] ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv385>, ir<%idxprom212>
    REPLICATE ir<%25> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%25>, ir<-1>
  Successor(s): if.then216

  if.then216:
    vp<%5> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%5>, ir<0>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%6> = not ir<%cmp214>
    EMIT vp<%7> = or ir<%cmp214>, vp<%6>
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next379>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count382)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv378 = phi 2, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv385>, ir<%indvars.iv378>
    vp<%4> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%24> = load vp<%4>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%24> to i64
    WIDEN-GEP Inv[Inv][Inv][Var] ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv385>, ir<%idxprom212>
    WIDEN ir<%25> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%25>, ir<-1>
  Successor(s): if.then216

  if.then216:
    vp<%5> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%5>, ir<0>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%6> = not ir<%cmp214>
    EMIT vp<%7> = or ir<%cmp214>, vp<%6>
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next379>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Vector loop of width 2 costs: 22
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Vector loop of width 4 costs: 21
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 46
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 46, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv378 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next379, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv385, i64 %indvars.iv378 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = load i32, ptr %arrayidx211, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom212 = zext i32 %24 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv385, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %25 = load i32, ptr %arrayidx213, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp214 = icmp eq i32 %25, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx211, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next379, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond383.not, label %for.inc234, label %for.body205, !llvm.loop !15 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 88
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 88
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 64
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95373 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%21> = load ir<%arrayidx102>
    CLONE ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    CLONE ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%6>
}

========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95373 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%7>
}

========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95373 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%7>
}


-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 2 for VF 4 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 4 for VF 8 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 19
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 8 for VF 16 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 35
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 35, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 35
B VF: 8, EstimatedWidthB: 8, CostB: 19
CostA * EstimatedWidthB: 280, CostB * EstimatedWidthA: 304
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 35
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 70

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load i8, ptr %arrayidx102, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 35
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 140
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: setup_save_areas at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95373 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    vp<%4>    = DERIVED-IV ir<%19> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%6>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523.1 = phi %76, %indvars.iv.next524.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507.1> = phi ir<%hard_regs_to_save.promoted.1>, ir<%or.1>
    CLONE ir<%indvars.iv.next524.1> = add nsw ir<%indvars.iv523.1>, ir<-1>
    CLONE ir<%78> = add nsw ir<%indvars.iv.next524.1>, ir<%77>
    CLONE ir<%shl295.1> = shl nuw ir<1>, ir<%78>
    CLONE ir<%or.1> = or ir<%or505507.1>, ir<%shl295.1>
    CLONE ir<%cmp290.1> = icmp ugt ir<%indvars.iv523.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge.1>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523.1 = phi %76, %indvars.iv.next524.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507.1> = phi ir<%hard_regs_to_save.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next524.1> = add nsw ir<%indvars.iv523.1>, ir<-1>
    WIDEN ir<%78> = add nsw ir<%indvars.iv.next524.1>, ir<%77>
    WIDEN ir<%shl295.1> = shl nuw ir<1>, ir<%78>
    WIDEN ir<%or.1> = or ir<%or505507.1>, ir<%shl295.1>
    CLONE ir<%cmp290.1> = icmp ugt ir<%indvars.iv523.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge.1>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523.1 = phi %76, %indvars.iv.next524.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507.1> = phi ir<%hard_regs_to_save.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next524.1> = add nsw ir<%indvars.iv523.1>, ir<-1>
    WIDEN ir<%78> = add nsw ir<%indvars.iv.next524.1>, ir<%77>
    WIDEN ir<%shl295.1> = shl nuw ir<1>, ir<%78>
    WIDEN ir<%or.1> = or ir<%or505507.1>, ir<%shl295.1>
    CLONE ir<%cmp290.1> = icmp ugt ir<%indvars.iv523.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge.1>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}


-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv523.1 = phi i64 [ %76, %while.body292.preheader.1 ], [ %indvars.iv.next524.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or505507.1 = phi i64 [ %hard_regs_to_save.promoted.1, %while.body292.preheader.1 ], [ %or.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next524.1 = add nsw i64 %indvars.iv523.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %78 = add nsw i64 %indvars.iv.next524.1, %77 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl295.1 = shl nuw i64 1, %78 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.1 = or i64 %or505507.1, %shl295.1 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp290.1 = icmp ugt i64 %indvars.iv523.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp290.1, label %while.body292.1, label %while.cond289.while.end296_crit_edge.1 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv523.1 = phi i64 [ %76, %while.body292.preheader.1 ], [ %indvars.iv.next524.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or505507.1 = phi i64 [ %hard_regs_to_save.promoted.1, %while.body292.preheader.1 ], [ %or.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next524.1 = add nsw i64 %indvars.iv523.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %78 = add nsw i64 %indvars.iv.next524.1, %77 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl295.1 = shl nuw i64 1, %78 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.1 = or i64 %or505507.1, %shl295.1 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp290.1 = icmp ugt i64 %indvars.iv523.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp290.1, label %while.body292.1, label %while.cond289.while.end296_crit_edge.1 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv523.1 = phi i64 [ %76, %while.body292.preheader.1 ], [ %indvars.iv.next524.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or505507.1 = phi i64 [ %hard_regs_to_save.promoted.1, %while.body292.preheader.1 ], [ %or.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next524.1 = add nsw i64 %indvars.iv523.1, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %78 = add nsw i64 %indvars.iv.next524.1, %77 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl295.1 = shl nuw i64 1, %78 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.1 = or i64 %or505507.1, %shl295.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp290.1 = icmp ugt i64 %indvars.iv523.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp290.1, label %while.body292.1, label %while.cond289.while.end296_crit_edge.1 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv523.1 = phi i64 [ %76, %while.body292.preheader.1 ], [ %indvars.iv.next524.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or505507.1 = phi i64 [ %hard_regs_to_save.promoted.1, %while.body292.preheader.1 ], [ %or.1, %while.body292.1 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next524.1 = add nsw i64 %indvars.iv523.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %78 = add nsw i64 %indvars.iv.next524.1, %77 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl295.1 = shl nuw i64 1, %78 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.1 = or i64 %or505507.1, %shl295.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp290.1 = icmp ugt i64 %indvars.iv523.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp290.1, label %while.body292.1, label %while.cond289.while.end296_crit_edge.1 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: save_call_clobbered_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader.1>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523.1 = phi %76, %indvars.iv.next524.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507.1> = phi ir<%hard_regs_to_save.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next524.1> = add nsw ir<%indvars.iv523.1>, ir<-1>
    WIDEN ir<%78> = add nsw ir<%indvars.iv.next524.1>, ir<%77>
    WIDEN ir<%shl295.1> = shl nuw ir<1>, ir<%78>
    WIDEN ir<%or.1> = or ir<%or505507.1>, ir<%shl295.1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge.1>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523 = phi %46, %indvars.iv.next524, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next524> = add nsw ir<%indvars.iv523>, ir<-1>
    CLONE ir<%48> = add nsw ir<%indvars.iv.next524>, ir<%47>
    CLONE ir<%shl295> = shl nuw ir<1>, ir<%48>
    CLONE ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv523>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523 = phi %46, %indvars.iv.next524, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next524> = add nsw ir<%indvars.iv523>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next524>, ir<%47>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv523>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523 = phi %46, %indvars.iv.next524, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next524> = add nsw ir<%indvars.iv523>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next524>, ir<%47>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv523>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv523 = phi i64 [ %46, %while.body292.preheader ], [ %indvars.iv.next524, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next524 = add nsw i64 %indvars.iv523, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = add nsw i64 %indvars.iv.next524, %47 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl295 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv523, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv523 = phi i64 [ %46, %while.body292.preheader ], [ %indvars.iv.next524, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next524 = add nsw i64 %indvars.iv523, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = add nsw i64 %indvars.iv.next524, %47 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl295 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv523, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv523 = phi i64 [ %46, %while.body292.preheader ], [ %indvars.iv.next524, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next524 = add nsw i64 %indvars.iv523, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %48 = add nsw i64 %indvars.iv.next524, %47 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl295 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv523, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv523 = phi i64 [ %46, %while.body292.preheader ], [ %indvars.iv.next524, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next524 = add nsw i64 %indvars.iv523, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = add nsw i64 %indvars.iv.next524, %47 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl295 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv523, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: save_call_clobbered_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv523 = phi %46, %indvars.iv.next524, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next524> = add nsw ir<%indvars.iv523>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next524>, ir<%47>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    CLONE ir<%and36> = and ir<%14>, ir<%shl35>
    CLONE ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    CLONE ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    CLONE ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%.sink>, ir<%16>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.body51>, scalar.ph

ir-bb<do.body51>:
No successors

scalar.ph:
No successors
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    REPLICATE ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    REPLICATE ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    REPLICATE ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    WIDEN ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width 2 costs: 1500008
A is not scalable.	B is not scalable.	
RTCostA: 78000423, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 78000423, RTCostB: 371

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 12 for VF 4 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width 4 costs: 750007
A is not scalable.	B is not scalable.	
RTCostA: 39000397, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 39000397, RTCostB: 371

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 631, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: 631, RTCostB: 371

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %15 = load i32, ptr %arrayidx41, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 587, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: 587, RTCostB: 371
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 3
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150321 to i64) + (-1 * (1 umin (zext i32 %cond150321 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi %24, %indvars.iv.next314, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next314> = add nsw ir<%indvars.iv313>, ir<-1>
    CLONE ir<%26> = add nsw ir<%indvars.iv.next314>, ir<%25>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%26>
    CLONE ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv313>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150321 to i64) + (-1 * (1 umin (zext i32 %cond150321 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi %24, %indvars.iv.next314, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next314> = add nsw ir<%indvars.iv313>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next314>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv313>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150321 to i64) + (-1 * (1 umin (zext i32 %cond150321 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi %24, %indvars.iv.next314, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next314> = add nsw ir<%indvars.iv313>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next314>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv313>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv313 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next314, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next314 = add nsw i64 %indvars.iv313, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = add nsw i64 %indvars.iv.next314, %25 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv313, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv313 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next314, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next314 = add nsw i64 %indvars.iv313, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %26 = add nsw i64 %indvars.iv.next314, %25 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv313, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv313 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next314, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next314 = add nsw i64 %indvars.iv313, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %26 = add nsw i64 %indvars.iv.next314, %25 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv313, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv313 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next314, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next314 = add nsw i64 %indvars.iv313, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %26 = add nsw i64 %indvars.iv.next314, %25 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv313, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_referenced_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150321 to i64) + (-1 * (1 umin (zext i32 %cond150321 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi %24, %indvars.iv.next314, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next314> = add nsw ir<%indvars.iv313>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next314>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 20
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    CLONE ir<%sh_prom> = zext nneg ir<%i.0111>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or108110>, ir<%shl>
    CLONE ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_set_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 23
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o calls.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                calls.c
========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1936 = phi %indvars.iv.next1937, 0, ir<1>
    CLONE ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1936>
    CLONE ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    CLONE store ir<null>, ir<%value>
    CLONE ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    CLONE store ir<null>, ir<%aligned_regs1250>
    CLONE ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    CLONE store ir<null>, ir<%stack>
    CLONE ir<%indvars.iv.next1937> = add nuw nsw ir<%indvars.iv1936>, ir<1>
    CLONE ir<%exitcond1940.not> = icmp eq ir<%indvars.iv.next1937>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1936 = phi %indvars.iv.next1937, 0, ir<1>
    REPLICATE ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1936>
    REPLICATE ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    REPLICATE store ir<null>, ir<%value>
    REPLICATE ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    REPLICATE store ir<null>, ir<%aligned_regs1250>
    REPLICATE ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    REPLICATE store ir<null>, ir<%stack>
    REPLICATE ir<%indvars.iv.next1937> = add nuw nsw ir<%indvars.iv1936>, ir<1>
    CLONE ir<%exitcond1940.not> = icmp eq ir<%indvars.iv.next1937>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1936 = phi %indvars.iv.next1937, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1936>
    WIDEN-GEP Var[Inv] ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    REPLICATE store ir<null>, ir<%value>
    WIDEN-GEP Var[Inv] ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    REPLICATE store ir<null>, ir<%aligned_regs1250>
    WIDEN-GEP Var[Inv] ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    REPLICATE store ir<null>, ir<%stack>
    WIDEN ir<%indvars.iv.next1937> = add nuw nsw ir<%indvars.iv1936>, ir<1>
    CLONE ir<%exitcond1940.not> = icmp eq ir<%indvars.iv.next1937>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1936 = phi %indvars.iv.next1937, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1936>
    WIDEN-GEP Var[Inv] ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    WIDEN store ir<%value>, ir<null>
    WIDEN-GEP Var[Inv] ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    WIDEN store ir<%aligned_regs1250>, ir<null>
    WIDEN-GEP Var[Inv] ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    WIDEN store ir<%stack>, ir<null>
    WIDEN ir<%indvars.iv.next1937> = add nuw nsw ir<%indvars.iv1936>, ir<1>
    CLONE ir<%exitcond1940.not> = icmp eq ir<%indvars.iv.next1937>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1936 = phi i64 [ %indvars.iv.next1937, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1936 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %value, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %aligned_regs1250, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %stack, align 8, !tbaa !44 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1937 = add nuw nsw i64 %indvars.iv1936, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1940.not = icmp eq i64 %indvars.iv.next1937, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1940.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1936 = phi i64 [ %indvars.iv.next1937, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1936 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %value, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %aligned_regs1250, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %stack, align 8, !tbaa !44 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1937 = add nuw nsw i64 %indvars.iv1936, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1940.not = icmp eq i64 %indvars.iv.next1937, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1940.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width 2 costs: 40

-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1936 = phi i64 [ %indvars.iv.next1937, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1936 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %value, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %aligned_regs1250, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %stack, align 8, !tbaa !44 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1937 = add nuw nsw i64 %indvars.iv1936, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1940.not = icmp eq i64 %indvars.iv.next1937, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1940.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738360
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738360

-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1936 = phi i64 [ %indvars.iv.next1937, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1936 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %value, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %aligned_regs1250, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %stack, align 8, !tbaa !44 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1937 = add nuw nsw i64 %indvars.iv1936, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1940.not = icmp eq i64 %indvars.iv.next1937, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1940.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 134217727899, RTCostB: 34359738360
A is scalable.	B is not scalable.	
RTCostA: 134217727899, RTCostB: 34359738360
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: expand_call at line: calls.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1247> = getelementptr inbounds ir<%42>, vp<%4>
    CLONE ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    CLONE store ir<null>, ir<%value>
    CLONE ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    CLONE store ir<null>, ir<%aligned_regs1250>
    CLONE ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    CLONE store ir<null>, ir<%stack>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfg.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfg.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfganal.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfganal.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfgbuild.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfgbuild.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfgcleanup.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfgcleanup.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfglayout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfglayout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfgloop.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfgloop.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cfgrtl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cfgrtl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o combine.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                combine.c
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    CLONE store ir<%insn>, ir<%arrayidx89>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %insn, ptr %arrayidx89, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: record_dead_and_set_regs at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%14> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%6>, ir<%insn>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94281 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = or ir<%or257259>, ir<%shl>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94281 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94281 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_used_regs_combine at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94281 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 43
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    CLONE store ir<%insn>, ir<%arrayidx121.us>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%25> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%6>, ir<%insn>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select348, ptr %68, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv312 = phi %59, %indvars.iv.next313, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%56>, ir<%indvars.iv312>
    CLONE store ir<%55>, ir<%arrayidx141>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%57>, ir<%indvars.iv312>
    CLONE ir<%67> = load ir<%arrayidx145>
    CLONE ir<%cmp146> = icmp eq ir<%67>, ir<%55>
    CLONE ir<%spec.select348> = zext ir<%cmp146>
    CLONE ir<%68> = getelementptr inbounds ir<%58>, ir<%indvars.iv312>
    CLONE store ir<%spec.select348>, ir<%68>
    CLONE ir<%indvars.iv.next313> = add nuw nsw ir<%indvars.iv312>, ir<1>
    CLONE ir<%exitcond316.not> = icmp eq ir<%indvars.iv.next313>, ir<%wide.trip.count315>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv312 = phi %59, %indvars.iv.next313, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%56>, ir<%indvars.iv312>
    vp<%4> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%4>, ir<%55>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%57>, ir<%indvars.iv312>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%67> = load vp<%5>
    WIDEN ir<%cmp146> = icmp eq ir<%67>, ir<%55>
    WIDEN-CAST ir<%spec.select348> = zext  ir<%cmp146> to i8
    CLONE ir<%68> = getelementptr inbounds ir<%58>, ir<%indvars.iv312>
    vp<%6> = vector-pointer ir<%68>
    WIDEN store vp<%6>, ir<%spec.select348>
    CLONE ir<%indvars.iv.next313> = add nuw nsw ir<%indvars.iv312>, ir<1>
    CLONE ir<%exitcond316.not> = icmp eq ir<%indvars.iv.next313>, ir<%wide.trip.count315>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv312 = phi %59, %indvars.iv.next313, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%56>, ir<%indvars.iv312>
    vp<%4> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%4>, ir<%55>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%57>, ir<%indvars.iv312>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%67> = load vp<%5>
    WIDEN ir<%cmp146> = icmp eq ir<%67>, ir<%55>
    WIDEN-CAST ir<%spec.select348> = zext  ir<%cmp146> to i8
    CLONE ir<%68> = getelementptr inbounds ir<%58>, ir<%indvars.iv312>
    vp<%6> = vector-pointer ir<%68>
    WIDEN store vp<%6>, ir<%spec.select348>
    CLONE ir<%indvars.iv.next313> = add nuw nsw ir<%indvars.iv312>, ir<1>
    CLONE ir<%exitcond316.not> = icmp eq ir<%indvars.iv.next313>, ir<%wide.trip.count315>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 16 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 16
B VF: 8, EstimatedWidthB: 8, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv312 = phi i64 [ %59, %for.body139.preheader ], [ %indvars.iv.next313, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %56, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %55, ptr %arrayidx141, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %57, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %67 = load i32, ptr %arrayidx145, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp146 = icmp eq i32 %67, %55 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select348 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %68 = getelementptr inbounds i8, ptr %58, i64 %indvars.iv312 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select348, ptr %68, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next313 = add nuw nsw i64 %indvars.iv312, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond316.not = icmp eq i64 %indvars.iv.next313, %wide.trip.count315 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond316.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%59> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%56>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%6>, ir<%55>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%57>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%69> = load vp<%7>
    WIDEN ir<%cmp146> = icmp eq ir<%69>, ir<%55>
    WIDEN-CAST ir<%spec.select348> = zext  ir<%cmp146> to i8
    CLONE ir<%70> = getelementptr inbounds ir<%58>, vp<%5>
    vp<%8> = vector-pointer ir<%70>
    WIDEN store vp<%8>, ir<%spec.select348>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv318 = phi %102, %indvars.iv.next319, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%100>, ir<%indvars.iv318>
    CLONE store ir<%99>, ir<%arrayidx141.us>
    CLONE ir<%indvars.iv.next319> = add nuw nsw ir<%indvars.iv318>, ir<1>
    CLONE ir<%exitcond322.not> = icmp eq ir<%indvars.iv.next319>, ir<%wide.trip.count321>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end171.thread325.loopexit>, scalar.ph

ir-bb<if.end171.thread325.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv318 = phi %102, %indvars.iv.next319, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%100>, ir<%indvars.iv318>
    vp<%4> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%4>, ir<%99>
    CLONE ir<%indvars.iv.next319> = add nuw nsw ir<%indvars.iv318>, ir<1>
    CLONE ir<%exitcond322.not> = icmp eq ir<%indvars.iv.next319>, ir<%wide.trip.count321>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end171.thread325.loopexit>, scalar.ph

ir-bb<if.end171.thread325.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv318 = phi %102, %indvars.iv.next319, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%100>, ir<%indvars.iv318>
    vp<%4> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%4>, ir<%99>
    CLONE ir<%indvars.iv.next319> = add nuw nsw ir<%indvars.iv318>, ir<1>
    CLONE ir<%exitcond322.not> = icmp eq ir<%indvars.iv.next319>, ir<%wide.trip.count321>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end171.thread325.loopexit>, scalar.ph

ir-bb<if.end171.thread325.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv318 = phi i64 [ %102, %for.body139.us.preheader ], [ %indvars.iv.next319, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %100, i64 %indvars.iv318 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %99, ptr %arrayidx141.us, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next319 = add nuw nsw i64 %indvars.iv318, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond322.not = icmp eq i64 %indvars.iv.next319, %wide.trip.count321 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond322.not, label %if.end171.thread325.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%102> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%100>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%6>, ir<%99>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end171.thread325.loopexit>, scalar.ph

ir-bb<if.end171.thread325.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 66
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv130 = phi %15, %indvars.iv.next131, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv130>
    CLONE store ir<%13>, ir<%arrayidx67>
    CLONE ir<%indvars.iv.next131> = add nuw nsw ir<%indvars.iv130>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next131>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv130 = phi %15, %indvars.iv.next131, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv130>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%13>
    CLONE ir<%indvars.iv.next131> = add nuw nsw ir<%indvars.iv130>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next131>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv130 = phi %15, %indvars.iv.next131, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv130>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%13>
    CLONE ir<%indvars.iv.next131> = add nuw nsw ir<%indvars.iv130>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next131>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv130 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next131, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv130 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %13, ptr %arrayidx67, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next131 = add nuw nsw i64 %indvars.iv130, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next131, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: update_table_tick at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%15> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%6>, ir<%13>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 88
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o conflict.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                conflict.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o convert.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                convert.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cse.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cse.c
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv884 = phi 2, %indvars.iv.next885, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv884>
    CLONE ir<%21> = load ir<%arrayidx85>
    CLONE ir<%22> = trunc ir<%21>
    CLONE ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next885> = add nuw nsw ir<%indvars.iv884>, ir<1>
    CLONE ir<%exitcond888.not> = icmp eq ir<%indvars.iv.next885>, ir<%wide.trip.count887>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%6>
}

========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv884 = phi 2, %indvars.iv.next885, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv884>
    vp<%4> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%4>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next885> = add nuw nsw ir<%indvars.iv884>, ir<1>
    CLONE ir<%exitcond888.not> = icmp eq ir<%indvars.iv.next885>, ir<%wide.trip.count887>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%7>
}

========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv884 = phi 2, %indvars.iv.next885, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv884>
    vp<%4> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%4>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next885> = add nuw nsw ir<%indvars.iv884>, ir<1>
    CLONE ir<%exitcond888.not> = icmp eq ir<%indvars.iv.next885>, ir<%wide.trip.count887>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%7>
}


-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv884 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next885, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv884 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next885 = add nuw nsw i64 %indvars.iv884, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond888.not = icmp eq i64 %indvars.iv.next885, %wide.trip.count887 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond888.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv884 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next885, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv884 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next885 = add nuw nsw i64 %indvars.iv884, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond888.not = icmp eq i64 %indvars.iv.next885, %wide.trip.count887 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond888.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv884 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next885, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv884 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next885 = add nuw nsw i64 %indvars.iv884, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond888.not = icmp eq i64 %indvars.iv.next885, %wide.trip.count887 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond888.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 1265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 635
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv884 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next885, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv884 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next885 = add nuw nsw i64 %indvars.iv884, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond888.not = icmp eq i64 %indvars.iv.next885, %wide.trip.count887 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond888.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1265
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 383

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv884 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next885, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv884 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load i64, ptr %arrayidx85, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next885 = add nuw nsw i64 %indvars.iv884, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond888.not = icmp eq i64 %indvars.iv.next885, %wide.trip.count887 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond888.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 1265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 383
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: canon_hash at line: cse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%6>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 55
Loops Epilogues Vectorized: 0
================================================
========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or697699> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = or ir<%or697699>, ir<%shl>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or697699>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or697699> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or697699>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or697699>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or697699> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or697699>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or697699>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or697699 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or697699, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or697699 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or697699, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or697699 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or697699, %shl of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or697699 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or697699, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: insert at line: cse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or697699> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or697699>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or697699>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 87
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cselib.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                cselib.c
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv332 = phi 2, %indvars.iv.next333, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv332>
    CLONE ir<%5> = load ir<%arrayidx29>
    CLONE ir<%6> = trunc ir<%5>
    CLONE ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next333> = add nuw nsw ir<%indvars.iv332>, ir<1>
    CLONE ir<%exitcond336.not> = icmp eq ir<%indvars.iv.next333>, ir<%wide.trip.count335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%6>
}

========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv332 = phi 2, %indvars.iv.next333, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv332>
    vp<%4> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next333> = add nuw nsw ir<%indvars.iv332>, ir<1>
    CLONE ir<%exitcond336.not> = icmp eq ir<%indvars.iv.next333>, ir<%wide.trip.count335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%7>
}

========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv332 = phi 2, %indvars.iv.next333, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv332>
    vp<%4> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next333> = add nuw nsw ir<%indvars.iv332>, ir<1>
    CLONE ir<%exitcond336.not> = icmp eq ir<%indvars.iv.next333>, ir<%wide.trip.count335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%7>
}


-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv332 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next333, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv332 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond336.not = icmp eq i64 %indvars.iv.next333, %wide.trip.count335 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond336.not, label %if.end41.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv332 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next333, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv332 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond336.not = icmp eq i64 %indvars.iv.next333, %wide.trip.count335 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond336.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv332 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next333, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv332 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond336.not = icmp eq i64 %indvars.iv.next333, %wide.trip.count335 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond336.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 1265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 635
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv332 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next333, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv332 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond336.not = icmp eq i64 %indvars.iv.next333, %wide.trip.count335 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond336.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1265
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 383

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv332 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next333, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv332 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load i64, ptr %arrayidx29, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next333 = add nuw nsw i64 %indvars.iv332, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond336.not = icmp eq i64 %indvars.iv.next333, %wide.trip.count335 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond336.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 1265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 383
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: hash_rtx at line: cselib.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%6>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dbxout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dbxout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o debug.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                debug.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dependence.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dependence.c
========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv474 = phi 1, %indvars.iv.next475, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv474>
    CLONE ir<%24> = load ir<%arrayidx144>
    CLONE ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    CLONE ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    CLONE ir<%indvars.iv.next475> = add nuw nsw ir<%indvars.iv474>, ir<1>
    CLONE ir<%exitcond478.not> = icmp eq ir<%indvars.iv.next475>, ir<%wide.trip.count477>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}

========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv474 = phi 1, %indvars.iv.next475, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    REPLICATE ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv474>
    REPLICATE ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    WIDEN-SELECT ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    REPLICATE ir<%indvars.iv.next475> = add nuw nsw ir<%indvars.iv474>, ir<1>
    CLONE ir<%exitcond478.not> = icmp eq ir<%indvars.iv.next475>, ir<%wide.trip.count477>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}

========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv474 = phi 1, %indvars.iv.next475, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv474>
    REPLICATE ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    WIDEN-SELECT ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    WIDEN ir<%indvars.iv.next475> = add nuw nsw ir<%indvars.iv474>, ir<1>
    CLONE ir<%exitcond478.not> = icmp eq ir<%indvars.iv.next475>, ir<%wide.trip.count477>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}

========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv474 = phi 1, %indvars.iv.next475, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv474>
    WIDEN ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    WIDEN-SELECT ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    WIDEN ir<%indvars.iv.next475> = add nuw nsw ir<%indvars.iv474>, ir<1>
    CLONE ir<%exitcond478.not> = icmp eq ir<%indvars.iv.next475>, ir<%wide.trip.count477>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}


-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 34359738352, RTCostB: 25769803764
A is not scalable.	B is not scalable.	
RTCostA: 34359738352, RTCostB: 25769803764

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 30064771056, RTCostB: 25769803764
A is not scalable.	B is not scalable.	
RTCostA: 30064771056, RTCostB: 25769803764

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 48318382047, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: 48318382047, RTCostB: 25769803764

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv474 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next475, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv474 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %24 = load i32, ptr %arrayidx144, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond478.not = icmp eq i64 %indvars.iv.next475, %wide.trip.count477 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond478.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 46170898382, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: 46170898382, RTCostB: 25769803764
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 10 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 10 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 10 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 10 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    CLONE ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    CLONE ir<%2> = load ir<%variable>
    CLONE ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx6>, vp<%4>
    CLONE ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%5> = logical-and vp<%4>, ir<%tobool.not>
    CLONE store ir<%2>, ir<%arrayidx6>, vp<%5>
    CLONE ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    CLONE ir<%4> = load ir<%coefficient>, vp<%5>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%icoeff>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx16>, vp<%5>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%6> = not ir<%tobool.not>
    EMIT vp<%7> = logical-and vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, vp<%5>
    EMIT vp<%9> = or vp<%8>, ir<%cmp4.not>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    CLONE ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    CLONE ir<%5> = load ir<%variable20>
    CLONE ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%10> = not ir<%cmp21.not>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    CLONE ir<%6> = load ir<%arrayidx24>, vp<%11>
    CLONE ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%12> = logical-and vp<%11>, ir<%tobool25.not>
    CLONE store ir<%5>, ir<%arrayidx24>, vp<%12>
    CLONE ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    CLONE ir<%7> = load ir<%coefficient34>, vp<%12>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%7>, ir<%arrayidx36>, vp<%12>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%13> = logical-and vp<%9>, ir<%cmp21.not>
    EMIT vp<%14> = or vp<%13>, vp<%12>
    EMIT vp<%15> = not ir<%tobool25.not>
    EMIT vp<%16> = logical-and vp<%11>, vp<%15>
    EMIT vp<%17> = or vp<%14>, vp<%16>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%20>
Successor(s): ir-bb<for.cond39.preheader>, scalar.ph

ir-bb<for.cond39.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    CLONE ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    INTERLEAVE-GROUP with factor 4 at %2, ir<%variable>
      ir<%2> = load from index 0
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%5>, vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool.not>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%7>, ir<%2>, vp<%6>
    REPLICATE ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    REPLICATE ir<%4> = load ir<%coefficient>, vp<%6>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%8>, ir<%4>, vp<%6>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%9> = not ir<%tobool.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    EMIT vp<%12> = or vp<%11>, ir<%cmp4.not>
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    CLONE ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    INTERLEAVE-GROUP with factor 4 at %5, ir<%variable20>
      ir<%5> = load from index 0
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%13> = not ir<%cmp21.not>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    vp<%15> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%15>, vp<%14>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%16> = logical-and vp<%14>, ir<%tobool25.not>
    vp<%17> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%17>, ir<%5>, vp<%16>
    REPLICATE ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    REPLICATE ir<%7> = load ir<%coefficient34>, vp<%16>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    vp<%18> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%18>, ir<%7>, vp<%16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%19> = logical-and vp<%12>, ir<%cmp21.not>
    EMIT vp<%20> = or vp<%19>, vp<%16>
    EMIT vp<%21> = not ir<%tobool25.not>
    EMIT vp<%22> = logical-and vp<%14>, vp<%21>
    EMIT vp<%23> = or vp<%20>, vp<%22>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    REPLICATE ir<%2> = load ir<%variable>
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%5>, vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool.not>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%7>, ir<%2>, vp<%6>
    WIDEN-GEP Var[Inv] ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    REPLICATE ir<%4> = load ir<%coefficient>, vp<%6>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%8>, ir<%4>, vp<%6>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%9> = not ir<%tobool.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    EMIT vp<%12> = or vp<%11>, ir<%cmp4.not>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    REPLICATE ir<%5> = load ir<%variable20>
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%13> = not ir<%cmp21.not>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    vp<%15> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%15>, vp<%14>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%16> = logical-and vp<%14>, ir<%tobool25.not>
    vp<%17> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%17>, ir<%5>, vp<%16>
    WIDEN-GEP Var[Inv] ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    REPLICATE ir<%7> = load ir<%coefficient34>, vp<%16>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    vp<%18> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%18>, ir<%7>, vp<%16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%19> = logical-and vp<%12>, ir<%cmp21.not>
    EMIT vp<%20> = or vp<%19>, vp<%16>
    EMIT vp<%21> = not ir<%tobool25.not>
    EMIT vp<%22> = logical-and vp<%14>, vp<%21>
    EMIT vp<%23> = or vp<%20>, vp<%22>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    WIDEN ir<%2> = load ir<%variable>
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%5>, vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool.not>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%7>, ir<%2>, vp<%6>
    WIDEN-GEP Var[Inv] ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    WIDEN ir<%4> = load ir<%coefficient>, vp<%6>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%8>, ir<%4>, vp<%6>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%9> = not ir<%tobool.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    EMIT vp<%12> = or vp<%11>, ir<%cmp4.not>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    WIDEN ir<%5> = load ir<%variable20>
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%13> = not ir<%cmp21.not>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    vp<%15> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%15>, vp<%14>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%16> = logical-and vp<%14>, ir<%tobool25.not>
    vp<%17> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%17>, ir<%5>, vp<%16>
    WIDEN-GEP Var[Inv] ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    WIDEN ir<%7> = load ir<%coefficient34>, vp<%16>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    vp<%18> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%18>, ir<%7>, vp<%16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%19> = logical-and vp<%12>, ir<%cmp21.not>
    EMIT vp<%20> = or vp<%19>, vp<%16>
    EMIT vp<%21> = not ir<%tobool25.not>
    EMIT vp<%22> = logical-and vp<%14>, vp<%21>
    EMIT vp<%23> = or vp<%20>, vp<%22>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load ptr, ptr %variable, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i32, ptr %coefficient, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load ptr, ptr %variable20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i32, ptr %coefficient34, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Scalar loop costs: 16.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %2 = load ptr, ptr %variable, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %4 = load i32, ptr %coefficient, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %5 = load ptr, ptr %variable20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %7 = load i32, ptr %coefficient34, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 3000041
A is not scalable.	B is not scalable.	
RTCostA: 6442538984829502, RTCostB: 34359738352
A is not scalable.	B is not scalable.	
RTCostA: 6442538984829502, RTCostB: 34359738352

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 8 for VF 4 For instruction:   %2 = load ptr, ptr %variable, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %4 = load i32, ptr %coefficient, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 8 for VF 4 For instruction:   %5 = load ptr, ptr %variable20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %7 = load i32, ptr %coefficient34, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 1500040
A is not scalable.	B is not scalable.	
RTCostA: 3221312439087630, RTCostB: 34359738352
A is not scalable.	B is not scalable.	
RTCostA: 3221312439087630, RTCostB: 34359738352

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load ptr, ptr %variable, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i32, ptr %coefficient, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load ptr, ptr %variable20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i32, ptr %coefficient34, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738352
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738352

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %variable, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %2, ptr %arrayidx6, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %4 = load i32, ptr %coefficient, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx16, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %5 = load ptr, ptr %variable20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %5, ptr %arrayidx24, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load i32, ptr %coefficient34, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %7, ptr %arrayidx36, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 44
A is scalable.	B is not scalable.	
RTCostA: 94489280384, RTCostB: 34359738352
A is scalable.	B is not scalable.	
RTCostA: 94489280384, RTCostB: 34359738352
LV: Selecting VF: 1 With Cost: 16.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4, !tbaa !14 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4, !tbaa !14 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%26>
    WIDEN-INDUCTION %indvars.iv194 = phi 1, %indvars.iv.next195, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv194>
    CLONE ir<%8> = load ir<%arrayidx43>
    CLONE ir<%cmp44> = icmp eq ir<%8>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv194>
    CLONE ir<%9> = load ir<%arrayidx46>
    CLONE ir<%cmp47> = icmp eq ir<%9>, ir<null>
    CLONE ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%or.cond>
    CLONE ir<%cmp55> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%icoeff>, ir<0>, ir<%indvars.iv194>
    CLONE ir<%10> = load ir<%arrayidx58>, vp<%4>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%5> = not ir<%cmp55>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%cmp82> = icmp eq ir<%10>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%7> = not ir<%cmp82>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    CLONE ir<%12> = load ir<%arrayidx84>, vp<%8>
    CLONE ir<%cmp85> = icmp eq ir<%12>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%9> = not ir<%cmp85>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv194>
    CLONE store ir<5>, ir<%arrayidx91>, vp<%10>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%11> = logical-and vp<%8>, ir<%cmp85>
    EMIT vp<%12> = logical-and vp<%6>, ir<%cmp82>
    EMIT vp<%13> = or vp<%11>, vp<%12>
    CLONE ir<%arrayidx88> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv194>
    CLONE store ir<3>, ir<%arrayidx88>, vp<%13>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%14> = logical-and vp<%4>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    CLONE ir<%11> = load ir<%arrayidx60>, vp<%14>
    CLONE ir<%cmp61> = icmp eq ir<%10>, ir<%11>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%15> = not ir<%cmp61>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    CLONE ir<%mul> = sub nsw ir<0>, ir<%11>
    CLONE ir<%cmp70> = icmp eq ir<%10>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv194>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%17> = not ir<%cmp70>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    CLONE store ir<2>, ir<%arrayidx73>, vp<%18>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%19> = logical-and vp<%16>, ir<%cmp70>
    CLONE store ir<4>, ir<%arrayidx73>, vp<%19>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%20> = logical-and vp<%14>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv194>
    CLONE store ir<1>, ir<%arrayidx64>, vp<%20>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv194>
    CLONE store ir<0>, ir<%arrayidx50>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%21> = or ir<%or.cond>, vp<%13>
    EMIT vp<%22> = or vp<%21>, vp<%10>
    EMIT vp<%23> = or vp<%22>, vp<%20>
    EMIT vp<%24> = or vp<%23>, vp<%18>
    EMIT vp<%25> = or vp<%24>, vp<%19>
    CLONE ir<%indvars.iv.next195> = add nuw nsw ir<%indvars.iv194>, ir<1>
    CLONE ir<%exitcond198.not> = icmp eq ir<%indvars.iv.next195>, ir<%wide.trip.count197>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%26> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%26>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%28> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%28>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%37>
    WIDEN-INDUCTION %indvars.iv194 = phi 1, %indvars.iv.next195, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv194>
    vp<%4> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%8> = load vp<%4>
    WIDEN ir<%cmp44> = icmp eq ir<%8>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv194>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%9> = load vp<%5>
    WIDEN ir<%cmp47> = icmp eq ir<%9>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%6> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv194>
    vp<%7> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%10> = load vp<%7>, vp<%6>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%8> = not ir<%cmp55>
    EMIT vp<%9> = logical-and vp<%6>, vp<%8>
    WIDEN ir<%cmp82> = icmp eq ir<%10>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%10> = not ir<%cmp82>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    vp<%12> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%12> = load vp<%12>, vp<%11>
    WIDEN ir<%cmp85> = icmp eq ir<%12>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%13> = not ir<%cmp85>
    EMIT vp<%14> = logical-and vp<%11>, vp<%13>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%15> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%15>, ir<5>, vp<%14>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%16> = logical-and vp<%11>, ir<%cmp85>
    EMIT vp<%17> = logical-and vp<%9>, ir<%cmp82>
    EMIT vp<%18> = or vp<%16>, vp<%17>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%19> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%19>, ir<3>, vp<%18>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%20> = logical-and vp<%6>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    vp<%21> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%11> = load vp<%21>, vp<%20>
    WIDEN ir<%cmp61> = icmp eq ir<%10>, ir<%11>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%22> = not ir<%cmp61>
    EMIT vp<%23> = logical-and vp<%20>, vp<%22>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%11>
    WIDEN ir<%cmp70> = icmp eq ir<%10>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, ir<%indvars.iv194>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%24> = not ir<%cmp70>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    vp<%26> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%26>, ir<2>, vp<%25>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%27> = logical-and vp<%23>, ir<%cmp70>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<4>, vp<%27>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%29> = logical-and vp<%20>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%30> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%30>, ir<1>, vp<%29>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%31> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%31>, ir<0>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%32> = or ir<%or.cond>, vp<%18>
    EMIT vp<%33> = or vp<%32>, vp<%14>
    EMIT vp<%34> = or vp<%33>, vp<%29>
    EMIT vp<%35> = or vp<%34>, vp<%25>
    EMIT vp<%36> = or vp<%35>, vp<%27>
    CLONE ir<%indvars.iv.next195> = add nuw nsw ir<%indvars.iv194>, ir<1>
    CLONE ir<%exitcond198.not> = icmp eq ir<%indvars.iv.next195>, ir<%wide.trip.count197>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%37> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%37>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%39> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%39>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%37>
    WIDEN-INDUCTION %indvars.iv194 = phi 1, %indvars.iv.next195, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv194>
    vp<%4> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%8> = load vp<%4>
    WIDEN ir<%cmp44> = icmp eq ir<%8>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv194>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%9> = load vp<%5>
    WIDEN ir<%cmp47> = icmp eq ir<%9>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%6> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv194>
    vp<%7> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%10> = load vp<%7>, vp<%6>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%8> = not ir<%cmp55>
    EMIT vp<%9> = logical-and vp<%6>, vp<%8>
    WIDEN ir<%cmp82> = icmp eq ir<%10>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%10> = not ir<%cmp82>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    vp<%12> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%12> = load vp<%12>, vp<%11>
    WIDEN ir<%cmp85> = icmp eq ir<%12>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%13> = not ir<%cmp85>
    EMIT vp<%14> = logical-and vp<%11>, vp<%13>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%15> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%15>, ir<5>, vp<%14>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%16> = logical-and vp<%11>, ir<%cmp85>
    EMIT vp<%17> = logical-and vp<%9>, ir<%cmp82>
    EMIT vp<%18> = or vp<%16>, vp<%17>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%19> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%19>, ir<3>, vp<%18>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%20> = logical-and vp<%6>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv194>
    vp<%21> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%11> = load vp<%21>, vp<%20>
    WIDEN ir<%cmp61> = icmp eq ir<%10>, ir<%11>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%22> = not ir<%cmp61>
    EMIT vp<%23> = logical-and vp<%20>, vp<%22>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%11>
    WIDEN ir<%cmp70> = icmp eq ir<%10>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, ir<%indvars.iv194>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%24> = not ir<%cmp70>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    vp<%26> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%26>, ir<2>, vp<%25>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%27> = logical-and vp<%23>, ir<%cmp70>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<4>, vp<%27>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%29> = logical-and vp<%20>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%30> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%30>, ir<1>, vp<%29>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, ir<%indvars.iv194>
    vp<%31> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%31>, ir<0>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%32> = or ir<%or.cond>, vp<%18>
    EMIT vp<%33> = or vp<%32>, vp<%14>
    EMIT vp<%34> = or vp<%33>, vp<%29>
    EMIT vp<%35> = or vp<%34>, vp<%25>
    EMIT vp<%36> = or vp<%35>, vp<%27>
    CLONE ir<%indvars.iv.next195> = add nuw nsw ir<%indvars.iv194>, ir<1>
    CLONE ir<%exitcond198.not> = icmp eq ir<%indvars.iv.next195>, ir<%wide.trip.count197>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%37> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%37>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%39> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%39>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv194 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next195, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp44 = icmp eq ptr %8, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp47 = icmp eq ptr %9, null of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp55 = icmp eq ptr %8, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp82 = icmp eq i32 %10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp85 = icmp eq i32 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 5, ptr %arrayidx91, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 3, ptr %arrayidx88, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp61 = icmp eq i32 %10, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul = sub nsw i32 0, %11 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp70 = icmp eq i32 %10, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 2, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 4, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx64, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx50, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next195 = add nuw nsw i64 %indvars.iv194, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond198.not = icmp eq i64 %indvars.iv.next195, %wide.trip.count197 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond198.not, label %for.end97, label %for.body41 of type:br
LV: Scalar loop costs: 19.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv194 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next195, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp44 = icmp eq ptr %8, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp47 = icmp eq ptr %9, null of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp55 = icmp eq ptr %8, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp82 = icmp eq i32 %10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp85 = icmp eq i32 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 5, ptr %arrayidx91, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 3, ptr %arrayidx88, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp61 = icmp eq i32 %10, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul = sub nsw i32 0, %11 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp70 = icmp eq i32 %10, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 2, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 4, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 1, ptr %arrayidx64, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 0, ptr %arrayidx50, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next195 = add nuw nsw i64 %indvars.iv194, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond198.not = icmp eq i64 %indvars.iv.next195, %wide.trip.count197 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond198.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width 2 costs: 51
A is not scalable.	B is not scalable.	
RTCostA: 110595407788, RTCostB: 40802189293
A is not scalable.	B is not scalable.	
RTCostA: 110595407788, RTCostB: 40802189293

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv194 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next195, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp44 = icmp eq ptr %8, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp47 = icmp eq ptr %9, null of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp55 = icmp eq ptr %8, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp82 = icmp eq i32 %10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp85 = icmp eq i32 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 5, ptr %arrayidx91, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 3, ptr %arrayidx88, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp61 = icmp eq i32 %10, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul = sub nsw i32 0, %11 of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp70 = icmp eq i32 %10, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 2, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 4, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 1, ptr %arrayidx64, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 0, ptr %arrayidx50, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next195 = add nuw nsw i64 %indvars.iv194, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond198.not = icmp eq i64 %indvars.iv.next195, %wide.trip.count197 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond198.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width 4 costs: 49
A is not scalable.	B is not scalable.	
RTCostA: 106300440435, RTCostB: 40802189293
A is not scalable.	B is not scalable.	
RTCostA: 106300440435, RTCostB: 40802189293

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv194 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next195, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp44 = icmp eq ptr %8, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp47 = icmp eq ptr %9, null of type:icmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp55 = icmp eq ptr %8, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp82 = icmp eq i32 %10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp85 = icmp eq i32 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 5, ptr %arrayidx91, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 3, ptr %arrayidx88, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp61 = icmp eq i32 %10, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = sub nsw i32 0, %11 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp70 = icmp eq i32 %10, %mul of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 2, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 4, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx64, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx50, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next195 = add nuw nsw i64 %indvars.iv194, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond198.not = icmp eq i64 %indvars.iv.next195, %wide.trip.count197 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond198.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 40802189293
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 40802189293

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv194 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next195, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = load ptr, ptr %arrayidx43, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp44 = icmp eq ptr %8, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load ptr, ptr %arrayidx46, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp47 = icmp eq ptr %9, null of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp55 = icmp eq ptr %8, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i32, ptr %arrayidx58, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp82 = icmp eq i32 %10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i32, ptr %arrayidx84, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp85 = icmp eq i32 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 5, ptr %arrayidx91, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 3, ptr %arrayidx88, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %11 = load i32, ptr %arrayidx60, align 4, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp61 = icmp eq i32 %10, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul = sub nsw i32 0, %11 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp70 = icmp eq i32 %10, %mul of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 2, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 4, ptr %arrayidx73, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx64, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv194 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx50, align 4, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next195 = add nuw nsw i64 %indvars.iv194, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond198.not = icmp eq i64 %indvars.iv.next195, %wide.trip.count197 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond198.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 11811160099, RTCostB: 40802189293
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 11811160099, RTCostB: 40802189293
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 5.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: classify_dependence at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%34>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%8> = load vp<%6>
    WIDEN ir<%cmp44> = icmp eq ir<%8>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%9> = load vp<%7>
    WIDEN ir<%cmp47> = icmp eq ir<%9>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
    EMIT vp<%8> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%10> = load vp<%9>, vp<%8>
    EMIT vp<%10> = not ir<%cmp55>
    EMIT vp<%11> = logical-and vp<%8>, vp<%10>
    WIDEN ir<%cmp82> = icmp eq ir<%10>, ir<0>
    EMIT vp<%12> = not ir<%cmp82>
    EMIT vp<%13> = logical-and vp<%11>, vp<%12>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, vp<%5>
    vp<%14> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%12> = load vp<%14>, vp<%13>
    WIDEN ir<%cmp85> = icmp eq ir<%12>, ir<0>
    EMIT vp<%15> = not ir<%cmp85>
    EMIT vp<%16> = logical-and vp<%13>, vp<%15>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, vp<%5>
    vp<%17> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%17>, ir<5>, vp<%16>
    EMIT vp<%18> = logical-and vp<%13>, ir<%cmp85>
    EMIT vp<%19> = logical-and vp<%11>, ir<%cmp82>
    EMIT vp<%20> = or vp<%18>, vp<%19>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, vp<%5>
    vp<%21> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%21>, ir<3>, vp<%20>
    EMIT vp<%22> = logical-and vp<%8>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, vp<%5>
    vp<%23> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%11> = load vp<%23>, vp<%22>
    WIDEN ir<%cmp61> = icmp eq ir<%10>, ir<%11>
    EMIT vp<%24> = not ir<%cmp61>
    EMIT vp<%25> = logical-and vp<%22>, vp<%24>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%11>
    WIDEN ir<%cmp70> = icmp eq ir<%10>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, vp<%5>
    EMIT vp<%26> = not ir<%cmp70>
    EMIT vp<%27> = logical-and vp<%25>, vp<%26>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<2>, vp<%27>
    EMIT vp<%29> = logical-and vp<%25>, ir<%cmp70>
    vp<%30> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%30>, ir<4>, vp<%29>
    EMIT vp<%31> = logical-and vp<%22>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, vp<%5>
    vp<%32> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%32>, ir<1>, vp<%31>
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, vp<%5>
    vp<%33> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%33>, ir<0>, ir<%or.cond>
    EMIT vp<%34> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%34>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%36> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%36>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 -> Cost: 10 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)
LV: Decision: Scalarize
@@ Instruction =>  %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 -> Cost: 20 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)
LV: Decision: Scalarize
@@ Instruction =>  %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv199 = phi 1, %indvars.iv.next200, ir<1>
    CLONE ir<%cmp104.not> = icmp eq ir<%indvars.iv204>, ir<%indvars.iv199>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    CLONE ir<%59> = load ir<%arrayidx107>, vp<%4>
    CLONE ir<%tobool108.not> = icmp eq ir<%59>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv199>
    CLONE ir<%60> = load ir<%arrayidx111>, vp<%6>
    CLONE ir<%cmp118> = icmp eq ir<%59>, ir<%60>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%7> = logical-and vp<%6>, ir<%cmp118>
    CLONE store ir<0>, ir<%separability>, vp<%7>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%8> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%9> = or ir<%cmp104.not>, vp<%8>
    EMIT vp<%10> = not ir<%cmp118>
    EMIT vp<%11> = logical-and vp<%6>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    CLONE ir<%indvars.iv.next200> = add nuw nsw ir<%indvars.iv199>, ir<1>
    CLONE ir<%exitcond203.not> = icmp eq ir<%indvars.iv.next200>, ir<%wide.trip.count207>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv199 = phi 1, %indvars.iv.next200, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv204>, ir<%indvars.iv199>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    REPLICATE ir<%59> = load ir<%arrayidx107>, vp<%4>
    WIDEN ir<%tobool108.not> = icmp eq ir<%59>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv199>
    vp<%7> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%60> = load vp<%7>, vp<%6>
    WIDEN ir<%cmp118> = icmp eq ir<%59>, ir<%60>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%8> = logical-and vp<%6>, ir<%cmp118>
    REPLICATE store ir<0>, ir<%separability>, vp<%8>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%9> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%10> = or ir<%cmp104.not>, vp<%9>
    EMIT vp<%11> = not ir<%cmp118>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    EMIT vp<%14> = or vp<%13>, vp<%8>
    WIDEN ir<%indvars.iv.next200> = add nuw nsw ir<%indvars.iv199>, ir<1>
    CLONE ir<%exitcond203.not> = icmp eq ir<%indvars.iv.next200>, ir<%wide.trip.count207>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv199 = phi 1, %indvars.iv.next200, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv204>, ir<%indvars.iv199>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    REPLICATE ir<%59> = load ir<%arrayidx107>, vp<%4>
    WIDEN ir<%tobool108.not> = icmp eq ir<%59>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv199>
    vp<%7> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%60> = load vp<%7>, vp<%6>
    WIDEN ir<%cmp118> = icmp eq ir<%59>, ir<%60>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%8> = logical-and vp<%6>, ir<%cmp118>
    REPLICATE store ir<0>, ir<%separability>, vp<%8>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%9> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%10> = or ir<%cmp104.not>, vp<%9>
    EMIT vp<%11> = not ir<%cmp118>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    EMIT vp<%14> = or vp<%13>, vp<%8>
    WIDEN ir<%indvars.iv.next200> = add nuw nsw ir<%indvars.iv199>, ir<1>
    CLONE ir<%exitcond203.not> = icmp eq ir<%indvars.iv.next200>, ir<%wide.trip.count207>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv199 = phi 1, %indvars.iv.next200, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv204>, ir<%indvars.iv199>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    WIDEN ir<%59> = load ir<%arrayidx107>, vp<%4>
    WIDEN ir<%tobool108.not> = icmp eq ir<%59>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv199>
    vp<%7> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%60> = load vp<%7>, vp<%6>
    WIDEN ir<%cmp118> = icmp eq ir<%59>, ir<%60>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%8> = logical-and vp<%6>, ir<%cmp118>
    WIDEN store ir<%separability>, ir<0>, vp<%8>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%9> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%10> = or ir<%cmp104.not>, vp<%9>
    EMIT vp<%11> = not ir<%cmp118>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    EMIT vp<%14> = or vp<%13>, vp<%8>
    WIDEN ir<%indvars.iv.next200> = add nuw nsw ir<%indvars.iv199>, ir<1>
    CLONE ir<%exitcond203.not> = icmp eq ir<%indvars.iv.next200>, ir<%wide.trip.count207>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv199 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next200, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv204, %indvars.iv199 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %59 = load ptr, ptr %arrayidx107, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool108.not = icmp eq ptr %59, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv199 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp118 = icmp eq ptr %59, %60 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %separability, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next200 = add nuw nsw i64 %indvars.iv199, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond203.not = icmp eq i64 %indvars.iv.next200, %wide.trip.count207 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond203.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv199 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next200, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv204, %indvars.iv199 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %59 = load ptr, ptr %arrayidx107, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool108.not = icmp eq ptr %59, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv199 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp118 = icmp eq ptr %59, %60 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 0, ptr %separability, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next200 = add nuw nsw i64 %indvars.iv199, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond203.not = icmp eq i64 %indvars.iv.next200, %wide.trip.count207 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond203.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width 2 costs: 1500012
A is not scalable.	B is not scalable.	
RTCostA: 3221252312545581, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 3221252312545581, RTCostB: 12884901882

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv199 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next200, %for.inc121 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv204, %indvars.iv199 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %59 = load ptr, ptr %arrayidx107, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool108.not = icmp eq ptr %59, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv199 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp118 = icmp eq ptr %59, %60 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 0, ptr %separability, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next200 = add nuw nsw i64 %indvars.iv199, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond203.not = icmp eq i64 %indvars.iv.next200, %wide.trip.count207 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond203.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width 4 costs: 750012
A is not scalable.	B is not scalable.	
RTCostA: 1610639039674657, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 1610639039674657, RTCostB: 12884901882

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv199 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next200, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv204, %indvars.iv199 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %59 = load ptr, ptr %arrayidx107, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool108.not = icmp eq ptr %59, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv199 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp118 = icmp eq ptr %59, %60 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %separability, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next200 = add nuw nsw i64 %indvars.iv199, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond203.not = icmp eq i64 %indvars.iv.next200, %wide.trip.count207 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond203.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv199 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next200, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv204, %indvars.iv199 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %59 = load ptr, ptr %arrayidx107, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool108.not = icmp eq ptr %59, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv199 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %60 = load ptr, ptr %arrayidx111, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp118 = icmp eq ptr %59, %60 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %separability, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next200 = add nuw nsw i64 %indvars.iv199, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond203.not = icmp eq i64 %indvars.iv.next200, %wide.trip.count207 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond203.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width vscale x 2 costs: 22
A is scalable.	B is not scalable.	
RTCostA: 47244640186, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 47244640186, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 1
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv116 = phi 1, %indvars.iv.next117, ir<1>
    CLONE ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv116>
    CLONE store ir<2147483647>, ir<%arrayidx.us>
    CLONE ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv116>
    CLONE store ir<5>, ir<%arrayidx3.us>
    CLONE ir<%indvars.iv.next117> = add nuw nsw ir<%indvars.iv116>, ir<1>
    CLONE ir<%exitcond120.not> = icmp eq ir<%indvars.iv.next117>, ir<%wide.trip.count119>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv116 = phi 1, %indvars.iv.next117, ir<1>
    REPLICATE ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv116>
    REPLICATE store ir<2147483647>, ir<%arrayidx.us>
    REPLICATE ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv116>
    REPLICATE store ir<5>, ir<%arrayidx3.us>
    REPLICATE ir<%indvars.iv.next117> = add nuw nsw ir<%indvars.iv116>, ir<1>
    CLONE ir<%exitcond120.not> = icmp eq ir<%indvars.iv.next117>, ir<%wide.trip.count119>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv116 = phi 1, %indvars.iv.next117, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv116>
    REPLICATE store ir<2147483647>, ir<%arrayidx.us>
    WIDEN-GEP Inv[Var] ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv116>
    REPLICATE store ir<5>, ir<%arrayidx3.us>
    WIDEN ir<%indvars.iv.next117> = add nuw nsw ir<%indvars.iv116>, ir<1>
    CLONE ir<%exitcond120.not> = icmp eq ir<%indvars.iv.next117>, ir<%wide.trip.count119>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv116 = phi 1, %indvars.iv.next117, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv116>
    WIDEN store ir<%arrayidx.us>, ir<2147483647>
    WIDEN-GEP Inv[Var] ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv116>
    WIDEN store ir<%arrayidx3.us>, ir<5>
    WIDEN ir<%indvars.iv.next117> = add nuw nsw ir<%indvars.iv116>, ir<1>
    CLONE ir<%exitcond120.not> = icmp eq ir<%indvars.iv.next117>, ir<%wide.trip.count119>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 9

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width 4 costs: 8

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45097156542, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45097156542, RTCostB: 12884901882

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv116 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next117, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv116 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv116 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 5, ptr %arrayidx3.us, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond120.not = icmp eq i64 %indvars.iv.next117, %wide.trip.count119 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond120.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
RTCostA: 44291850117, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 44291850117, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o df.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                df.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o diagnostic.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                diagnostic.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o doloop.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                doloop.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dominance.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dominance.c
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    CLONE store ir<%1>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.else19>, scalar.ph

ir-bb<if.else19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.else19>, scalar.ph

ir-bb<if.else19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.else19>, scalar.ph

ir-bb<if.else19>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 6442450945
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967304

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 4294967304
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.else19, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2147483672, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_dom_info at line: dominance.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%1>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call7>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%1>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.else19>, scalar.ph

ir-bb<if.else19>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body27.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv145 = phi %indvars.iv.next146, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv145 = phi %indvars.iv.next146, 0\l" +
    "  ir<%27>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%call22>, ir<%indvars.iv145>
    CLONE store ir<%27>, ir<%arrayidx30>
    CLONE ir<%indvars.iv.next146> = add nuw nsw ir<%indvars.iv145>, ir<1>
    CLONE ir<%exitcond149.not> = icmp eq ir<%indvars.iv.next146>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end34.loopexit>, scalar.ph

ir-bb<if.end34.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body27.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv145 = phi %indvars.iv.next146, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv145 = phi %indvars.iv.next146, 0\l" +
    "  ir<%27>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%call22>, ir<%indvars.iv145>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%4>, ir<%27>
    WIDEN ir<%indvars.iv.next146> = add nuw nsw ir<%indvars.iv145>, ir<1>
    CLONE ir<%exitcond149.not> = icmp eq ir<%indvars.iv.next146>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end34.loopexit>, scalar.ph

ir-bb<if.end34.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body27.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv145 = phi %indvars.iv.next146, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv145 = phi %indvars.iv.next146, 0\l" +
    "  ir<%27>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%call22>, ir<%indvars.iv145>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%4>, ir<%27>
    WIDEN ir<%indvars.iv.next146> = add nuw nsw ir<%indvars.iv145>, ir<1>
    CLONE ir<%exitcond149.not> = icmp eq ir<%indvars.iv.next146>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end34.loopexit>, scalar.ph

ir-bb<if.end34.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 6442450945
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967304

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 4294967304
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.body27 ], [ 0, %for.body27.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %call22, i64 %indvars.iv145 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %27 = trunc nuw i64 %indvars.iv145 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %27, ptr %arrayidx30, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond149.not = icmp eq i64 %indvars.iv.next146, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond149.not, label %if.end34.loopexit, label %for.body27 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2147483672, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_dom_info at line: dominance.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body27.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv145 = phi %indvars.iv.next146, 0\l" +
    "  ir<%27>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%call22>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%5>, ir<%27>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end34.loopexit>, scalar.ph

ir-bb<if.end34.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1, ptr %arrayidx72, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx72, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx72, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1, ptr %arrayidx72, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx72, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv150 = phi %indvars.iv.next151, 0, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%call65>, ir<%indvars.iv150>
    CLONE store ir<1>, ir<%arrayidx72>
    CLONE ir<%indvars.iv.next151> = add nuw nsw ir<%indvars.iv150>, ir<1>
    CLONE ir<%exitcond154.not> = icmp eq ir<%indvars.iv.next151>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end75.loopexit>, scalar.ph

ir-bb<for.end75.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv150 = phi %indvars.iv.next151, 0, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%call65>, ir<%indvars.iv150>
    vp<%4> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next151> = add nuw nsw ir<%indvars.iv150>, ir<1>
    CLONE ir<%exitcond154.not> = icmp eq ir<%indvars.iv.next151>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end75.loopexit>, scalar.ph

ir-bb<for.end75.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_dom_info' from dominance.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv150 = phi %indvars.iv.next151, 0, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%call65>, ir<%indvars.iv150>
    vp<%4> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next151> = add nuw nsw ir<%indvars.iv150>, ir<1>
    CLONE ir<%exitcond154.not> = icmp eq ir<%indvars.iv.next151>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end75.loopexit>, scalar.ph

ir-bb<for.end75.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450945, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 6442450945
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225481

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_dom_info' from dominance.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv150 = phi i64 [ %indvars.iv.next151, %for.body69 ], [ 0, %for.body69.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx72 = getelementptr inbounds i32, ptr %call65, i64 %indvars.iv150 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next151 = add nuw nsw i64 %indvars.iv150, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond154.not = icmp eq i64 %indvars.iv.next151, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond154.not, label %for.end75.loopexit, label %for.body69 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612761, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612761, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_dom_info at line: dominance.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body69.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %0)<nsw> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%call65>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%5>, ir<1>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end75.loopexit>, scalar.ph

ir-bb<for.end75.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dwarf2asm.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dwarf2asm.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dwarf2out.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dwarf2out.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dwarfout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                dwarfout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o emit-rtl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                emit-rtl.c
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    CLONE ir<%0> = load ir<%argp.addr.09>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    vp<%4> = vector-pointer ir<%argp.addr.09>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    vp<%4> = vector-pointer ir<%argp.addr.09>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %0, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: gen_rtvec_v at line: emit-rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    vp<%5>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%6> = SCALAR-STEPS vp<%5>, ir<8>
    EMIT vp<%7> = ptradd ir<%argp>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%5> = load vp<%8>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, vp<%4>
    vp<%9> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%9>, ir<%5>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 385, RTCostB: 1020
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 385, RTCostB: 1020
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1020
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 385

-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %4, ptr %arrayidx17, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 1020
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 385
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: gen_const_vector_0 at line: emit-rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%5>, ir<%4>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 83
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o except.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                except.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o explow.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                explow.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o expmed.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                expmed.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o expr.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                expr.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o final.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                final.c
MVT: v2i64
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<%seq.0759>, ir<%arrayidx181>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%4>, ir<%seq.0759>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%4>, ir<%seq.0759>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 131072, RTCostB: 262140
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 131072, RTCostB: 262140
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 262140
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131072

-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 65544, RTCostB: 262140
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 65544, RTCostB: 131072
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: shorten_branches at line: final.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%conv165> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%6>, ir<%seq.0759>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o flow.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                flow.c
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    CLONE store ir<1>, ir<%arrayidx100>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%4> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%4> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx100, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: mark_used_reg at line: flow.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: mark_used_reg at line: flow.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%0> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%idxprom99> = zext vp<%5>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%6> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%6>, ir<1>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: mark_used_reg at line: flow.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%22> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%0> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%idxprom99> = zext vp<%4>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%5> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%5>, ir<1>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%22>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 70
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fold-const.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                fold-const.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o function.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                function.c
MVT: v2i32
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv78 = phi %5, %indvars.iv.next79, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv78>
    CLONE ir<%9> = load ir<%arrayidx22.us>
    CLONE ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%inc.us> = zext ir<%cmp23.us>
    CLONE ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next79> = add nsw ir<%indvars.iv78>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv78>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%6>
}

========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv78 = phi %5, %indvars.iv.next79, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv78>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next79> = add nsw ir<%indvars.iv78>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv78>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%7>
}

========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv78 = phi %5, %indvars.iv.next79, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv78>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next79> = add nsw ir<%indvars.iv78>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv78>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%7>
}


-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv78 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next79, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next79 = add nsw i64 %indvars.iv78, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv78, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: contains at line: function.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    vp<%4>    = DERIVED-IV ir<%5> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 71
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
MVT: nxv4i1
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o gcse.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                gcse.c
========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<-1>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    REPLICATE store ir<-1>, ir<%arrayidx>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    REPLICATE store ir<-1>, ir<%arrayidx>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 46170898401, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: 46170898401, RTCostB: 17179869180

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !12 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 45097156552, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: 45097156552, RTCostB: 17179869180
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: compute_hash_table at line: gcse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, vp<%4>
    CLONE store ir<-1>, ir<%arrayidx>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 26
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv528 = phi 2, %indvars.iv.next529, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv528>
    CLONE ir<%3> = load ir<%arrayidx23>
    CLONE ir<%conv24> = trunc ir<%3>
    CLONE ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next529> = add nuw nsw ir<%indvars.iv528>, ir<1>
    CLONE ir<%exitcond532.not> = icmp eq ir<%indvars.iv.next529>, ir<%wide.trip.count531>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%6>
}

========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv528 = phi 2, %indvars.iv.next529, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv528>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next529> = add nuw nsw ir<%indvars.iv528>, ir<1>
    CLONE ir<%exitcond532.not> = icmp eq ir<%indvars.iv.next529>, ir<%wide.trip.count531>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%7>
}

========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv528 = phi 2, %indvars.iv.next529, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv528>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next529> = add nuw nsw ir<%indvars.iv528>, ir<1>
    CLONE ir<%exitcond532.not> = icmp eq ir<%indvars.iv.next529>, ir<%wide.trip.count531>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%7>
}


-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv528 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next529, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv528 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next529 = add nuw nsw i64 %indvars.iv528, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond532.not = icmp eq i64 %indvars.iv.next529, %wide.trip.count531 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond532.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv528 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next529, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv528 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next529 = add nuw nsw i64 %indvars.iv528, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond532.not = icmp eq i64 %indvars.iv.next529, %wide.trip.count531 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond532.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 635, RTCostB: 1265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv528 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next529, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv528 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next529 = add nuw nsw i64 %indvars.iv528, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond532.not = icmp eq i64 %indvars.iv.next529, %wide.trip.count531 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond532.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 1265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 383, RTCostB: 635
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv528 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next529, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv528 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next529 = add nuw nsw i64 %indvars.iv528, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond532.not = icmp eq i64 %indvars.iv.next529, %wide.trip.count531 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond532.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1265
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 383

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv528 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next529, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv528 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load i64, ptr %arrayidx23, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next529 = add nuw nsw i64 %indvars.iv528, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond532.not = icmp eq i64 %indvars.iv.next529, %wide.trip.count531 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond532.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 1265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 383
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: hash_expr_1 at line: gcse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%6>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 46
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o genrtl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                genrtl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ggc-common.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ggc-common.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o global.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                global.c
@@ Instruction =>  %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %62 to i32))<nsw> + ((1 + (sext i16 %62 to i32))<nsw> smax ((sext i16 %62 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %77, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%78> = load ir<%arrayidx339>
    CLONE ir<%add340> = add nsw ir<%78>, ir<%74>
    CLONE store ir<%add340>, ir<%arrayidx339>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    CLONE ir<%79> = load ir<%arrayidx345>
    CLONE ir<%add346> = add nsw ir<%79>, ir<%75>
    CLONE store ir<%add346>, ir<%arrayidx345>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    CLONE ir<%80> = load ir<%arrayidx351>
    CLONE ir<%add352> = add nsw ir<%80>, ir<%76>
    CLONE store ir<%add352>, ir<%arrayidx351>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%81> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330693>, ir<%81>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %62 to i32))<nsw> + ((1 + (sext i16 %62 to i32))<nsw> smax ((sext i16 %62 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %77, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%78> = load vp<%4>
    WIDEN ir<%add340> = add nsw ir<%78>, ir<%74>
    vp<%5> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%5>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%79> = load vp<%6>
    WIDEN ir<%add346> = add nsw ir<%79>, ir<%75>
    vp<%7> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%7>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%80> = load vp<%8>
    WIDEN ir<%add352> = add nsw ir<%80>, ir<%76>
    vp<%9> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%9>, ir<%add352>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%81> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330693>, ir<%81>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %62 to i32))<nsw> + ((1 + (sext i16 %62 to i32))<nsw> smax ((sext i16 %62 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %77, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%78> = load vp<%4>
    WIDEN ir<%add340> = add nsw ir<%78>, ir<%74>
    vp<%5> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%5>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%79> = load vp<%6>
    WIDEN ir<%add346> = add nsw ir<%79>, ir<%75>
    vp<%7> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%7>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%80> = load vp<%8>
    WIDEN ir<%add352> = add nsw ir<%80>, ir<%76>
    vp<%9> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%9>, ir<%add352>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%81> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330693>, ir<%81>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Scalar loop costs: 17.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 18254725086
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 18254725086
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2952970263, RTCostB: 18254725086
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952970263, RTCostB: 5905940469
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 18254725086
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2952970263

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2952970263, RTCostB: 18254725086
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2952970263, RTCostB: 2952970263
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %77, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %78 = load i32, ptr %arrayidx339, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add340 = add nsw i32 %78, %74 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %add340, ptr %arrayidx339, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %79 = load i32, ptr %arrayidx345, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add346 = add nsw i32 %79, %75 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %add346, ptr %arrayidx345, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %80 = load i32, ptr %arrayidx351, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add352 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %add352, ptr %arrayidx351, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %81 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp332 = icmp sgt i32 %add330693, %81 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1476485211, RTCostB: 18254725086
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1476485211, RTCostB: 2952970263
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %62 to i32))<nsw> + ((1 + (sext i16 %62 to i32))<nsw> smax ((sext i16 %62 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%77> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%78> = load vp<%6>
    WIDEN ir<%add340> = add nsw ir<%78>, ir<%74>
    vp<%7> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%7>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%79> = load vp<%8>
    WIDEN ir<%add346> = add nsw ir<%79>, ir<%75>
    vp<%9> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%9>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, vp<%5>
    vp<%10> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%80> = load vp<%10>
    WIDEN ir<%add352> = add nsw ir<%80>, ir<%76>
    vp<%11> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%11>, ir<%add352>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.7660 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7660>
    CLONE ir<%104> = load ir<%arrayidx364>
    CLONE ir<%tobool365.not> = icmp eq ir<%104>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%3> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%i.7660>
    CLONE store ir<0>, ir<%arrayidx367>, vp<%3>
    CLONE ir<%arrayidx368> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%i.7660>
    CLONE store ir<0>, ir<%arrayidx368>, vp<%3>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%4> = or ir<%tobool365.not>, vp<%3>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7660>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.7660 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7660>
    vp<%3> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%104> = load vp<%3>
    WIDEN ir<%tobool365.not> = icmp eq ir<%104>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%4> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, ir<%i.7660>
    vp<%5> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%5>, ir<0>, vp<%4>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, ir<%i.7660>
    vp<%6> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%6>, ir<0>, vp<%4>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%7> = or ir<%tobool365.not>, vp<%4>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7660>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.7660 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7660>
    vp<%3> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%104> = load vp<%3>
    WIDEN ir<%tobool365.not> = icmp eq ir<%104>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%4> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, ir<%i.7660>
    vp<%5> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%5>, ir<0>, vp<%4>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, ir<%i.7660>
    vp<%6> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%6>, ir<0>, vp<%4>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%7> = or ir<%tobool365.not>, vp<%4>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7660>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 2 costs: 13
A is not scalable.	B is not scalable.	
RTCostA: 709, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 709, RTCostB: 371

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 4 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 592, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 592, RTCostB: 371

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 8 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 539, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 539, RTCostB: 371

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 16 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 527, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 527, RTCostB: 371

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 85, RTCostB: 371
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 85, RTCostB: 371
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.7660 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %104 = load i8, ptr %arrayidx364, align 1, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool365.not = icmp eq i8 %104, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx367, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7660 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx368, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc371 = add nuw nsw i64 %i.7660, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 71, RTCostB: 371
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 71, RTCostB: 85
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%104> = load vp<%4>
    WIDEN ir<%tobool365.not> = icmp eq ir<%104>, ir<0>
    EMIT vp<%5> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%6>, ir<0>, vp<%5>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%7>, ir<0>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %143 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8662 = phi 0, %inc399, ir<1>
    CLONE ir<%hard_reg_conflicts> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<6>
    CLONE ir<%146> = load ir<%hard_reg_conflicts>
    CLONE ir<%and391> = and ir<%146>, ir<%not>
    CLONE store ir<%and391>, ir<%hard_reg_conflicts>
    CLONE ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<8>
    CLONE ir<%147> = load ir<%hard_reg_copy_preferences>
    CLONE ir<%and394> = and ir<%147>, ir<%not>
    CLONE store ir<%and394>, ir<%hard_reg_copy_preferences>
    CLONE ir<%hard_reg_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<7>
    CLONE ir<%148> = load ir<%hard_reg_preferences>
    CLONE ir<%and397> = and ir<%148>, ir<%not>
    CLONE store ir<%and397>, ir<%hard_reg_preferences>
    CLONE ir<%inc399> = add nuw ir<%i.8662>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %143 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8662 = phi 0, %inc399, ir<1>
    REPLICATE ir<%hard_reg_conflicts> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<6>
    REPLICATE ir<%146> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%146>, ir<%not>
    REPLICATE store ir<%and391>, ir<%hard_reg_conflicts>
    REPLICATE ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<8>
    REPLICATE ir<%147> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%147>, ir<%not>
    REPLICATE store ir<%and394>, ir<%hard_reg_copy_preferences>
    REPLICATE ir<%hard_reg_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<7>
    REPLICATE ir<%148> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%148>, ir<%not>
    REPLICATE store ir<%and397>, ir<%hard_reg_preferences>
    REPLICATE ir<%inc399> = add nuw ir<%i.8662>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %143 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8662 = phi 0, %inc399, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_conflicts> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<6>
    REPLICATE ir<%146> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%146>, ir<%not>
    REPLICATE store ir<%and391>, ir<%hard_reg_conflicts>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<8>
    REPLICATE ir<%147> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%147>, ir<%not>
    REPLICATE store ir<%and394>, ir<%hard_reg_copy_preferences>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<7>
    REPLICATE ir<%148> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%148>, ir<%not>
    REPLICATE store ir<%and397>, ir<%hard_reg_preferences>
    WIDEN ir<%inc399> = add nuw ir<%i.8662>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %143 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8662 = phi 0, %inc399, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_conflicts> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<6>
    WIDEN ir<%146> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%146>, ir<%not>
    WIDEN store ir<%hard_reg_conflicts>, ir<%and391>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<8>
    WIDEN ir<%147> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%147>, ir<%not>
    WIDEN store ir<%hard_reg_copy_preferences>, ir<%and394>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_preferences> = getelementptr inbounds ir<%145>, ir<%i.8662>, ir<7>
    WIDEN ir<%148> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%148>, ir<%not>
    WIDEN store ir<%hard_reg_preferences>, ir<%and397>
    WIDEN ir<%inc399> = add nuw ir<%i.8662>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.8662 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 6 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %146 = load i64, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and391 = and i64 %146, %not of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %147 = load i64, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and394 = and i64 %147, %not of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %148 = load i64, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and397 = and i64 %148, %not of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc399 = add nuw i64 %i.8662, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Scalar loop costs: 17.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.8662 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %146 = load i64, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and391 = and i64 %146, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %147 = load i64, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and394 = and i64 %147, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %148 = load i64, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and397 = and i64 %148, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc399 = add nuw i64 %i.8662, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width 2 costs: 38
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 77
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: 77, CostB * EstimatedWidthA: 34
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 77
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: 77, CostB * EstimatedWidthA: 34

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.8662 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %146 = load i64, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and391 = and i64 %146, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %147 = load i64, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and394 = and i64 %147, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %148 = load i64, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and397 = and i64 %148, %not of type:and
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc399 = add nuw i64 %i.8662, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 34
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 34

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.8662 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %146 = load i64, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and391 = and i64 %146, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8, !tbaa !40 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %147 = load i64, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and394 = and i64 %147, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8, !tbaa !41 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %145, i64 %i.8662, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %148 = load i64, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and397 = and i64 %148, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc399 = add nuw i64 %i.8662, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width vscale x 2 costs: 62
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 251
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: 251, CostB * EstimatedWidthA: 68
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 251
B VF: 1, EstimatedWidthB: 1, CostB: 17
CostA * EstimatedWidthB: 251, CostB * EstimatedWidthA: 68
LV: Selecting VF: 1 With Cost: 17.
maxbefore: 2
maxafter: 2
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.9664 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9664 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9664>
    CLONE store ir<%conv409>, ir<%arrayidx410>
    CLONE ir<%inc412> = add nuw ir<%i.9664>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.9664 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9664 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9664>
    vp<%4> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%4>, ir<%conv409>
    WIDEN ir<%inc412> = add nuw ir<%i.9664>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.9664 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9664 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9664>
    vp<%4> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%4>, ir<%conv409>
    WIDEN ir<%inc412> = add nuw ir<%i.9664>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.9664 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv409 = trunc i64 %i.9664 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9664 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc412 = add nuw i64 %i.9664, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %i.9664 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%5>, ir<%conv409>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10668 = phi 0, %inc436, ir<1>
    CLONE ir<%size420> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<1>
    CLONE ir<%177> = load ir<%size420>
    CLONE ir<%cmp421> = icmp eq ir<%177>, ir<0>
  Successor(s): if.then423

  if.then423:
    CLONE store ir<1>, ir<%size420>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    CLONE ir<%live_length428> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<5>
    CLONE ir<%178> = load ir<%live_length428>
    CLONE ir<%cmp429> = icmp eq ir<%178>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    CLONE store ir<-1>, ir<%live_length428>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    CLONE ir<%inc436> = add nuw ir<%i.10668>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10668 = phi 0, %inc436, ir<1>
    REPLICATE ir<%size420> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<1>
    REPLICATE ir<%177> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%177>, ir<0>
  Successor(s): if.then423

  if.then423:
    REPLICATE store ir<1>, ir<%size420>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    REPLICATE ir<%live_length428> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<5>
    REPLICATE ir<%178> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%178>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    REPLICATE store ir<-1>, ir<%live_length428>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    REPLICATE ir<%inc436> = add nuw ir<%i.10668>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10668 = phi 0, %inc436, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%size420> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<1>
    REPLICATE ir<%177> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%177>, ir<0>
  Successor(s): if.then423

  if.then423:
    REPLICATE store ir<1>, ir<%size420>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    WIDEN-GEP Inv[Var][Inv] ir<%live_length428> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<5>
    REPLICATE ir<%178> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%178>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    REPLICATE store ir<-1>, ir<%live_length428>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    WIDEN ir<%inc436> = add nuw ir<%i.10668>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10668 = phi 0, %inc436, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%size420> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<1>
    WIDEN ir<%177> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%177>, ir<0>
  Successor(s): if.then423

  if.then423:
    WIDEN store ir<%size420>, ir<1>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    WIDEN-GEP Inv[Var][Inv] ir<%live_length428> = getelementptr inbounds ir<%176>, ir<%i.10668>, ir<5>
    WIDEN ir<%178> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%178>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    WIDEN store ir<%live_length428>, ir<-1>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    WIDEN ir<%inc436> = add nuw ir<%i.10668>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width 2 costs: 1500022
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000044
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 3000044, CostB * EstimatedWidthA: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000044
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 3000044, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width 4 costs: 750021
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000084
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 3000084, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000084
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 3000084, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 2 costs: 42
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 168
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 168
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.10668 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %177 = load i32, ptr %size420, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp421 = icmp eq i32 %177, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 1, ptr %size420, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %176, i64 %i.10668, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %178 = load i32, ptr %live_length428, align 4, !tbaa !33 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp429 = icmp eq i32 %178, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %live_length428, align 4, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc436 = add nuw i64 %i.10668, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 4 costs: 41
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 329
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 329, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 329
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 329, CostB * EstimatedWidthA: 80
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 3
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
MVT: v4i32
@@ Instruction =>  %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v2i32
@@ Instruction =>  %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: prune_preferences' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body32.lr.ph.split>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre159) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv147 = phi %28, %indvars.iv.next148, ir<-1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%15>, ir<%indvars.iv147>
    CLONE ir<%29> = load ir<%arrayidx35>
    CLONE ir<%idxprom77> = sext ir<%29>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%idxprom77>
    CLONE store ir<0>, ir<%gep>
    CLONE ir<%indvars.iv.next148> = add nsw ir<%indvars.iv147>, ir<-1>
    CLONE ir<%cmp30.not> = icmp eq ir<%indvars.iv147>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end87.loopexit163>, scalar.ph

ir-bb<for.end87.loopexit163>:
No successors

scalar.ph:
No successors
}

========== Loop: prune_preferences' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body32.lr.ph.split>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre159) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv147 = phi %28, %indvars.iv.next148, ir<-1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%15>, ir<%indvars.iv147>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx35>
    WIDEN ir<%29> = load vp<%4>
    WIDEN-CAST ir<%idxprom77> = sext  ir<%29> to i64
    REPLICATE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%idxprom77>
    REPLICATE store ir<0>, ir<%gep>
    CLONE ir<%indvars.iv.next148> = add nsw ir<%indvars.iv147>, ir<-1>
    CLONE ir<%cmp30.not> = icmp eq ir<%indvars.iv147>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end87.loopexit163>, scalar.ph

ir-bb<for.end87.loopexit163>:
No successors

scalar.ph:
No successors
}

========== Loop: prune_preferences' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body32.lr.ph.split>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre159) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv147 = phi %28, %indvars.iv.next148, ir<-1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%15>, ir<%indvars.iv147>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx35>
    WIDEN ir<%29> = load vp<%4>
    WIDEN-CAST ir<%idxprom77> = sext  ir<%29> to i64
    WIDEN-GEP Inv[Var] ir<%gep> = getelementptr ir<%invariant.gep>, ir<%idxprom77>
    REPLICATE store ir<0>, ir<%gep>
    CLONE ir<%indvars.iv.next148> = add nsw ir<%indvars.iv147>, ir<-1>
    CLONE ir<%cmp30.not> = icmp eq ir<%indvars.iv147>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end87.loopexit163>, scalar.ph

ir-bb<for.end87.loopexit163>:
No successors

scalar.ph:
No successors
}

========== Loop: prune_preferences' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body32.lr.ph.split>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre159) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv147 = phi %28, %indvars.iv.next148, ir<-1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%15>, ir<%indvars.iv147>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx35>
    WIDEN ir<%29> = load vp<%4>
    WIDEN-CAST ir<%idxprom77> = sext  ir<%29> to i64
    WIDEN-GEP Inv[Var] ir<%gep> = getelementptr ir<%invariant.gep>, ir<%idxprom77>
    WIDEN store ir<%gep>, ir<0>
    CLONE ir<%indvars.iv.next148> = add nsw ir<%indvars.iv147>, ir<-1>
    CLONE ir<%cmp30.not> = icmp eq ir<%indvars.iv147>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end87.loopexit163>, scalar.ph

ir-bb<for.end87.loopexit163>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'prune_preferences' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv147 = phi i64 [ %28, %for.body32.lr.ph.split ], [ %indvars.iv.next148, %for.body32 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %15, i64 %indvars.iv147 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom77 = sext i32 %29 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep = getelementptr %struct.allocno, ptr %invariant.gep, i64 %idxprom77 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 0, ptr %gep, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next148 = add nsw i64 %indvars.iv147, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp30.not = icmp eq i64 %indvars.iv147, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp30.not, label %for.end87.loopexit163, label %for.body32 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'prune_preferences' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv147 = phi i64 [ %28, %for.body32.lr.ph.split ], [ %indvars.iv.next148, %for.body32 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %15, i64 %indvars.iv147 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom77 = sext i32 %29 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep = getelementptr %struct.allocno, ptr %invariant.gep, i64 %idxprom77 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 0, ptr %gep, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next148 = add nsw i64 %indvars.iv147, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp30.not = icmp eq i64 %indvars.iv147, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp30.not, label %for.end87.loopexit163, label %for.body32 of type:br
LV: Vector loop of width 2 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 33285996519, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 33285996519, RTCostB: 12884901882

-----------------Function that is being costed:'prune_preferences' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv147 = phi i64 [ %28, %for.body32.lr.ph.split ], [ %indvars.iv.next148, %for.body32 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %15, i64 %indvars.iv147 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom77 = sext i32 %29 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep = getelementptr %struct.allocno, ptr %invariant.gep, i64 %idxprom77 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i64 0, ptr %gep, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next148 = add nsw i64 %indvars.iv147, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp30.not = icmp eq i64 %indvars.iv147, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp30.not, label %for.end87.loopexit163, label %for.body32 of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 31675383767, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 31675383767, RTCostB: 12884901882

-----------------Function that is being costed:'prune_preferences' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv147 = phi i64 [ %28, %for.body32.lr.ph.split ], [ %indvars.iv.next148, %for.body32 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %15, i64 %indvars.iv147 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom77 = sext i32 %29 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep = getelementptr %struct.allocno, ptr %invariant.gep, i64 %idxprom77 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 0, ptr %gep, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next148 = add nsw i64 %indvars.iv147, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp30.not = icmp eq i64 %indvars.iv147, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp30.not, label %for.end87.loopexit163, label %for.body32 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'prune_preferences' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv147 = phi i64 [ %28, %for.body32.lr.ph.split ], [ %indvars.iv.next148, %for.body32 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx35 = getelementptr inbounds i32, ptr %15, i64 %indvars.iv147 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %29 = load i32, ptr %arrayidx35, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom77 = sext i32 %29 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep = getelementptr %struct.allocno, ptr %invariant.gep, i64 %idxprom77 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 0, ptr %gep, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next148 = add nsw i64 %indvars.iv147, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp30.not = icmp eq i64 %indvars.iv147, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp30.not, label %for.end87.loopexit163, label %for.body32 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24696061924, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 24696061924, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: prune_preferences at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body32.lr.ph.split>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre159) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%28> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%15>, vp<%5>
    CLONE ir<%29> = load ir<%arrayidx35>
    CLONE ir<%idxprom77> = sext ir<%29>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%idxprom77>
    CLONE store ir<0>, ir<%gep>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end87.loopexit163>, scalar.ph

ir-bb<for.end87.loopexit163>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%idxprom1> = sext ir<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    CLONE ir<%5> = load ir<%arrayidx2>
    CLONE ir<%idxprom3> = sext ir<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE ir<%6> = load ir<%arrayidx4>
    CLONE ir<%.lobit> = lshr ir<%6>, ir<15>
    CLONE ir<%inc> = zext nneg ir<%.lobit>
    CLONE ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    REPLICATE ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    REPLICATE ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    REPLICATE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    REPLICATE ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    WIDEN ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 33
A is not scalable.	B is not scalable.	
RTCostA: 71940702152, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 71940702152, RTCostB: 23622320117

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 32
A is not scalable.	B is not scalable.	
RTCostA: 69256347552, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 69256347552, RTCostB: 23622320117

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 31
A is not scalable.	B is not scalable.	
RTCostA: 67377299282, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 67377299282, RTCostB: 23622320117

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 22
A is scalable.	B is not scalable.	
RTCostA: 47244640201, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: 47244640201, RTCostB: 23622320117

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %5 = load i32, ptr %arrayidx2, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %6 = load i16, ptr %arrayidx4, align 2, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 46170898337, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: 46170898337, RTCostB: 23622320117
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: dump_conflicts at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, vp<%4>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%idxprom1> = sext ir<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    CLONE ir<%5> = load ir<%arrayidx2>
    CLONE ir<%idxprom3> = sext ir<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE ir<%6> = load ir<%arrayidx4>
    CLONE ir<%.lobit> = lshr ir<%6>, ir<15>
    CLONE ir<%inc> = zext nneg ir<%.lobit>
    CLONE ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 40 -> VectorType: <8 x i16> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 10 -> VectorType: <2 x i16> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 20 -> VectorType: <4 x i16> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 40 -> VectorType: <8 x i16> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body764.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-53 + (zext i32 %136 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1306 = phi 53, %indvars.iv.next1307, ir<1>
    CLONE ir<%arrayidx766> = getelementptr inbounds ir<%137>, ir<%indvars.iv1306>
    CLONE ir<%138> = load ir<%arrayidx766>
    CLONE ir<%cmp767> = icmp eq ir<%138>, ir<%num>
  Successor(s): if.then769

  if.then769:
    CLONE ir<%arrayidx772> = getelementptr inbounds ir<%131>, ir<%indvars.iv1306>
    CLONE store ir<%conv748>, ir<%arrayidx772>, ir<%cmp767>
  Successor(s): for.inc774

  for.inc774:
    EMIT vp<%4> = not ir<%cmp767>
    EMIT vp<%5> = or vp<%4>, ir<%cmp767>
    CLONE ir<%indvars.iv.next1307> = add nuw nsw ir<%indvars.iv1306>, ir<1>
    CLONE ir<%exitcond1311.not> = icmp eq ir<%indvars.iv.next1307>, ir<%wide.trip.count1310>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end777.loopexit>, scalar.ph

ir-bb<if.end777.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body764.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-53 + (zext i32 %136 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv1306 = phi 53, %indvars.iv.next1307, ir<1>
    CLONE ir<%arrayidx766> = getelementptr inbounds ir<%137>, ir<%indvars.iv1306>
    vp<%4> = vector-pointer ir<%arrayidx766>
    WIDEN ir<%138> = load vp<%4>
    WIDEN ir<%cmp767> = icmp eq ir<%138>, ir<%num>
  Successor(s): if.then769

  if.then769:
    CLONE ir<%arrayidx772> = getelementptr ir<%131>, ir<%indvars.iv1306>
    vp<%5> = vector-pointer ir<%arrayidx772>
    WIDEN store vp<%5>, ir<%conv748>, ir<%cmp767>
  Successor(s): for.inc774

  for.inc774:
    EMIT vp<%6> = not ir<%cmp767>
    EMIT vp<%7> = or vp<%6>, ir<%cmp767>
    CLONE ir<%indvars.iv.next1307> = add nuw nsw ir<%indvars.iv1306>, ir<1>
    CLONE ir<%exitcond1311.not> = icmp eq ir<%indvars.iv.next1307>, ir<%wide.trip.count1310>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end777.loopexit>, scalar.ph

ir-bb<if.end777.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body764.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-53 + (zext i32 %136 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv1306 = phi 53, %indvars.iv.next1307, ir<1>
    CLONE ir<%arrayidx766> = getelementptr inbounds ir<%137>, ir<%indvars.iv1306>
    vp<%4> = vector-pointer ir<%arrayidx766>
    WIDEN ir<%138> = load vp<%4>
    WIDEN ir<%cmp767> = icmp eq ir<%138>, ir<%num>
  Successor(s): if.then769

  if.then769:
    CLONE ir<%arrayidx772> = getelementptr ir<%131>, ir<%indvars.iv1306>
    vp<%5> = vector-pointer ir<%arrayidx772>
    WIDEN store vp<%5>, ir<%conv748>, ir<%cmp767>
  Successor(s): for.inc774

  for.inc774:
    EMIT vp<%6> = not ir<%cmp767>
    EMIT vp<%7> = or vp<%6>, ir<%cmp767>
    CLONE ir<%indvars.iv.next1307> = add nuw nsw ir<%indvars.iv1306>, ir<1>
    CLONE ir<%exitcond1311.not> = icmp eq ir<%indvars.iv.next1307>, ir<%wide.trip.count1310>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end777.loopexit>, scalar.ph

ir-bb<if.end777.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 15032385158, RTCostB: 12884901564
A is not scalable.	B is not scalable.	
RTCostA: 15032385158, RTCostB: 12884901564

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901564, RTCostB: 12884901564
A is not scalable.	B is not scalable.	
RTCostA: 12884901564, RTCostB: 12884901564

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 12348030666, RTCostB: 12884901564
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12348030666, RTCostB: 12884901564
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901564
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12348030666

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354502, RTCostB: 12884901564
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354502, RTCostB: 12348030666
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 8

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1306 = phi i64 [ 53, %for.body764.lr.ph ], [ %indvars.iv.next1307, %for.inc774 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx766 = getelementptr inbounds i32, ptr %137, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %138 = load i32, ptr %arrayidx766, align 4, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp767 = icmp eq i32 %138, %num of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp767, label %if.then769, label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx772 = getelementptr inbounds i16, ptr %131, i64 %indvars.iv1306 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %conv748, ptr %arrayidx772, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc774 of type:br

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1307 = add nuw nsw i64 %indvars.iv1306, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1311.not = icmp eq i64 %indvars.iv.next1307, %wide.trip.count1310 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1311.not, label %if.end777.loopexit, label %for.body764 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177257, RTCostB: 12884901564
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177257, RTCostB: 2684354502
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: find_reg at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body764.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-53 + (zext i32 %136 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<53> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx766> = getelementptr inbounds ir<%137>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx766>
    WIDEN ir<%140> = load vp<%6>
    WIDEN ir<%cmp767> = icmp eq ir<%140>, ir<%num>
    CLONE ir<%arrayidx772> = getelementptr ir<%131>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx772>
    WIDEN store vp<%7>, ir<%conv748>, ir<%cmp767>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end777.loopexit>, scalar.ph

ir-bb<if.end777.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1315 = phi %182, %indvars.iv.next1316, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    CLONE ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1315>
    CLONE ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    CLONE ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    CLONE ir<%indvars.iv.next1316> = add nuw nsw ir<%indvars.iv1315>, ir<1>
    CLONE ir<%190> = trunc ir<%indvars.iv.next1316>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461341>, ir<%190>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1315 = phi %182, %indvars.iv.next1316, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1315>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    WIDEN ir<%indvars.iv.next1316> = add nuw nsw ir<%indvars.iv1315>, ir<1>
    CLONE ir<%190> = trunc ir<%indvars.iv.next1316>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461341>, ir<%190>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1315 = phi %182, %indvars.iv.next1316, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1315>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    WIDEN ir<%indvars.iv.next1316> = add nuw nsw ir<%indvars.iv1315>, ir<1>
    CLONE ir<%190> = trunc ir<%indvars.iv.next1316>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461341>, ir<%190>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}


-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1315 = phi i64 [ %182, %for.body850.preheader ], [ %indvars.iv.next1316, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1315 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1316 = add nuw nsw i64 %indvars.iv1315, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %190 = trunc nuw i64 %indvars.iv.next1316 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp848 = icmp sgt i32 %add8461341, %190 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1315 = phi i64 [ %182, %for.body850.preheader ], [ %indvars.iv.next1316, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1315 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1316 = add nuw nsw i64 %indvars.iv1315, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %190 = trunc nuw i64 %indvars.iv.next1316 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp848 = icmp sgt i32 %add8461341, %190 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1315 = phi i64 [ %182, %for.body850.preheader ], [ %indvars.iv.next1316, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1315 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1316 = add nuw nsw i64 %indvars.iv1315, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %190 = trunc nuw i64 %indvars.iv.next1316 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp848 = icmp sgt i32 %add8461341, %190 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1315 = phi i64 [ %182, %for.body850.preheader ], [ %indvars.iv.next1316, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1315 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1316 = add nuw nsw i64 %indvars.iv1315, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %190 = trunc nuw i64 %indvars.iv.next1316 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp848 = icmp sgt i32 %add8461341, %190 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: find_reg at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1315 = phi %182, %indvars.iv.next1316, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1315>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 35
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    CLONE ir<%sh_prom> = zext nneg ir<%regno.addr.068>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or6567>, ir<%shl>
    CLONE ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_reg_live_nc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 46
Loops Epilogues Vectorized: 0
================================================
MVT: v2i64
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %16 = load i64, ptr %gep, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  store i64 %or23, ptr %gep, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %16 = load i64, ptr %gep, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i64 %or23, ptr %gep, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %16 = load i64, ptr %gep, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i64 %or23, ptr %gep, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    CLONE ir<%15> = load ir<%arrayidx19>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    CLONE ir<%16> = load ir<%gep>
    CLONE ir<%or23> = or ir<%16>, ir<%15>
    CLONE store ir<%or23>, ir<%gep>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit61>, scalar.ph

ir-bb<if.end27.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%16> = load vp<%5>
    WIDEN ir<%or23> = or ir<%16>, ir<%15>
    vp<%6> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%6>, ir<%or23>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end27.loopexit61>, scalar.ph

ir-bb<if.end27.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%16> = load vp<%5>
    WIDEN ir<%or23> = or ir<%16>, ir<%15>
    vp<%6> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%6>, ir<%or23>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end27.loopexit61>, scalar.ph

ir-bb<if.end27.loopexit61>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i64, ptr %gep, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or23, ptr %gep, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit61 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %16 = load i64, ptr %gep, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i64 %or23, ptr %gep, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit61 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 19327352832, RTCostB: 38654705655
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 19327352832, RTCostB: 38654705655
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i64, ptr %gep, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %or23, ptr %gep, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit61 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705655
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352832

-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %15 = load i64, ptr %arrayidx19, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %16 = load i64, ptr %gep, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %or23, ptr %gep, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit61 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 9663676434, RTCostB: 38654705655
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9663676434, RTCostB: 19327352832
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: record_one_conflict at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%13> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%18> = load vp<%6>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%7> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%19> = load vp<%7>
    WIDEN ir<%or23> = or ir<%19>, ir<%18>
    vp<%8> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%8>, ir<%or23>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end27.loopexit61>, scalar.ph

ir-bb<if.end27.loopexit61>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 49
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    CLONE ir<%sh_prom99> = zext nneg ir<%regno.1142>
    CLONE ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    CLONE ir<%not101> = xor ir<%shl100>, ir<-1>
    CLONE ir<%and102> = and ir<%and102139141>, ir<%not101>
    CLONE ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}

========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    WIDEN ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}

========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    WIDEN ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_reg_death at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 50
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o graph.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                graph.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o haifa-sched.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                haifa-sched.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hash.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hash.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hashtable.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hashtable.c
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8, !tbaa !15 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8, !tbaa !15 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8, !tbaa !15 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    CLONE ir<%2> = load ir<%p.0>
    CLONE ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%3> = load ir<%2>, vp<%4>
    CLONE ir<%conv> = zext ir<%3>
    CLONE ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    CLONE ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    CLONE ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    CLONE ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>)
    CLONE ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%5> = or ir<%tobool.not>, vp<%4>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%9> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%10> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%11> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%8>
Live-out i64 %longest.2.lcssa = vp<%9>
Live-out i64 %total_bytes.1.lcssa = vp<%10>
Live-out i64 %nids.1.lcssa = vp<%11>
}

========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    vp<%4> = vector-pointer ir<%p.0>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%5> = not ir<%tobool.not>
    REPLICATE ir<%3> = load ir<%2>, vp<%5>
    WIDEN-CAST ir<%conv> = zext  ir<%3> to i64
    WIDEN ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    WIDEN ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    WIDEN ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>) (using vector intrinsic)
    WIDEN ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%6> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%10> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%11> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%12> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%9>
Live-out i64 %longest.2.lcssa = vp<%10>
Live-out i64 %total_bytes.1.lcssa = vp<%11>
Live-out i64 %nids.1.lcssa = vp<%12>
}

========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    vp<%4> = vector-pointer ir<%p.0>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%5> = not ir<%tobool.not>
    REPLICATE ir<%3> = load ir<%2>, vp<%5>
    WIDEN-CAST ir<%conv> = zext  ir<%3> to i64
    WIDEN ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    WIDEN ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    WIDEN ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>) (using vector intrinsic)
    WIDEN ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%6> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%10> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%11> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%12> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%9>
Live-out i64 %longest.2.lcssa = vp<%10>
Live-out i64 %total_bytes.1.lcssa = vp<%11>
Live-out i64 %nids.1.lcssa = vp<%12>
}

========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    vp<%4> = vector-pointer ir<%p.0>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%3> = load ir<%2>, vp<%5>
    WIDEN-CAST ir<%conv> = zext  ir<%3> to i64
    WIDEN ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    WIDEN ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    WIDEN ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>) (using vector intrinsic)
    WIDEN ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%6> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%10> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%11> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%12> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%9>
Live-out i64 %longest.2.lcssa = vp<%10>
Live-out i64 %total_bytes.1.lcssa = vp<%11>
Live-out i64 %nids.1.lcssa = vp<%12>
}


-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load ptr, ptr %p.0, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i32, ptr %2, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load ptr, ptr %p.0, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %3 = load i32, ptr %2, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 2 for VF 2 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 6 for VF 2 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 6 for VF 2 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 6 for VF 2 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width 2 costs: 1500018
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000037
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 3000037, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000037
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 3000037, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load ptr, ptr %p.0, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %3 = load i32, ptr %2, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 4 for VF 4 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 80 for VF 4 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 80 for VF 4 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 80 for VF 4 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 80 for VF 4 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width 4 costs: 750086
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000347
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 3000347, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000347
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 3000347, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load ptr, ptr %p.0, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i32, ptr %2, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %p.0, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %3 = load i32, ptr %2, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width vscale x 2 costs: 13
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 53
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 53, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 53
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 53, CostB * EstimatedWidthA: 32
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hooks.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hooks.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ifcvt.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ifcvt.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-attrtab.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-attrtab.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-emit.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-emit.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-extract.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-extract.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-opinit.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-opinit.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-output.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-output.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-peep.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-peep.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o insn-recog.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                insn-recog.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o integrate.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                integrate.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o intl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                intl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o jump.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                jump.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o langhooks.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                langhooks.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lcm.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                lcm.c
========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64106 to i64) + (-1 * (1 umin (zext i32 %cond64106 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%15>
    CLONE ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64106 to i64) + (-1 * (1 umin (zext i32 %cond64106 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64106 to i64) + (-1 * (1 umin (zext i32 %cond64106 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: reg_becomes_live at line: lcm.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64106 to i64) + (-1 * (1 umin (zext i32 %cond64106 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 33
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lists.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                lists.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o local-alloc.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                local-alloc.c
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1110 = phi 0, %indvars.iv.next1111, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1110 = phi 0, %indvars.iv.next1111\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1110>
    CLONE store ir<%78>, ir<%arrayidx505>
    CLONE ir<%indvars.iv.next1111> = add nuw nsw ir<%indvars.iv1110>, ir<1>
    CLONE ir<%exitcond1114.not> = icmp eq ir<%indvars.iv.next1111>, ir<%wide.trip.count1113>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1110 = phi 0, %indvars.iv.next1111, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1110 = phi 0, %indvars.iv.next1111\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1110>
    vp<%4> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%4>, ir<%78>
    WIDEN ir<%indvars.iv.next1111> = add nuw nsw ir<%indvars.iv1110>, ir<1>
    CLONE ir<%exitcond1114.not> = icmp eq ir<%indvars.iv.next1111>, ir<%wide.trip.count1113>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1110 = phi 0, %indvars.iv.next1111, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1110 = phi 0, %indvars.iv.next1111\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1110>
    vp<%4> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%4>, ir<%78>
    WIDEN ir<%indvars.iv.next1111> = add nuw nsw ir<%indvars.iv1110>, ir<1>
    CLONE ir<%exitcond1114.not> = icmp eq ir<%indvars.iv.next1111>, ir<%wide.trip.count1113>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1110 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1111, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1110 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1110 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %78, ptr %arrayidx505, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1111 = add nuw nsw i64 %indvars.iv1110, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1114.not = icmp eq i64 %indvars.iv.next1111, %wide.trip.count1113 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1114.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: block_alloc at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1110 = phi 0, %indvars.iv.next1111\l" +
    "  ir<%78>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%5>, ir<%78>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %123 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1118 = phi 0, %indvars.iv.next1119, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1118 = phi 0, %indvars.iv.next1119\l" +
    "  ir<%126>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1118>
    CLONE store ir<%126>, ir<%arrayidx581>
    CLONE ir<%indvars.iv.next1119> = add nuw nsw ir<%indvars.iv1118>, ir<1>
    CLONE ir<%exitcond1122.not> = icmp eq ir<%indvars.iv.next1119>, ir<%wide.trip.count1121>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %123 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1118 = phi 0, %indvars.iv.next1119, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1118 = phi 0, %indvars.iv.next1119\l" +
    "  ir<%126>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1118>
    vp<%4> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%4>, ir<%126>
    WIDEN ir<%indvars.iv.next1119> = add nuw nsw ir<%indvars.iv1118>, ir<1>
    CLONE ir<%exitcond1122.not> = icmp eq ir<%indvars.iv.next1119>, ir<%wide.trip.count1121>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %123 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1118 = phi 0, %indvars.iv.next1119, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1118 = phi 0, %indvars.iv.next1119\l" +
    "  ir<%126>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1118>
    vp<%4> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%4>, ir<%126>
    WIDEN ir<%indvars.iv.next1119> = add nuw nsw ir<%indvars.iv1118>, ir<1>
    CLONE ir<%exitcond1122.not> = icmp eq ir<%indvars.iv.next1119>, ir<%wide.trip.count1121>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1118 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1119, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1118 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %126 = trunc nuw nsw i64 %indvars.iv1118 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %126, ptr %arrayidx581, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1119 = add nuw nsw i64 %indvars.iv1118, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1122.not = icmp eq i64 %indvars.iv.next1119, %wide.trip.count1121 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1122.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: block_alloc at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %123 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1118 = phi 0, %indvars.iv.next1119\l" +
    "  ir<%126>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%5>, ir<%126>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 20
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    CLONE ir<%9> = load ir<%arrayidx20>
    CLONE ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%7>
}

========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%7>
}


-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i64, ptr %arrayidx20, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: find_free_reg at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    vp<%4>    = DERIVED-IV ir<%0> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 41
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%15>
    CLONE ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit93>, scalar.ph

ir-bb<if.end.sink.split.loopexit93>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit93>, scalar.ph

ir-bb<if.end.sink.split.loopexit93>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit93>, scalar.ph

ir-bb<if.end.sink.split.loopexit93>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit93 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit93 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit93 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit93 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit93>, scalar.ph

ir-bb<if.end.sink.split.loopexit93>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv89 = phi %36, %indvars.iv.next90, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    CLONE ir<%indvars.iv.next90> = add nsw ir<%indvars.iv89>, ir<-1>
    CLONE ir<%39> = add nsw ir<%indvars.iv.next90>, ir<%37>
    CLONE ir<%shl51> = shl nuw ir<1>, ir<%39>
    CLONE ir<%not> = xor ir<%shl51>, ir<-1>
    CLONE ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv89>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv89 = phi %36, %indvars.iv.next90, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next90> = add nsw ir<%indvars.iv89>, ir<-1>
    WIDEN ir<%39> = add nsw ir<%indvars.iv.next90>, ir<%37>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%39>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv89>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv89 = phi %36, %indvars.iv.next90, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next90> = add nsw ir<%indvars.iv89>, ir<-1>
    WIDEN ir<%39> = add nsw ir<%indvars.iv.next90>, ir<%37>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%39>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv89>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv89 = phi i64 [ %36, %while.body48.preheader ], [ %indvars.iv.next90, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next90 = add nsw i64 %indvars.iv89, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %39 = add nsw i64 %indvars.iv.next90, %37 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl51 = shl nuw i64 1, %39 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv89, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv89 = phi i64 [ %36, %while.body48.preheader ], [ %indvars.iv.next90, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next90 = add nsw i64 %indvars.iv89, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %39 = add nsw i64 %indvars.iv.next90, %37 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl51 = shl nuw i64 1, %39 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv89, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv89 = phi i64 [ %36, %while.body48.preheader ], [ %indvars.iv.next90, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next90 = add nsw i64 %indvars.iv89, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %39 = add nsw i64 %indvars.iv.next90, %37 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl51 = shl nuw i64 1, %39 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv89, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450938
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225472

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv89 = phi i64 [ %36, %while.body48.preheader ], [ %indvars.iv.next90, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next90 = add nsw i64 %indvars.iv89, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %39 = add nsw i64 %indvars.iv.next90, %37 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl51 = shl nuw i64 1, %39 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv89, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv89 = phi %36, %indvars.iv.next90, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next90> = add nsw ir<%indvars.iv89>, ir<-1>
    WIDEN ir<%39> = add nsw ir<%indvars.iv.next90>, ir<%37>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%39>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 43
Loops Epilogues Vectorized: 0
================================================
========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond39101 to i64) + (-1 * (1 umin (zext i32 %cond39101 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%13>
    CLONE ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond39101 to i64) + (-1 * (1 umin (zext i32 %cond39101 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond39101 to i64) + (-1 * (1 umin (zext i32 %cond39101 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: post_mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond39101 to i64) + (-1 * (1 umin (zext i32 %cond39101 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv96 = phi %36, %indvars.iv.next97, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%35>, ir<%indvars.iv96>
    CLONE ir<%38> = load ir<%arrayidx49>
    CLONE ir<%or50> = or ir<%38>, ir<%this_reg.0.lcssa>
    CLONE store ir<%or50>, ir<%arrayidx49>
    CLONE ir<%indvars.iv.next97> = add nsw ir<%indvars.iv96>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next97>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv96 = phi %36, %indvars.iv.next97, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%35>, ir<%indvars.iv96>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%38> = load vp<%4>
    WIDEN ir<%or50> = or ir<%38>, ir<%this_reg.0.lcssa>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%5>, ir<%or50>
    CLONE ir<%indvars.iv.next97> = add nsw ir<%indvars.iv96>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next97>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv96 = phi %36, %indvars.iv.next97, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%35>, ir<%indvars.iv96>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%38> = load vp<%4>
    WIDEN ir<%or50> = or ir<%38>, ir<%this_reg.0.lcssa>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%5>, ir<%or50>
    CLONE ir<%indvars.iv.next97> = add nsw ir<%indvars.iv96>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next97>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv96 = phi i64 [ %36, %while.body47.lr.ph ], [ %indvars.iv.next97, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %35, i64 %indvars.iv96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or50 = or i64 %38, %this_reg.0.lcssa of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next97 = add nsw i64 %indvars.iv96, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next97, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv96 = phi i64 [ %36, %while.body47.lr.ph ], [ %indvars.iv.next97, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %35, i64 %indvars.iv96 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or50 = or i64 %38, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next97 = add nsw i64 %indvars.iv96, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next97, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv96 = phi i64 [ %36, %while.body47.lr.ph ], [ %indvars.iv.next97, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %35, i64 %indvars.iv96 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or50 = or i64 %38, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next97 = add nsw i64 %indvars.iv96, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next97, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv96 = phi i64 [ %36, %while.body47.lr.ph ], [ %indvars.iv.next97, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %35, i64 %indvars.iv96 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %38 = load i64, ptr %arrayidx49, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or50 = or i64 %38, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %or50, ptr %arrayidx49, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next97 = add nsw i64 %indvars.iv96, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next97, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: post_mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%36> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%35>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%38> = load vp<%6>
    WIDEN ir<%or50> = or ir<%38>, ir<%this_reg.0.lcssa>
    vp<%7> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%7>, ir<%or50>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 45
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o loop.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                loop.c
========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    CLONE ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    CLONE store ir<%add.ptr>, ir<%aux>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    REPLICATE ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    REPLICATE store ir<%add.ptr>, ir<%aux>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var][Inv] ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    REPLICATE store ir<%add.ptr>, ir<%aux>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var][Inv] ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    WIDEN store ir<%aux>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr, ptr %aux, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr, ptr %aux, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width 2 costs: 16

-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %aux, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %aux, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: loop_optimize at line: loop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call17>, vp<%4>
    CLONE ir<%aux> = getelementptr inbounds ir<%call14>, vp<%4>, ir<22>
    CLONE store ir<%add.ptr>, ir<%aux>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: scan_loop' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1448.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %234 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2067 = phi 0, %indvars.iv.next2068, ir<1>
    CLONE ir<%arrayidx1451> = getelementptr inbounds ir<%235>, ir<%indvars.iv2067>
    CLONE ir<%236> = load ir<%arrayidx1451>
    CLONE ir<%cmp1453> = icmp slt ir<%236>, ir<0>
  Successor(s): if.then1455

  if.then1455:
    CLONE ir<%n_times_set1459> = getelementptr inbounds ir<%arrayidx1451>, ir<4>
    CLONE ir<%237> = load ir<%n_times_set1459>, ir<%cmp1453>
    CLONE store ir<%237>, ir<%arrayidx1451>, ir<%cmp1453>
  Successor(s): for.inc1465

  for.inc1465:
    EMIT vp<%4> = not ir<%cmp1453>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1453>
    CLONE ir<%indvars.iv.next2068> = add nuw nsw ir<%indvars.iv2067>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next2068>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end1467.loopexit>, scalar.ph

ir-bb<for.end1467.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: scan_loop' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1448.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %234 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2067 = phi 0, %indvars.iv.next2068, ir<1>
    REPLICATE ir<%arrayidx1451> = getelementptr inbounds ir<%235>, ir<%indvars.iv2067>
    INTERLEAVE-GROUP with factor 6 at %236, ir<%arrayidx1451>
      ir<%236> = load from index 0
    WIDEN ir<%cmp1453> = icmp slt ir<%236>, ir<0>
  Successor(s): if.then1455

  if.then1455:
    REPLICATE ir<%n_times_set1459> = getelementptr inbounds ir<%arrayidx1451>, ir<4>
    REPLICATE ir<%237> = load ir<%n_times_set1459>, ir<%cmp1453>
    REPLICATE store ir<%237>, ir<%arrayidx1451>, ir<%cmp1453>
  Successor(s): for.inc1465

  for.inc1465:
    EMIT vp<%4> = not ir<%cmp1453>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1453>
    REPLICATE ir<%indvars.iv.next2068> = add nuw nsw ir<%indvars.iv2067>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next2068>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: scan_loop' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1448.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %234 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2067 = phi 0, %indvars.iv.next2068, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1451> = getelementptr inbounds ir<%235>, ir<%indvars.iv2067>
    REPLICATE ir<%236> = load ir<%arrayidx1451>
    WIDEN ir<%cmp1453> = icmp slt ir<%236>, ir<0>
  Successor(s): if.then1455

  if.then1455:
    WIDEN-GEP Var[Inv] ir<%n_times_set1459> = getelementptr inbounds ir<%arrayidx1451>, ir<4>
    REPLICATE ir<%237> = load ir<%n_times_set1459>, ir<%cmp1453>
    REPLICATE store ir<%237>, ir<%arrayidx1451>, ir<%cmp1453>
  Successor(s): for.inc1465

  for.inc1465:
    EMIT vp<%4> = not ir<%cmp1453>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1453>
    WIDEN ir<%indvars.iv.next2068> = add nuw nsw ir<%indvars.iv2067>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next2068>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: scan_loop' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1448.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %234 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2067 = phi 0, %indvars.iv.next2068, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1451> = getelementptr inbounds ir<%235>, ir<%indvars.iv2067>
    WIDEN ir<%236> = load ir<%arrayidx1451>
    WIDEN ir<%cmp1453> = icmp slt ir<%236>, ir<0>
  Successor(s): if.then1455

  if.then1455:
    WIDEN-GEP Var[Inv] ir<%n_times_set1459> = getelementptr inbounds ir<%arrayidx1451>, ir<4>
    WIDEN ir<%237> = load ir<%n_times_set1459>, ir<%cmp1453>
    WIDEN store ir<%arrayidx1451>, ir<%237>, ir<%cmp1453>
  Successor(s): for.inc1465

  for.inc1465:
    EMIT vp<%4> = not ir<%cmp1453>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1453>
    WIDEN ir<%indvars.iv.next2068> = add nuw nsw ir<%indvars.iv2067>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next2068>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Vector loop of width 2 costs: 1500011
A is not scalable.	B is not scalable.	
RTCostA: 3221249091320113, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 3221249091320113, RTCostB: 15032385529

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 22 for VF 4 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Found an estimated cost of 8 for VF 4 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Vector loop of width 4 costs: 750010
A is not scalable.	B is not scalable.	
RTCostA: 1610634744707372, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 1610634744707372, RTCostB: 15032385529

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 67645734807, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: 67645734807, RTCostB: 15032385529

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv2067 = phi i64 [ 0, %for.body1448.lr.ph ], [ %indvars.iv.next2068, %for.inc1465 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1451 = getelementptr inbounds %struct.loop_reg, ptr %235, i64 %indvars.iv2067 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %236 = load i32, ptr %arrayidx1451, align 8, !tbaa !32 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1453 = icmp slt i32 %236, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1453, label %if.then1455, label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n_times_set1459 = getelementptr inbounds i8, ptr %arrayidx1451, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %237 = load i32, ptr %n_times_set1459, align 4, !tbaa !50 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %237, ptr %arrayidx1451, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc1465 of type:br

-----------------Function that is being costed:'scan_loop' from loop.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next2068 = add nuw nsw i64 %indvars.iv2067, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next2068, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end1467.loopexit, label %for.body1448 of type:br
LV: Vector loop of width vscale x 4 costs: 30
A is scalable.	B is not scalable.	
RTCostA: 66303557434, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: 66303557434, RTCostB: 15032385529
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx>
    CLONE ir<%may_not_optimize> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<3>
    CLONE store ir<0>, ir<%may_not_optimize>
    CLONE ir<%single_usage> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<2>
    CLONE store ir<null>, ir<%single_usage>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx>
    REPLICATE ir<%may_not_optimize> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<3>
    REPLICATE store ir<0>, ir<%may_not_optimize>
    REPLICATE ir<%single_usage> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<2>
    REPLICATE store ir<null>, ir<%single_usage>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx>
    WIDEN-GEP Inv[Var][Inv] ir<%may_not_optimize> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<3>
    REPLICATE store ir<0>, ir<%may_not_optimize>
    WIDEN-GEP Inv[Var][Inv] ir<%single_usage> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<2>
    REPLICATE store ir<null>, ir<%single_usage>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<0>
    WIDEN-GEP Inv[Var][Inv] ir<%may_not_optimize> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<3>
    WIDEN store ir<%may_not_optimize>, ir<0>
    WIDEN-GEP Inv[Var][Inv] ir<%single_usage> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<2>
    WIDEN store ir<%single_usage>, ir<null>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 13

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 12

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 8 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 8 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 8 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 12

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 64 for VF 16 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 64 for VF 16 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 64 for VF 16 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 12

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %may_not_optimize = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 0, ptr %may_not_optimize, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %single_usage = getelementptr inbounds %struct.loop_reg, ptr %5, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %single_usage, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: loop_regs_scan at line: loop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, vp<%4>
    CLONE store ir<0>, ir<%arrayidx>
    CLONE ir<%may_not_optimize> = getelementptr inbounds ir<%5>, vp<%4>, ir<3>
    CLONE store ir<0>, ir<%may_not_optimize>
    CLONE ir<%single_usage> = getelementptr inbounds ir<%5>, vp<%4>, ir<2>
    CLONE store ir<null>, ir<%single_usage>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body137.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %39 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv236 = phi %41, %indvars.iv.next237, ir<1>
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%40>, ir<%indvars.iv236>
    CLONE ir<%42> = load ir<%arrayidx140>
    CLONE ir<%n_times_set> = getelementptr inbounds ir<%arrayidx140>, ir<4>
    CLONE store ir<%42>, ir<%n_times_set>
    CLONE ir<%indvars.iv.next237> = add nsw ir<%indvars.iv236>, ir<1>
    CLONE ir<%exitcond240.not> = icmp eq ir<%indvars.iv.next237>, ir<%wide.trip.count239>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end147.loopexit>, scalar.ph

ir-bb<for.end147.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body137.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %39 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv236 = phi %41, %indvars.iv.next237, ir<1>
    REPLICATE ir<%arrayidx140> = getelementptr inbounds ir<%40>, ir<%indvars.iv236>
    INTERLEAVE-GROUP with factor 6 at %42, ir<%arrayidx140>
      ir<%42> = load from index 0
    REPLICATE ir<%n_times_set> = getelementptr inbounds ir<%arrayidx140>, ir<4>
    REPLICATE store ir<%42>, ir<%n_times_set>
    REPLICATE ir<%indvars.iv.next237> = add nsw ir<%indvars.iv236>, ir<1>
    CLONE ir<%exitcond240.not> = icmp eq ir<%indvars.iv.next237>, ir<%wide.trip.count239>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body137.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %39 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv236 = phi %41, %indvars.iv.next237, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx140> = getelementptr inbounds ir<%40>, ir<%indvars.iv236>
    REPLICATE ir<%42> = load ir<%arrayidx140>
    WIDEN-GEP Var[Inv] ir<%n_times_set> = getelementptr inbounds ir<%arrayidx140>, ir<4>
    REPLICATE store ir<%42>, ir<%n_times_set>
    WIDEN ir<%indvars.iv.next237> = add nsw ir<%indvars.iv236>, ir<1>
    CLONE ir<%exitcond240.not> = icmp eq ir<%indvars.iv.next237>, ir<%wide.trip.count239>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: loop_regs_scan' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body137.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %39 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv236 = phi %41, %indvars.iv.next237, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx140> = getelementptr inbounds ir<%40>, ir<%indvars.iv236>
    WIDEN ir<%42> = load ir<%arrayidx140>
    WIDEN-GEP Var[Inv] ir<%n_times_set> = getelementptr inbounds ir<%arrayidx140>, ir<4>
    WIDEN store ir<%n_times_set>, ir<%42>
    WIDEN ir<%indvars.iv.next237> = add nsw ir<%indvars.iv236>, ir<1>
    CLONE ir<%exitcond240.not> = icmp eq ir<%indvars.iv.next237>, ir<%wide.trip.count239>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 22 for VF 4 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Vector loop of width 4 costs: 12
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'loop_regs_scan' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv236 = phi i64 [ %41, %for.body137.lr.ph ], [ %indvars.iv.next237, %for.body137 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx140 = getelementptr inbounds %struct.loop_reg, ptr %40, i64 %indvars.iv236 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %42 = load i32, ptr %arrayidx140, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n_times_set = getelementptr inbounds i8, ptr %arrayidx140, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %42, ptr %n_times_set, align 4, !tbaa !38 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next237 = add nsw i64 %indvars.iv236, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond240.not = icmp eq i64 %indvars.iv.next237, %wide.trip.count239 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond240.not, label %for.end147.loopexit, label %for.body137 of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: loop_regs_scan at line: loop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body137.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %39 to i64) + (-1 * (sext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%41> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%40>, vp<%5>
    CLONE ir<%42> = load ir<%arrayidx140>
    CLONE ir<%n_times_set> = getelementptr inbounds ir<%arrayidx140>, ir<4>
    CLONE store ir<%42>, ir<%n_times_set>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end147.loopexit>, scalar.ph

ir-bb<for.end147.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 50
Loops Epilogues Vectorized: 0
================================================
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv450 = phi 0, %indvars.iv.next451, ir<1>
    CLONE ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv450>
    CLONE ir<%22> = load ir<%arrayidx232.us>
    CLONE ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr464>
    CLONE ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    CLONE ir<%idxprom236.us> = sext ir<%add235.us>
    CLONE ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    CLONE ir<%23> = load ir<%arrayidx237.us>
    CLONE ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    CLONE ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    CLONE ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    CLONE ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    CLONE ir<%reass.sub416> = sub ir<%25>, ir<%24>
    CLONE ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    CLONE store ir<%sub245.us>, ir<%total_benefit244.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    CLONE ir<%indvars.iv.next451> = add nuw nsw ir<%indvars.iv450>, ir<1>
    CLONE ir<%exitcond454.not> = icmp eq ir<%indvars.iv.next451>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%conv465>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup253.us>, scalar.ph

ir-bb<cleanup253.us>:
No successors

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv450 = phi 0, %indvars.iv.next451, ir<1>
    REPLICATE ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv450>
    INTERLEAVE-GROUP with factor 2 at %22, ir<%arrayidx232.us>
      ir<%22> = load from index 0
    WIDEN ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr464>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    REPLICATE ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    REPLICATE ir<%23> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    REPLICATE ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    REPLICATE ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    REPLICATE ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    REPLICATE ir<%reass.sub416> = sub ir<%25>, ir<%24>
    REPLICATE ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    REPLICATE store ir<%sub245.us>, ir<%total_benefit244.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    REPLICATE ir<%indvars.iv.next451> = add nuw nsw ir<%indvars.iv450>, ir<1>
    CLONE ir<%exitcond454.not> = icmp eq ir<%indvars.iv.next451>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv450 = phi 0, %indvars.iv.next451, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv450>
    REPLICATE ir<%22> = load ir<%arrayidx232.us>
    WIDEN ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr464>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    REPLICATE ir<%23> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    REPLICATE ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    WIDEN-GEP Var[Inv] ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    REPLICATE ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    WIDEN ir<%reass.sub416> = sub ir<%25>, ir<%24>
    WIDEN ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    REPLICATE store ir<%sub245.us>, ir<%total_benefit244.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    WIDEN ir<%indvars.iv.next451> = add nuw nsw ir<%indvars.iv450>, ir<1>
    CLONE ir<%exitcond454.not> = icmp eq ir<%indvars.iv.next451>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv450 = phi 0, %indvars.iv.next451, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv450>
    WIDEN ir<%22> = load ir<%arrayidx232.us>
    WIDEN ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr464>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    WIDEN ir<%23> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    WIDEN ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    WIDEN-GEP Var[Inv] ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    WIDEN ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    WIDEN ir<%reass.sub416> = sub ir<%25>, ir<%24>
    WIDEN ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    WIDEN store ir<%total_benefit244.us>, ir<%sub245.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    WIDEN ir<%indvars.iv.next451> = add nuw nsw ir<%indvars.iv450>, ir<1>
    CLONE ir<%exitcond454.not> = icmp eq ir<%indvars.iv.next451>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv450 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next451, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv450 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next451 = add nuw nsw i64 %indvars.iv450, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond454.not = icmp eq i64 %indvars.iv.next451, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond454.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv450 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next451, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv450 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 5 for VF 2 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next451 = add nuw nsw i64 %indvars.iv450, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond454.not = icmp eq i64 %indvars.iv.next451, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond454.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width 2 costs: 3000024
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6000049
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 6000049, CostB * EstimatedWidthA: 26
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6000049
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 6000049, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv450 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next451, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv450 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 10 for VF 4 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next451 = add nuw nsw i64 %indvars.iv450, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond454.not = icmp eq i64 %indvars.iv.next451, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond454.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width 4 costs: 1500023
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6000094
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 6000094, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6000094
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 6000094, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv450 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next451, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv450 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next451 = add nuw nsw i64 %indvars.iv450, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond454.not = icmp eq i64 %indvars.iv.next451, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond454.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv450 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next451, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv450 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next451 = add nuw nsw i64 %indvars.iv450, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond454.not = icmp eq i64 %indvars.iv.next451, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond454.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width vscale x 2 costs: 53
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 212
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 212, CostB * EstimatedWidthA: 52
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 212
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 212, CostB * EstimatedWidthA: 52
LV: Selecting VF: 1 With Cost: 13.
maxbefore: 2
maxafter: 2
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv433 = phi %indvars.iv.next434, 0, ir<1>
    CLONE ir<%arrayidx189.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv433>
    CLONE ir<%47> = load ir<%arrayidx189.us>
    CLONE ir<%mul191.us> = mul nsw ir<%47>, ir<%giv_count.0.lcssa.fr464>
    CLONE ir<%48> = sext ir<%mul191.us>
    CLONE ir<%arrayidx194.us> = getelementptr ir<%40>, ir<%48>
    CLONE ir<%49> = load ir<%arrayidx194.us>
    CLONE ir<%tobool195.not.us> = icmp eq ir<%49>, ir<null>
  Successor(s): if.then196.us

  if.then196.us:
    EMIT vp<%3> = not ir<%tobool195.not.us>
    CLONE ir<%total_benefit201.us> = getelementptr inbounds ir<%arrayidx189.us>, ir<4>
    CLONE ir<%50> = load ir<%total_benefit201.us>, vp<%3>
    CLONE ir<%reass.sub> = sub ir<%50>, ir<%34>
    CLONE ir<%sub202.us> = add ir<%reass.sub>, ir<-3>
    CLONE store ir<%sub202.us>, ir<%total_benefit201.us>, vp<%3>
  Successor(s): if.end203.us

  if.end203.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool195.not.us>
    CLONE ir<%indvars.iv.next434> = add nuw nsw ir<%indvars.iv433>, ir<1>
    CLONE ir<%exitcond437.not> = icmp eq ir<%indvars.iv.next434>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%conv465>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end206.us>, scalar.ph

ir-bb<for.end206.us>:
No successors

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv433 = phi %indvars.iv.next434, 0, ir<1>
    REPLICATE ir<%arrayidx189.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv433>
    INTERLEAVE-GROUP with factor 2 at %47, ir<%arrayidx189.us>
      ir<%47> = load from index 0
    WIDEN ir<%mul191.us> = mul nsw ir<%47>, ir<%giv_count.0.lcssa.fr464>
    WIDEN-CAST ir<%48> = sext  ir<%mul191.us> to i64
    REPLICATE ir<%arrayidx194.us> = getelementptr ir<%40>, ir<%48>
    REPLICATE ir<%49> = load ir<%arrayidx194.us>
    WIDEN ir<%tobool195.not.us> = icmp eq ir<%49>, ir<null>
  Successor(s): if.then196.us

  if.then196.us:
    EMIT vp<%3> = not ir<%tobool195.not.us>
    REPLICATE ir<%total_benefit201.us> = getelementptr inbounds ir<%arrayidx189.us>, ir<4>
    REPLICATE ir<%50> = load ir<%total_benefit201.us>, vp<%3>
    REPLICATE ir<%reass.sub> = sub ir<%50>, ir<%34>
    REPLICATE ir<%sub202.us> = add ir<%reass.sub>, ir<-3>
    REPLICATE store ir<%sub202.us>, ir<%total_benefit201.us>, vp<%3>
  Successor(s): if.end203.us

  if.end203.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool195.not.us>
    REPLICATE ir<%indvars.iv.next434> = add nuw nsw ir<%indvars.iv433>, ir<1>
    CLONE ir<%exitcond437.not> = icmp eq ir<%indvars.iv.next434>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv433 = phi %indvars.iv.next434, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx189.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv433>
    REPLICATE ir<%47> = load ir<%arrayidx189.us>
    WIDEN ir<%mul191.us> = mul nsw ir<%47>, ir<%giv_count.0.lcssa.fr464>
    WIDEN-CAST ir<%48> = sext  ir<%mul191.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx194.us> = getelementptr ir<%40>, ir<%48>
    REPLICATE ir<%49> = load ir<%arrayidx194.us>
    WIDEN ir<%tobool195.not.us> = icmp eq ir<%49>, ir<null>
  Successor(s): if.then196.us

  if.then196.us:
    EMIT vp<%3> = not ir<%tobool195.not.us>
    WIDEN-GEP Var[Inv] ir<%total_benefit201.us> = getelementptr inbounds ir<%arrayidx189.us>, ir<4>
    REPLICATE ir<%50> = load ir<%total_benefit201.us>, vp<%3>
    WIDEN ir<%reass.sub> = sub ir<%50>, ir<%34>
    WIDEN ir<%sub202.us> = add ir<%reass.sub>, ir<-3>
    REPLICATE store ir<%sub202.us>, ir<%total_benefit201.us>, vp<%3>
  Successor(s): if.end203.us

  if.end203.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool195.not.us>
    WIDEN ir<%indvars.iv.next434> = add nuw nsw ir<%indvars.iv433>, ir<1>
    CLONE ir<%exitcond437.not> = icmp eq ir<%indvars.iv.next434>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv465> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv433 = phi %indvars.iv.next434, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx189.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv433>
    WIDEN ir<%47> = load ir<%arrayidx189.us>
    WIDEN ir<%mul191.us> = mul nsw ir<%47>, ir<%giv_count.0.lcssa.fr464>
    WIDEN-CAST ir<%48> = sext  ir<%mul191.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx194.us> = getelementptr ir<%40>, ir<%48>
    WIDEN ir<%49> = load ir<%arrayidx194.us>
    WIDEN ir<%tobool195.not.us> = icmp eq ir<%49>, ir<null>
  Successor(s): if.then196.us

  if.then196.us:
    EMIT vp<%3> = not ir<%tobool195.not.us>
    WIDEN-GEP Var[Inv] ir<%total_benefit201.us> = getelementptr inbounds ir<%arrayidx189.us>, ir<4>
    WIDEN ir<%50> = load ir<%total_benefit201.us>, vp<%3>
    WIDEN ir<%reass.sub> = sub ir<%50>, ir<%34>
    WIDEN ir<%sub202.us> = add ir<%reass.sub>, ir<-3>
    WIDEN store ir<%total_benefit201.us>, ir<%sub202.us>, vp<%3>
  Successor(s): if.end203.us

  if.end203.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool195.not.us>
    WIDEN ir<%indvars.iv.next434> = add nuw nsw ir<%indvars.iv433>, ir<1>
    CLONE ir<%exitcond437.not> = icmp eq ir<%indvars.iv.next434>, ir<%conv465>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv433 = phi i64 [ %indvars.iv.next434, %if.end203.us ], [ 0, %if.end183.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx189.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv433 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load i32, ptr %arrayidx189.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul191.us = mul nsw i32 %47, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %48 = sext i32 %mul191.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx194.us = getelementptr ptr, ptr %40, i64 %48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %49 = load ptr, ptr %arrayidx194.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool195.not.us = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool195.not.us, label %if.end203.us, label %if.then196.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_benefit201.us = getelementptr inbounds i8, ptr %arrayidx189.us, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %50 = load i32, ptr %total_benefit201.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %reass.sub = sub i32 %50, %34 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub202.us = add i32 %reass.sub, -3 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub202.us, ptr %total_benefit201.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end203.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next434 = add nuw nsw i64 %indvars.iv433, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond437.not = icmp eq i64 %indvars.iv.next434, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond437.not, label %for.end206.us, label %for.body187.us of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv433 = phi i64 [ %indvars.iv.next434, %if.end203.us ], [ 0, %if.end183.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx189.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv433 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %47 = load i32, ptr %arrayidx189.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul191.us = mul nsw i32 %47, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %48 = sext i32 %mul191.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx194.us = getelementptr ptr, ptr %40, i64 %48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %49 = load ptr, ptr %arrayidx194.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool195.not.us = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool195.not.us, label %if.end203.us, label %if.then196.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %total_benefit201.us = getelementptr inbounds i8, ptr %arrayidx189.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %50 = load i32, ptr %total_benefit201.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 3 for VF 2 For instruction:   %reass.sub = sub i32 %50, %34 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub202.us = add i32 %reass.sub, -3 of type:add
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %sub202.us, ptr %total_benefit201.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end203.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next434 = add nuw nsw i64 %indvars.iv433, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond437.not = icmp eq i64 %indvars.iv.next434, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond437.not, label %for.end206.us, label %for.body187.us of type:br
LV: Vector loop of width 2 costs: 1500023
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000046
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 3000046, CostB * EstimatedWidthA: 22
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000046
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 3000046, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv433 = phi i64 [ %indvars.iv.next434, %if.end203.us ], [ 0, %if.end183.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx189.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv433 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   %47 = load i32, ptr %arrayidx189.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul191.us = mul nsw i32 %47, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %48 = sext i32 %mul191.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx194.us = getelementptr ptr, ptr %40, i64 %48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %49 = load ptr, ptr %arrayidx194.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool195.not.us = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool195.not.us, label %if.end203.us, label %if.then196.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %total_benefit201.us = getelementptr inbounds i8, ptr %arrayidx189.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %50 = load i32, ptr %total_benefit201.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 6 for VF 4 For instruction:   %reass.sub = sub i32 %50, %34 of type:sub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub202.us = add i32 %reass.sub, -3 of type:add
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %sub202.us, ptr %total_benefit201.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end203.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next434 = add nuw nsw i64 %indvars.iv433, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond437.not = icmp eq i64 %indvars.iv.next434, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond437.not, label %for.end206.us, label %for.body187.us of type:br
LV: Vector loop of width 4 costs: 750022
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000089
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 3000089, CostB * EstimatedWidthA: 44
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3000089
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 3000089, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv433 = phi i64 [ %indvars.iv.next434, %if.end203.us ], [ 0, %if.end183.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx189.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv433 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load i32, ptr %arrayidx189.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul191.us = mul nsw i32 %47, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %48 = sext i32 %mul191.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx194.us = getelementptr ptr, ptr %40, i64 %48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %49 = load ptr, ptr %arrayidx194.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool195.not.us = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool195.not.us, label %if.end203.us, label %if.then196.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %total_benefit201.us = getelementptr inbounds i8, ptr %arrayidx189.us, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %50 = load i32, ptr %total_benefit201.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %reass.sub = sub i32 %50, %34 of type:sub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub202.us = add i32 %reass.sub, -3 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub202.us, ptr %total_benefit201.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end203.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next434 = add nuw nsw i64 %indvars.iv433, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond437.not = icmp eq i64 %indvars.iv.next434, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond437.not, label %for.end206.us, label %for.body187.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv433 = phi i64 [ %indvars.iv.next434, %if.end203.us ], [ 0, %if.end183.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx189.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv433 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %47 = load i32, ptr %arrayidx189.us, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul191.us = mul nsw i32 %47, %giv_count.0.lcssa.fr464 of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %48 = sext i32 %mul191.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx194.us = getelementptr ptr, ptr %40, i64 %48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %49 = load ptr, ptr %arrayidx194.us, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool195.not.us = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool195.not.us, label %if.end203.us, label %if.then196.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %total_benefit201.us = getelementptr inbounds i8, ptr %arrayidx189.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %50 = load i32, ptr %total_benefit201.us, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %reass.sub = sub i32 %50, %34 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub202.us = add i32 %reass.sub, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %sub202.us, ptr %total_benefit201.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end203.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next434 = add nuw nsw i64 %indvars.iv433, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond437.not = icmp eq i64 %indvars.iv.next434, %conv465 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond437.not, label %for.end206.us, label %for.body187.us of type:br
LV: Vector loop of width vscale x 2 costs: 42
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 170
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 170, CostB * EstimatedWidthA: 44
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 170
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 170, CostB * EstimatedWidthA: 44
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o obstack.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                obstack.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o optabs.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                optabs.c
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx15>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx15.1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<0>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<0>
    REPLICATE store ir<1317>, ir<%arrayidx15>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<1317>, ir<%arrayidx15.1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<0>
    WIDEN store ir<%arrayidx15>, ir<1317>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<1>
    WIDEN store ir<%arrayidx15.1>, ir<1317>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<0>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, ir<%indvars.iv>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 354
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 122
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv367, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 354
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 74
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv367>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv374 = phi 0, %indvars.iv.next375, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx42>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx42.1>
    CLONE ir<%indvars.iv.next375> = add nuw nsw ir<%indvars.iv374>, ir<1>
    CLONE ir<%exitcond377.not> = icmp eq ir<%indvars.iv.next375>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv374 = phi 0, %indvars.iv.next375, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<0>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next375> = add nuw nsw ir<%indvars.iv374>, ir<1>
    CLONE ir<%exitcond377.not> = icmp eq ir<%indvars.iv.next375>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv374 = phi 0, %indvars.iv.next375, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<0>
    REPLICATE store ir<1317>, ir<%arrayidx42>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<1>
    REPLICATE store ir<1317>, ir<%arrayidx42.1>
    WIDEN ir<%indvars.iv.next375> = add nuw nsw ir<%indvars.iv374>, ir<1>
    CLONE ir<%exitcond377.not> = icmp eq ir<%indvars.iv.next375>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv374 = phi 0, %indvars.iv.next375, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<0>
    WIDEN store ir<%arrayidx42>, ir<1317>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<1>
    WIDEN store ir<%arrayidx42.1>, ir<1317>
    WIDEN ir<%indvars.iv.next375> = add nuw nsw ir<%indvars.iv374>, ir<1>
    CLONE ir<%exitcond377.not> = icmp eq ir<%indvars.iv.next375>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv374 = phi 0, %indvars.iv.next375, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<0>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, ir<%indvars.iv374>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next375> = add nuw nsw ir<%indvars.iv374>, ir<1>
    CLONE ir<%exitcond377.not> = icmp eq ir<%indvars.iv.next375>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx42 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 354
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 122
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv374 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next375, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx42, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv378, i64 %indvars.iv374, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next375 = add nuw nsw i64 %indvars.iv374, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond377.not = icmp eq i64 %indvars.iv.next375, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond377.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 354
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 74
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv378>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv385 = phi 0, %indvars.iv.next386, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx72>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx72.1>
    CLONE ir<%indvars.iv.next386> = add nuw nsw ir<%indvars.iv385>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next386>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv385 = phi 0, %indvars.iv.next386, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<0>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next386> = add nuw nsw ir<%indvars.iv385>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next386>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv385 = phi 0, %indvars.iv.next386, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<0>
    REPLICATE store ir<1317>, ir<%arrayidx72>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<1>
    REPLICATE store ir<1317>, ir<%arrayidx72.1>
    WIDEN ir<%indvars.iv.next386> = add nuw nsw ir<%indvars.iv385>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next386>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv385 = phi 0, %indvars.iv.next386, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<0>
    WIDEN store ir<%arrayidx72>, ir<1317>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<1>
    WIDEN store ir<%arrayidx72.1>, ir<1317>
    WIDEN ir<%indvars.iv.next386> = add nuw nsw ir<%indvars.iv385>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next386>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv385 = phi 0, %indvars.iv.next386, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<0>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv385>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next386> = add nuw nsw ir<%indvars.iv385>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next386>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 354
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 122
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv385 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next386, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx72, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv389, i64 %indvars.iv385, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next386 = add nuw nsw i64 %indvars.iv385, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next386, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond388.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 354
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 74
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv389>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv396 = phi 0, %indvars.iv.next397, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx102>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx102.1>
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond399.not> = icmp eq ir<%indvars.iv.next397>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv396 = phi 0, %indvars.iv.next397, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<0>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond399.not> = icmp eq ir<%indvars.iv.next397>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv396 = phi 0, %indvars.iv.next397, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<0>
    REPLICATE store ir<1317>, ir<%arrayidx102>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<1>
    REPLICATE store ir<1317>, ir<%arrayidx102.1>
    WIDEN ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond399.not> = icmp eq ir<%indvars.iv.next397>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv396 = phi 0, %indvars.iv.next397, ir<1>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<0>
    WIDEN store ir<%arrayidx102>, ir<1317>
    WIDEN-GEP Inv[Inv][Inv][Var][Inv] ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<1>
    WIDEN store ir<%arrayidx102.1>, ir<1317>
    WIDEN ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond399.not> = icmp eq ir<%indvars.iv.next397>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv396 = phi 0, %indvars.iv.next397, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<0>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, ir<%indvars.iv396>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond399.not> = icmp eq ir<%indvars.iv.next397>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 354
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 354
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 74, RTCostB: 122
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 354
A is scalable.	B is not scalable.	
RTCostA: 1194, RTCostB: 74

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv396 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next397, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx102, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv400, i64 %indvars.iv396, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond399.not = icmp eq i64 %indvars.iv.next397, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond399.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 354
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 74
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv400>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv404 = phi %indvars.iv.next405, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv404>
    CLONE store ir<1317>, ir<%arrayidx117>
    CLONE ir<%indvars.iv.next405> = add nuw nsw ir<%indvars.iv404>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next405>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv404 = phi %indvars.iv.next405, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv404>
    vp<%3> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%indvars.iv.next405> = add nuw nsw ir<%indvars.iv404>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next405>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv404 = phi %indvars.iv.next405, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv404>
    vp<%3> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%indvars.iv.next405> = add nuw nsw ir<%indvars.iv404>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next405>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 232, RTCostB: 612
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 232, RTCostB: 612
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 118, RTCostB: 612
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 118, RTCostB: 232
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 612
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 118

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 118, RTCostB: 612
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 118, RTCostB: 118
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv404 = phi i64 [ %indvars.iv.next405, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv404 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx117, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next405 = add nuw nsw i64 %indvars.iv404, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next405, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond407.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 612
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 61, RTCostB: 118
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%4>, ir<1317>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv412 = phi 0, %indvars.iv.next413, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv412>
    CLONE store ir<1317>, ir<%arrayidx183>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv412>
    CLONE store ir<1317>, ir<%arrayidx185>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv412>
    CLONE store ir<1317>, ir<%arrayidx187>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv412>
    CLONE store ir<1317>, ir<%arrayidx189>
    CLONE ir<%indvars.iv.next413> = add nuw nsw ir<%indvars.iv412>, ir<1>
    CLONE ir<%exitcond415.not> = icmp eq ir<%indvars.iv.next413>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv412 = phi 0, %indvars.iv.next413, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv412>
    vp<%3> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv412>
    vp<%4> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv412>
    vp<%5> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv412>
    vp<%6> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%indvars.iv.next413> = add nuw nsw ir<%indvars.iv412>, ir<1>
    CLONE ir<%exitcond415.not> = icmp eq ir<%indvars.iv.next413>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv412 = phi 0, %indvars.iv.next413, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv412>
    vp<%3> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv412>
    vp<%4> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv412>
    vp<%5> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv412>
    vp<%6> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%indvars.iv.next413> = add nuw nsw ir<%indvars.iv412>, ir<1>
    CLONE ir<%exitcond415.not> = icmp eq ir<%indvars.iv.next413>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 184, RTCostB: 590
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 184, RTCostB: 590
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 590
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 184
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 590
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 114

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 590
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 114
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv412 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next413, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx183, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx185, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx187, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv412 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx189, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next413 = add nuw nsw i64 %indvars.iv412, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond415.not = icmp eq i64 %indvars.iv.next413, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond415.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 72, RTCostB: 590
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 72, RTCostB: 114
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%7>, ir<1317>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 44
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o params.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                params.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o predict.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                predict.c
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    CLONE ir<%4> = load ir<%count>
    CLONE ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%6>
}

========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    REPLICATE ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    REPLICATE ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}

========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    REPLICATE ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}

========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    WIDEN ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}


-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i64, ptr %count, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %4 = load i64, ptr %count, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 37580963813, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 37580963813, RTCostB: 17179869176

-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i64, ptr %count, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %4 = load i64, ptr %count, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24159191019, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 24159191019, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: counts_to_freqs at line: predict.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, vp<%4>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    CLONE ir<%4> = load ir<%count>
    CLONE ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>)
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o print-rtl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                print-rtl.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o print-tree.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                print-tree.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o profile.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                profile.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o real.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                real.c
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    CLONE ir<%9> = load ir<%arrayidx56>
    CLONE ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    CLONE ir<%10> = zext ir<%tobool57.not>
    CLONE ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    CLONE store ir<0>, ir<%arrayidx56>
    CLONE ir<%11> = trunc ir<%indvars.iv>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%6>
}

========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, %idxprom44\l" +
    "  ir<%11>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%5>, ir<0>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%8>
}

========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, %idxprom44\l" +
    "  ir<%11>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%5>, ir<0>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%8>
}


-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 13958643764, RTCostB: 19327352904
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 13958643764, RTCostB: 19327352904
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 19327352904
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 13958643764
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 19327352904
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 3758096398
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352904
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1879048199

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 19327352904
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 1879048199

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 19327352904
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 1879048199
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %9 = load i16, ptr %arrayidx56, align 2, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 0, ptr %arrayidx56, align 2, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 939524168, RTCostB: 19327352904
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 939524168, RTCostB: 1879048199
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 13958643764
A is not scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 3758096398
A is scalable.	B is not scalable.	
RTCostA: 3758096398, RTCostB: 1879048199
A is scalable.	B is not scalable.	
RTCostA: 1879048199, RTCostB: 1879048199
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: emdnorm at line: real.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: emdnorm at line: real.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    vp<%4>    = DERIVED-IV ir<%idxprom44> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%7> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%7>, ir<0>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%10>
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: emdnorm at line: real.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%11> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%bc.merge.rdx>, ir<%spec.select197>
    vp<%3>    = DERIVED-IV ir<%idxprom44> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%4>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%46> = load vp<%5>
    WIDEN ir<%tobool57.not> = icmp ne ir<%46>, ir<0>
    WIDEN-CAST ir<%47> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%47>
    vp<%6> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%6>, ir<0>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%10> = icmp eq ir<%11>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o recog.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                recog.c
@@ Instruction =>  store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: decode_asm_operands' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body329.us.us.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %57 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv608 = phi 0, %indvars.iv.next609, ir<1>
    CLONE ir<%58> = load ir<%arrayidx325>
    CLONE ir<%elem334.us.us.us> = getelementptr inbounds ir<%58>, ir<8>
    CLONE ir<%arrayidx336.us.us.us> = getelementptr inbounds ir<%elem334.us.us.us>, ir<0>, ir<%indvars.iv608>
    CLONE ir<%arrayidx338.us.us.us> = getelementptr inbounds ir<%operand_locs>, ir<%indvars.iv608>
    CLONE store ir<%arrayidx336.us.us.us>, ir<%arrayidx338.us.us.us>
    CLONE ir<%indvars.iv.next609> = add nuw nsw ir<%indvars.iv608>, ir<1>
    CLONE ir<%exitcond612.not> = icmp eq ir<%indvars.iv.next609>, ir<%wide.trip.count611>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end383.sink.split.loopexit661>, scalar.ph

ir-bb<if.end383.sink.split.loopexit661>:
No successors

scalar.ph:
No successors
}

========== Loop: decode_asm_operands' from recog.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body329.us.us.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %57 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv608 = phi 0, %indvars.iv.next609, ir<1>
    CLONE ir<%58> = load ir<%arrayidx325>
    WIDEN-GEP Var[Inv] ir<%elem334.us.us.us> = getelementptr inbounds ir<%58>, ir<8>
    WIDEN-GEP Var[Inv][Var] ir<%arrayidx336.us.us.us> = getelementptr inbounds ir<%elem334.us.us.us>, ir<0>, ir<%indvars.iv608>
    CLONE ir<%arrayidx338.us.us.us> = getelementptr inbounds ir<%operand_locs>, ir<%indvars.iv608>
    vp<%4> = vector-pointer ir<%arrayidx338.us.us.us>
    WIDEN store vp<%4>, ir<%arrayidx336.us.us.us>
    WIDEN ir<%indvars.iv.next609> = add nuw nsw ir<%indvars.iv608>, ir<1>
    CLONE ir<%exitcond612.not> = icmp eq ir<%indvars.iv.next609>, ir<%wide.trip.count611>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end383.sink.split.loopexit661>, scalar.ph

ir-bb<if.end383.sink.split.loopexit661>:
No successors

scalar.ph:
No successors
}

========== Loop: decode_asm_operands' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body329.us.us.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %57 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv608 = phi 0, %indvars.iv.next609, ir<1>
    CLONE ir<%58> = load ir<%arrayidx325>
    WIDEN-GEP Var[Inv] ir<%elem334.us.us.us> = getelementptr inbounds ir<%58>, ir<8>
    WIDEN-GEP Var[Inv][Var] ir<%arrayidx336.us.us.us> = getelementptr inbounds ir<%elem334.us.us.us>, ir<0>, ir<%indvars.iv608>
    CLONE ir<%arrayidx338.us.us.us> = getelementptr inbounds ir<%operand_locs>, ir<%indvars.iv608>
    vp<%4> = vector-pointer ir<%arrayidx338.us.us.us>
    WIDEN store vp<%4>, ir<%arrayidx336.us.us.us>
    WIDEN ir<%indvars.iv.next609> = add nuw nsw ir<%indvars.iv608>, ir<1>
    CLONE ir<%exitcond612.not> = icmp eq ir<%indvars.iv.next609>, ir<%wide.trip.count611>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end383.sink.split.loopexit661>, scalar.ph

ir-bb<if.end383.sink.split.loopexit661>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'decode_asm_operands' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv608 = phi i64 [ 0, %for.body329.us.us.us.preheader ], [ %indvars.iv.next609, %for.body329.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load ptr, ptr %arrayidx325, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %elem334.us.us.us = getelementptr inbounds i8, ptr %58, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx336.us.us.us = getelementptr inbounds [1 x ptr], ptr %elem334.us.us.us, i64 0, i64 %indvars.iv608 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx338.us.us.us = getelementptr inbounds ptr, ptr %operand_locs, i64 %indvars.iv608 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next609 = add nuw nsw i64 %indvars.iv608, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond612.not = icmp eq i64 %indvars.iv.next609, %wide.trip.count611 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond612.not, label %if.end383.sink.split.loopexit661, label %for.body329.us.us.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'decode_asm_operands' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv608 = phi i64 [ 0, %for.body329.us.us.us.preheader ], [ %indvars.iv.next609, %for.body329.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %58 = load ptr, ptr %arrayidx325, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %elem334.us.us.us = getelementptr inbounds i8, ptr %58, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx336.us.us.us = getelementptr inbounds [1 x ptr], ptr %elem334.us.us.us, i64 0, i64 %indvars.iv608 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx338.us.us.us = getelementptr inbounds ptr, ptr %operand_locs, i64 %indvars.iv608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next609 = add nuw nsw i64 %indvars.iv608, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond612.not = icmp eq i64 %indvars.iv.next609, %wide.trip.count611 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond612.not, label %if.end383.sink.split.loopexit661, label %for.body329.us.us.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709121, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709121, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'decode_asm_operands' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv608 = phi i64 [ 0, %for.body329.us.us.us.preheader ], [ %indvars.iv.next609, %for.body329.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %58 = load ptr, ptr %arrayidx325, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %elem334.us.us.us = getelementptr inbounds i8, ptr %58, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx336.us.us.us = getelementptr inbounds [1 x ptr], ptr %elem334.us.us.us, i64 0, i64 %indvars.iv608 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx338.us.us.us = getelementptr inbounds ptr, ptr %operand_locs, i64 %indvars.iv608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next609 = add nuw nsw i64 %indvars.iv608, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond612.not = icmp eq i64 %indvars.iv.next609, %wide.trip.count611 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond612.not, label %if.end383.sink.split.loopexit661, label %for.body329.us.us.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709121

-----------------Function that is being costed:'decode_asm_operands' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv608 = phi i64 [ 0, %for.body329.us.us.us.preheader ], [ %indvars.iv.next609, %for.body329.us.us.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %58 = load ptr, ptr %arrayidx325, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %elem334.us.us.us = getelementptr inbounds i8, ptr %58, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx336.us.us.us = getelementptr inbounds [1 x ptr], ptr %elem334.us.us.us, i64 0, i64 %indvars.iv608 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx338.us.us.us = getelementptr inbounds ptr, ptr %operand_locs, i64 %indvars.iv608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %arrayidx336.us.us.us, ptr %arrayidx338.us.us.us, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next609 = add nuw nsw i64 %indvars.iv608, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond612.not = icmp eq i64 %indvars.iv.next609, %wide.trip.count611 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond612.not, label %if.end383.sink.split.loopexit661, label %for.body329.us.us.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 5368709121
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: decode_asm_operands at line: recog.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body329.us.us.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %57 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv608 = phi 0, %indvars.iv.next609, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%59> = load ir<%arrayidx325>
    WIDEN-GEP Var[Inv] ir<%elem334.us.us.us> = getelementptr inbounds ir<%59>, ir<8>
    WIDEN-GEP Var[Inv][Var] ir<%arrayidx336.us.us.us> = getelementptr inbounds ir<%elem334.us.us.us>, ir<0>, ir<%indvars.iv608>
    CLONE ir<%arrayidx338.us.us.us> = getelementptr inbounds ir<%operand_locs>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx338.us.us.us>
    WIDEN store vp<%5>, ir<%arrayidx336.us.us.us>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end383.sink.split.loopexit661>, scalar.ph

ir-bb<if.end383.sink.split.loopexit661>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396559 to i64) + (-1 * (1 umin (zext i32 %cond396559 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv552 = phi %45, %indvars.iv.next553, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    CLONE ir<%indvars.iv.next553> = add nsw ir<%indvars.iv552>, ir<-1>
    CLONE ir<%46> = add nsw ir<%indvars.iv.next553>, ir<%idxprom209.lcssa>
    CLONE ir<%shl404> = shl nuw ir<1>, ir<%46>
    CLONE ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv552>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}

========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396559 to i64) + (-1 * (1 umin (zext i32 %cond396559 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv552 = phi %45, %indvars.iv.next553, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next553> = add nsw ir<%indvars.iv552>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next553>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv552>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}

========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396559 to i64) + (-1 * (1 umin (zext i32 %cond396559 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv552 = phi %45, %indvars.iv.next553, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next553> = add nsw ir<%indvars.iv552>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next553>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv552>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}


-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv552 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next553, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next553 = add nsw i64 %indvars.iv552, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %46 = add nsw i64 %indvars.iv.next553, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv552, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv552 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next553, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next553 = add nsw i64 %indvars.iv552, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %46 = add nsw i64 %indvars.iv.next553, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv552, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv552 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next553, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next553 = add nsw i64 %indvars.iv552, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %46 = add nsw i64 %indvars.iv.next553, %idxprom209.lcssa of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv552, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv552 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next553, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next553 = add nsw i64 %indvars.iv552, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %46 = add nsw i64 %indvars.iv.next553, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv552, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: peep2_find_free_register at line: recog.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396559 to i64) + (-1 * (1 umin (zext i32 %cond396559 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv552 = phi %45, %indvars.iv.next553, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next553> = add nsw ir<%indvars.iv552>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next553>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 38
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o reg-stack.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                reg-stack.c
========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    CLONE ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and> = and ir<%3>, ir<%not>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}

========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}

========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}


-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 10737418240
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418240
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709120

-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 10737418240
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709120
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: subst_stack_regs at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 50
Loops Epilogues Vectorized: 0
================================================
MVT: v2i32
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    CLONE ir<%3> = trunc ir<%indvars.iv>
    CLONE ir<%sub> = sub ir<%add>, ir<%3>
    CLONE ir<%conv> = trunc ir<%sub>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%conv>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 10737418240
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 10737418240
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952790016, RTCostB: 10737418240
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952790016, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 3 for VF 16 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2550136832, RTCostB: 10737418240
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2550136832, RTCostB: 2952790016
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418240
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2550136832

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 10737418240
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2550136832

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612736, RTCostB: 10737418240
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612736, RTCostB: 2550136832
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 10737418240
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177280, RTCostB: 1610612736
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %conv, ptr %arrayidx, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1207959552, RTCostB: 10737418240
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1207959552, RTCostB: 1342177280
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934592
A is not scalable.	B is not scalable.	
RTCostA: 2952790016, RTCostB: 4294967296
A is not scalable.	B is not scalable.	
RTCostA: 2550136832, RTCostB: 2952790016
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2550136832
A is scalable.	B is not scalable.	
RTCostA: 1610612736, RTCostB: 2550136832
A is scalable.	B is scalable.	
RTCostA: 1342177280, RTCostB: 1610612736
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: straighten_stack at line: reg-stack.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=1 at function: straighten_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    vp<%4>    = DERIVED-IV ir<%2> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<%conv>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: straighten_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%3> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%30>, ir<-1>
    vp<%3>    = DERIVED-IV ir<%2> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%30>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<%conv>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%3>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 58
Loops Epilogues Vectorized: 1
================================================
MVT: nxv16i8
MVT: nxv8i16
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%4> = load ir<%arrayidx20>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx23>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %4 = load i8, ptr %arrayidx20, align 1, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %4, ptr %arrayidx23, align 1, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: pop_stack at line: reg-stack.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: pop_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom8.lcssa> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%6>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%7>, ir<%4>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: pop_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%4> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%idxprom8.lcssa> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%4>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%34> = load vp<%5>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%6>, ir<%34>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%4>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 91
Loops Epilogues Vectorized: 2
================================================
MVT: nxv8i16
MVT: nxv8i16
MVT: nxv16i8
MVT: nxv16i8
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o regclass.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                regclass.c
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%conv> = zext ir<%1>
    CLONE ir<%and2> = and ir<%cond>, ir<%conv>
    CLONE ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    CLONE ir<%conv5> = zext ir<%cmp3>
    CLONE store ir<%conv5>, ir<%arrayidx>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx9>
    CLONE ir<%conv10> = zext ir<%2>
    CLONE ir<%and14> = and ir<%cond>, ir<%conv10>
    CLONE ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    CLONE ir<%conv17> = zext ir<%cmp15>
    CLONE store ir<%conv17>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%3>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%5>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%conv17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%3>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%5>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%conv17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 13
A is not scalable.	B is not scalable.	
RTCostA: 690, RTCostB: 742
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 690, RTCostB: 742
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 248, RTCostB: 742
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 248, RTCostB: 690
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 3 for VF 8 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 3 for VF 8 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 202, RTCostB: 742
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 202, RTCostB: 248
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 6 for VF 16 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 6 for VF 16 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 178, RTCostB: 742
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 178, RTCostB: 202
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 742
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 178

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 742
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 178

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 142, RTCostB: 742
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 142, RTCostB: 178
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 124, RTCostB: 742
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 124, RTCostB: 142
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %1 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 6 for VF vscale x 16 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %conv5, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %2 = load i8, ptr %arrayidx9, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 6 for VF vscale x 16 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 330, RTCostB: 742
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 330, RTCostB: 124
LV: Selecting VF: vscale x 8 With Cost: 1.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 248, RTCostB: 690
A is not scalable.	B is not scalable.	
RTCostA: 202, RTCostB: 248
A is scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 202
A is scalable.	B is scalable.	
RTCostA: 142, RTCostB: 196
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: init_reg_sets_1 at line: regclass.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%6>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%7> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%7>, ir<%conv17>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%23> = load vp<%4>
    WIDEN-CAST ir<%conv> = zext  ir<%23> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%24> = load vp<%6>
    WIDEN-CAST ir<%conv10> = zext  ir<%24> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%7> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%7>, ir<%conv17>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv969>
    CLONE ir<%and53> = and ir<%47>, ir<%shl>
    CLONE ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv969>
    CLONE store ir<1>, ir<%arrayidx57>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv969>
    CLONE store ir<1>, ir<%arrayidx59>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%4> = or ir<%tobool54.not>, vp<%3>
    CLONE ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond972.not> = icmp eq ir<%indvars.iv.next970>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv969>
    WIDEN ir<%and53> = and ir<%47>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv969>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv969>
    vp<%5> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%6> = or ir<%tobool54.not>, vp<%3>
    WIDEN ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond972.not> = icmp eq ir<%indvars.iv.next970>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv969>
    WIDEN ir<%and53> = and ir<%47>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv969>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv969>
    vp<%5> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%6> = or ir<%tobool54.not>, vp<%3>
    WIDEN ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond972.not> = icmp eq ir<%indvars.iv.next970>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 4 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 8 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 16 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 87, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 87, RTCostB: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next970, %for.inc61 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv969 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %and53 = and i64 %47, %shl of type:and
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx57, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx59, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond972.not = icmp eq i64 %indvars.iv.next970, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond972.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 16 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 161, RTCostB: 87
LV: Selecting VF: vscale x 8 With Cost: 1.
maxbefore: 2
maxafter: 2
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: init_reg_sets_1 at line: regclass.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    vp<%4> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, vp<%3>
    WIDEN ir<%and53> = and ir<%47>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
    EMIT vp<%5> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%6>, ir<1>, vp<%5>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%7>, ir<1>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv969>
    WIDEN ir<%and53> = and ir<%47>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
    EMIT vp<%4> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv973 = phi 0, %indvars.iv.next974, ir<1>
    CLONE ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv973>
    CLONE ir<%and76> = and ir<%94>, ir<%shl75>
    CLONE ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv973>
    CLONE store ir<1>, ir<%arrayidx80>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv973>
    CLONE store ir<1>, ir<%arrayidx82>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = or ir<%tobool77.not>, vp<%3>
    CLONE ir<%indvars.iv.next974> = add nuw nsw ir<%indvars.iv973>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next974>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv973 = phi 0, %indvars.iv.next974, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv973>
    WIDEN ir<%and76> = and ir<%94>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv973>
    vp<%4> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv973>
    vp<%5> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%6> = or ir<%tobool77.not>, vp<%3>
    WIDEN ir<%indvars.iv.next974> = add nuw nsw ir<%indvars.iv973>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next974>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv973 = phi 0, %indvars.iv.next974, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv973>
    WIDEN ir<%and76> = and ir<%94>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv973>
    vp<%4> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv973>
    vp<%5> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%6> = or ir<%tobool77.not>, vp<%3>
    WIDEN ir<%indvars.iv.next974> = add nuw nsw ir<%indvars.iv973>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next974>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 4 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 8 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 16 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 87, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 87, RTCostB: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv973 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next974, %for.inc84 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv973 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %and76 = and i64 %94, %shl75 of type:and
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx80, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv973 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx82, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next974 = add nuw nsw i64 %indvars.iv973, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next974, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond976.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 16 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 161, RTCostB: 87
LV: Selecting VF: vscale x 8 With Cost: 1.
maxbefore: 2
maxafter: 2
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: init_reg_sets_1 at line: regclass.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv973 = phi 0, %indvars.iv.next974, ir<1>
    vp<%4> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, vp<%3>
    WIDEN ir<%and76> = and ir<%94>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
    EMIT vp<%5> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%6>, ir<1>, vp<%5>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%7>, ir<1>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv973 = phi 0, %indvars.iv.next974, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv973>
    WIDEN ir<%and76> = and ir<%94>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
    EMIT vp<%4> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv977 = phi 0, %indvars.iv.next978, ir<1>
    CLONE ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv977>
    CLONE ir<%and100> = and ir<%shl99>, ir<%142>
    CLONE ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv977>
    CLONE store ir<1>, ir<%arrayidx104>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv977>
    CLONE store ir<1>, ir<%arrayidx106>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%4> = or ir<%tobool101.not>, vp<%3>
    CLONE ir<%indvars.iv.next978> = add nuw nsw ir<%indvars.iv977>, ir<1>
    CLONE ir<%exitcond980.not> = icmp eq ir<%indvars.iv.next978>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv977 = phi 0, %indvars.iv.next978, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv977>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%142>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv977>
    vp<%4> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv977>
    vp<%5> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%6> = or ir<%tobool101.not>, vp<%3>
    WIDEN ir<%indvars.iv.next978> = add nuw nsw ir<%indvars.iv977>, ir<1>
    CLONE ir<%exitcond980.not> = icmp eq ir<%indvars.iv.next978>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv977 = phi 0, %indvars.iv.next978, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv977>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%142>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv977>
    vp<%4> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv977>
    vp<%5> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%6> = or ir<%tobool101.not>, vp<%3>
    WIDEN ir<%indvars.iv.next978> = add nuw nsw ir<%indvars.iv977>, ir<1>
    CLONE ir<%exitcond980.not> = icmp eq ir<%indvars.iv.next978>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 656, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 4 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 643, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 8 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 612, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 16 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 609, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 87, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 87, RTCostB: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv977 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next978, %for.inc108 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv977 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %and100 = and i64 %shl99, %142 of type:and
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx104, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv977 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx106, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next978 = add nuw nsw i64 %indvars.iv977, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond980.not = icmp eq i64 %indvars.iv.next978, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond980.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 16 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 161, RTCostB: 87
LV: Selecting VF: vscale x 8 With Cost: 1.
maxbefore: 2
maxafter: 2
A is scalable.	B is scalable.	
RTCostA: 96, RTCostB: 97
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: init_reg_sets_1 at line: regclass.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv977 = phi 0, %indvars.iv.next978, ir<1>
    vp<%4> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, vp<%3>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%142>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
    EMIT vp<%5> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%6>, ir<1>, vp<%5>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%7>, ir<1>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv977 = phi 0, %indvars.iv.next978, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv977>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%142>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
    EMIT vp<%4> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%97>
    WIDEN-INDUCTION %indvars.iv1005 = phi 0, %indvars.iv.next1006, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv1005>
    CLONE ir<%222> = load ir<%arrayidx200>
    CLONE ir<%or201> = or ir<%222>, ir<%221>
    CLONE ir<%and209> = and ir<%or201>, ir<%not208>
    CLONE ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%3> = not ir<%cmp210>
    CLONE ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    CLONE ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%4> = not ir<%cmp210.1>
    EMIT vp<%5> = logical-and vp<%3>, vp<%4>
    CLONE ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    CLONE ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%6> = not ir<%cmp210.2>
    EMIT vp<%7> = logical-and vp<%5>, vp<%6>
    CLONE ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    CLONE ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%8> = not ir<%cmp210.3>
    EMIT vp<%9> = logical-and vp<%7>, vp<%8>
    CLONE ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    CLONE ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%10> = not ir<%cmp210.4>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    CLONE ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%12> = not ir<%cmp210.5>
    EMIT vp<%13> = logical-and vp<%11>, vp<%12>
    CLONE ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    CLONE ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%14> = not ir<%cmp210.6>
    EMIT vp<%15> = logical-and vp<%13>, vp<%14>
    CLONE ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    CLONE ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%16> = not ir<%cmp210.7>
    EMIT vp<%17> = logical-and vp<%15>, vp<%16>
    CLONE ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    CLONE ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%18> = not ir<%cmp210.8>
    EMIT vp<%19> = logical-and vp<%17>, vp<%18>
    CLONE ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    CLONE ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%20> = not ir<%cmp210.9>
    EMIT vp<%21> = logical-and vp<%19>, vp<%20>
    CLONE ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    CLONE ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%22> = not ir<%cmp210.10>
    EMIT vp<%23> = logical-and vp<%21>, vp<%22>
    CLONE ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    CLONE ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%24> = not ir<%cmp210.11>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    CLONE ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    CLONE ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%26> = not ir<%cmp210.12>
    EMIT vp<%27> = logical-and vp<%25>, vp<%26>
    CLONE ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    CLONE ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%28> = not ir<%cmp210.13>
    EMIT vp<%29> = logical-and vp<%27>, vp<%28>
    CLONE ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    CLONE ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%30> = not ir<%cmp210.14>
    EMIT vp<%31> = logical-and vp<%29>, vp<%30>
    CLONE ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    CLONE ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%32> = not ir<%cmp210.15>
    EMIT vp<%33> = logical-and vp<%31>, vp<%32>
    CLONE ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    CLONE ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%34> = not ir<%cmp210.16>
    EMIT vp<%35> = logical-and vp<%33>, vp<%34>
    CLONE ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    CLONE ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%36> = not ir<%cmp210.17>
    EMIT vp<%37> = logical-and vp<%35>, vp<%36>
    CLONE ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    CLONE ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%38> = not ir<%cmp210.18>
    EMIT vp<%39> = logical-and vp<%37>, vp<%38>
    CLONE ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    CLONE ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%40> = not ir<%cmp210.19>
    EMIT vp<%41> = logical-and vp<%39>, vp<%40>
    CLONE ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    CLONE ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%42> = not ir<%cmp210.20>
    EMIT vp<%43> = logical-and vp<%41>, vp<%42>
    CLONE ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    CLONE ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%44> = not ir<%cmp210.21>
    EMIT vp<%45> = logical-and vp<%43>, vp<%44>
    CLONE ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    CLONE ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%46> = not ir<%cmp210.22>
    EMIT vp<%47> = logical-and vp<%45>, vp<%46>
    CLONE ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    CLONE ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%48> = not ir<%cmp210.23>
    EMIT vp<%49> = logical-and vp<%47>, vp<%48>
    CLONE ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    CLONE ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    CLONE ir<%spec.select1224> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%50> = logical-and vp<%47>, ir<%cmp210.23>
    EMIT vp<%51> = or vp<%49>, vp<%50>
    EMIT vp<%52> = logical-and vp<%45>, ir<%cmp210.22>
    EMIT vp<%53> = or vp<%51>, vp<%52>
    EMIT vp<%54> = logical-and vp<%43>, ir<%cmp210.21>
    EMIT vp<%55> = or vp<%53>, vp<%54>
    EMIT vp<%56> = logical-and vp<%41>, ir<%cmp210.20>
    EMIT vp<%57> = or vp<%55>, vp<%56>
    EMIT vp<%58> = logical-and vp<%39>, ir<%cmp210.19>
    EMIT vp<%59> = or vp<%57>, vp<%58>
    EMIT vp<%60> = logical-and vp<%37>, ir<%cmp210.18>
    EMIT vp<%61> = or vp<%59>, vp<%60>
    EMIT vp<%62> = logical-and vp<%35>, ir<%cmp210.17>
    EMIT vp<%63> = or vp<%61>, vp<%62>
    EMIT vp<%64> = logical-and vp<%33>, ir<%cmp210.16>
    EMIT vp<%65> = or vp<%63>, vp<%64>
    EMIT vp<%66> = logical-and vp<%31>, ir<%cmp210.15>
    EMIT vp<%67> = or vp<%65>, vp<%66>
    EMIT vp<%68> = logical-and vp<%29>, ir<%cmp210.14>
    EMIT vp<%69> = or vp<%67>, vp<%68>
    EMIT vp<%70> = logical-and vp<%27>, ir<%cmp210.13>
    EMIT vp<%71> = or vp<%69>, vp<%70>
    EMIT vp<%72> = logical-and vp<%25>, ir<%cmp210.12>
    EMIT vp<%73> = or vp<%71>, vp<%72>
    EMIT vp<%74> = logical-and vp<%23>, ir<%cmp210.11>
    EMIT vp<%75> = or vp<%73>, vp<%74>
    EMIT vp<%76> = logical-and vp<%21>, ir<%cmp210.10>
    EMIT vp<%77> = or vp<%75>, vp<%76>
    EMIT vp<%78> = logical-and vp<%19>, ir<%cmp210.9>
    EMIT vp<%79> = or vp<%77>, vp<%78>
    EMIT vp<%80> = logical-and vp<%17>, ir<%cmp210.8>
    EMIT vp<%81> = or vp<%79>, vp<%80>
    EMIT vp<%82> = logical-and vp<%15>, ir<%cmp210.7>
    EMIT vp<%83> = or vp<%81>, vp<%82>
    EMIT vp<%84> = logical-and vp<%13>, ir<%cmp210.6>
    EMIT vp<%85> = or vp<%83>, vp<%84>
    EMIT vp<%86> = logical-and vp<%11>, ir<%cmp210.5>
    EMIT vp<%87> = or vp<%85>, vp<%86>
    EMIT vp<%88> = logical-and vp<%9>, ir<%cmp210.4>
    EMIT vp<%89> = or vp<%87>, vp<%88>
    EMIT vp<%90> = logical-and vp<%7>, ir<%cmp210.3>
    EMIT vp<%91> = or vp<%89>, vp<%90>
    EMIT vp<%92> = logical-and vp<%5>, ir<%cmp210.2>
    EMIT vp<%93> = or vp<%91>, vp<%92>
    EMIT vp<%94> = logical-and vp<%3>, ir<%cmp210.1>
    EMIT vp<%95> = or vp<%93>, vp<%94>
    EMIT vp<%96> = or vp<%95>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%94> ir<2>/vp<%92> ir<3>/vp<%90> ir<4>/vp<%88> ir<5>/vp<%86> ir<6>/vp<%84> ir<7>/vp<%82> ir<8>/vp<%80> ir<9>/vp<%78> ir<10>/vp<%76> ir<11>/vp<%74> ir<12>/vp<%72> ir<13>/vp<%70> ir<14>/vp<%68> ir<15>/vp<%66> ir<16>/vp<%64> ir<17>/vp<%62> ir<18>/vp<%60> ir<19>/vp<%58> ir<20>/vp<%56> ir<21>/vp<%54> ir<22>/vp<%52> ir<23>/vp<%50> ir<%spec.select1224>/vp<%49>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv1009>, ir<%indvars.iv1005>
    CLONE store ir<%k196.0.lcssa>, ir<%arrayidx220>
    CLONE ir<%indvars.iv.next1006> = add nuw nsw ir<%indvars.iv1005>, ir<1>
    CLONE ir<%exitcond1008.not> = icmp eq ir<%indvars.iv.next1006>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%97> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%97>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%99> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%99>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%99>
    WIDEN-INDUCTION %indvars.iv1005 = phi 0, %indvars.iv.next1006, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv1005>
    vp<%3> = vector-pointer ir<%arrayidx200>
    WIDEN ir<%222> = load vp<%3>
    WIDEN ir<%or201> = or ir<%222>, ir<%221>
    WIDEN ir<%and209> = and ir<%or201>, ir<%not208>
    WIDEN ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%4> = not ir<%cmp210>
    WIDEN ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    WIDEN ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%5> = not ir<%cmp210.1>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    WIDEN ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%7> = not ir<%cmp210.2>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    WIDEN ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    WIDEN ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%9> = not ir<%cmp210.3>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    WIDEN ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    WIDEN ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%11> = not ir<%cmp210.4>
    EMIT vp<%12> = logical-and vp<%10>, vp<%11>
    WIDEN ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    WIDEN ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%13> = not ir<%cmp210.5>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    WIDEN ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    WIDEN ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%15> = not ir<%cmp210.6>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    WIDEN ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    WIDEN ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%17> = not ir<%cmp210.7>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    WIDEN ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    WIDEN ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%19> = not ir<%cmp210.8>
    EMIT vp<%20> = logical-and vp<%18>, vp<%19>
    WIDEN ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    WIDEN ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%21> = not ir<%cmp210.9>
    EMIT vp<%22> = logical-and vp<%20>, vp<%21>
    WIDEN ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    WIDEN ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%23> = not ir<%cmp210.10>
    EMIT vp<%24> = logical-and vp<%22>, vp<%23>
    WIDEN ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    WIDEN ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%25> = not ir<%cmp210.11>
    EMIT vp<%26> = logical-and vp<%24>, vp<%25>
    WIDEN ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    WIDEN ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%27> = not ir<%cmp210.12>
    EMIT vp<%28> = logical-and vp<%26>, vp<%27>
    WIDEN ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    WIDEN ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%29> = not ir<%cmp210.13>
    EMIT vp<%30> = logical-and vp<%28>, vp<%29>
    WIDEN ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    WIDEN ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%31> = not ir<%cmp210.14>
    EMIT vp<%32> = logical-and vp<%30>, vp<%31>
    WIDEN ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    WIDEN ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%33> = not ir<%cmp210.15>
    EMIT vp<%34> = logical-and vp<%32>, vp<%33>
    WIDEN ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    WIDEN ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%35> = not ir<%cmp210.16>
    EMIT vp<%36> = logical-and vp<%34>, vp<%35>
    WIDEN ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    WIDEN ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%37> = not ir<%cmp210.17>
    EMIT vp<%38> = logical-and vp<%36>, vp<%37>
    WIDEN ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    WIDEN ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%39> = not ir<%cmp210.18>
    EMIT vp<%40> = logical-and vp<%38>, vp<%39>
    WIDEN ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    WIDEN ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%41> = not ir<%cmp210.19>
    EMIT vp<%42> = logical-and vp<%40>, vp<%41>
    WIDEN ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    WIDEN ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%43> = not ir<%cmp210.20>
    EMIT vp<%44> = logical-and vp<%42>, vp<%43>
    WIDEN ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    WIDEN ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%45> = not ir<%cmp210.21>
    EMIT vp<%46> = logical-and vp<%44>, vp<%45>
    WIDEN ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    WIDEN ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%47> = not ir<%cmp210.22>
    EMIT vp<%48> = logical-and vp<%46>, vp<%47>
    WIDEN ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    WIDEN ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%49> = not ir<%cmp210.23>
    EMIT vp<%50> = logical-and vp<%48>, vp<%49>
    WIDEN ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    WIDEN ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    WIDEN-SELECT ir<%spec.select1224> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%51> = logical-and vp<%48>, ir<%cmp210.23>
    EMIT vp<%52> = or vp<%50>, vp<%51>
    EMIT vp<%53> = logical-and vp<%46>, ir<%cmp210.22>
    EMIT vp<%54> = or vp<%52>, vp<%53>
    EMIT vp<%55> = logical-and vp<%44>, ir<%cmp210.21>
    EMIT vp<%56> = or vp<%54>, vp<%55>
    EMIT vp<%57> = logical-and vp<%42>, ir<%cmp210.20>
    EMIT vp<%58> = or vp<%56>, vp<%57>
    EMIT vp<%59> = logical-and vp<%40>, ir<%cmp210.19>
    EMIT vp<%60> = or vp<%58>, vp<%59>
    EMIT vp<%61> = logical-and vp<%38>, ir<%cmp210.18>
    EMIT vp<%62> = or vp<%60>, vp<%61>
    EMIT vp<%63> = logical-and vp<%36>, ir<%cmp210.17>
    EMIT vp<%64> = or vp<%62>, vp<%63>
    EMIT vp<%65> = logical-and vp<%34>, ir<%cmp210.16>
    EMIT vp<%66> = or vp<%64>, vp<%65>
    EMIT vp<%67> = logical-and vp<%32>, ir<%cmp210.15>
    EMIT vp<%68> = or vp<%66>, vp<%67>
    EMIT vp<%69> = logical-and vp<%30>, ir<%cmp210.14>
    EMIT vp<%70> = or vp<%68>, vp<%69>
    EMIT vp<%71> = logical-and vp<%28>, ir<%cmp210.13>
    EMIT vp<%72> = or vp<%70>, vp<%71>
    EMIT vp<%73> = logical-and vp<%26>, ir<%cmp210.12>
    EMIT vp<%74> = or vp<%72>, vp<%73>
    EMIT vp<%75> = logical-and vp<%24>, ir<%cmp210.11>
    EMIT vp<%76> = or vp<%74>, vp<%75>
    EMIT vp<%77> = logical-and vp<%22>, ir<%cmp210.10>
    EMIT vp<%78> = or vp<%76>, vp<%77>
    EMIT vp<%79> = logical-and vp<%20>, ir<%cmp210.9>
    EMIT vp<%80> = or vp<%78>, vp<%79>
    EMIT vp<%81> = logical-and vp<%18>, ir<%cmp210.8>
    EMIT vp<%82> = or vp<%80>, vp<%81>
    EMIT vp<%83> = logical-and vp<%16>, ir<%cmp210.7>
    EMIT vp<%84> = or vp<%82>, vp<%83>
    EMIT vp<%85> = logical-and vp<%14>, ir<%cmp210.6>
    EMIT vp<%86> = or vp<%84>, vp<%85>
    EMIT vp<%87> = logical-and vp<%12>, ir<%cmp210.5>
    EMIT vp<%88> = or vp<%86>, vp<%87>
    EMIT vp<%89> = logical-and vp<%10>, ir<%cmp210.4>
    EMIT vp<%90> = or vp<%88>, vp<%89>
    EMIT vp<%91> = logical-and vp<%8>, ir<%cmp210.3>
    EMIT vp<%92> = or vp<%90>, vp<%91>
    EMIT vp<%93> = logical-and vp<%6>, ir<%cmp210.2>
    EMIT vp<%94> = or vp<%92>, vp<%93>
    EMIT vp<%95> = logical-and vp<%4>, ir<%cmp210.1>
    EMIT vp<%96> = or vp<%94>, vp<%95>
    EMIT vp<%97> = or vp<%96>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%95> ir<2>/vp<%93> ir<3>/vp<%91> ir<4>/vp<%89> ir<5>/vp<%87> ir<6>/vp<%85> ir<7>/vp<%83> ir<8>/vp<%81> ir<9>/vp<%79> ir<10>/vp<%77> ir<11>/vp<%75> ir<12>/vp<%73> ir<13>/vp<%71> ir<14>/vp<%69> ir<15>/vp<%67> ir<16>/vp<%65> ir<17>/vp<%63> ir<18>/vp<%61> ir<19>/vp<%59> ir<20>/vp<%57> ir<21>/vp<%55> ir<22>/vp<%53> ir<23>/vp<%51> ir<%spec.select1224>/vp<%50>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv1009>, ir<%indvars.iv1005>
    vp<%98> = vector-pointer ir<%arrayidx220>
    WIDEN store vp<%98>, ir<%k196.0.lcssa>
    CLONE ir<%indvars.iv.next1006> = add nuw nsw ir<%indvars.iv1005>, ir<1>
    CLONE ir<%exitcond1008.not> = icmp eq ir<%indvars.iv.next1006>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%99> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%99>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%101> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%101>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%99>
    WIDEN-INDUCTION %indvars.iv1005 = phi 0, %indvars.iv.next1006, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv1005>
    vp<%3> = vector-pointer ir<%arrayidx200>
    WIDEN ir<%222> = load vp<%3>
    WIDEN ir<%or201> = or ir<%222>, ir<%221>
    WIDEN ir<%and209> = and ir<%or201>, ir<%not208>
    WIDEN ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%4> = not ir<%cmp210>
    WIDEN ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    WIDEN ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%5> = not ir<%cmp210.1>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    WIDEN ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%7> = not ir<%cmp210.2>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    WIDEN ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    WIDEN ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%9> = not ir<%cmp210.3>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    WIDEN ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    WIDEN ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%11> = not ir<%cmp210.4>
    EMIT vp<%12> = logical-and vp<%10>, vp<%11>
    WIDEN ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    WIDEN ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%13> = not ir<%cmp210.5>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    WIDEN ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    WIDEN ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%15> = not ir<%cmp210.6>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    WIDEN ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    WIDEN ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%17> = not ir<%cmp210.7>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    WIDEN ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    WIDEN ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%19> = not ir<%cmp210.8>
    EMIT vp<%20> = logical-and vp<%18>, vp<%19>
    WIDEN ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    WIDEN ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%21> = not ir<%cmp210.9>
    EMIT vp<%22> = logical-and vp<%20>, vp<%21>
    WIDEN ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    WIDEN ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%23> = not ir<%cmp210.10>
    EMIT vp<%24> = logical-and vp<%22>, vp<%23>
    WIDEN ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    WIDEN ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%25> = not ir<%cmp210.11>
    EMIT vp<%26> = logical-and vp<%24>, vp<%25>
    WIDEN ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    WIDEN ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%27> = not ir<%cmp210.12>
    EMIT vp<%28> = logical-and vp<%26>, vp<%27>
    WIDEN ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    WIDEN ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%29> = not ir<%cmp210.13>
    EMIT vp<%30> = logical-and vp<%28>, vp<%29>
    WIDEN ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    WIDEN ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%31> = not ir<%cmp210.14>
    EMIT vp<%32> = logical-and vp<%30>, vp<%31>
    WIDEN ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    WIDEN ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%33> = not ir<%cmp210.15>
    EMIT vp<%34> = logical-and vp<%32>, vp<%33>
    WIDEN ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    WIDEN ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%35> = not ir<%cmp210.16>
    EMIT vp<%36> = logical-and vp<%34>, vp<%35>
    WIDEN ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    WIDEN ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%37> = not ir<%cmp210.17>
    EMIT vp<%38> = logical-and vp<%36>, vp<%37>
    WIDEN ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    WIDEN ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%39> = not ir<%cmp210.18>
    EMIT vp<%40> = logical-and vp<%38>, vp<%39>
    WIDEN ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    WIDEN ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%41> = not ir<%cmp210.19>
    EMIT vp<%42> = logical-and vp<%40>, vp<%41>
    WIDEN ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    WIDEN ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%43> = not ir<%cmp210.20>
    EMIT vp<%44> = logical-and vp<%42>, vp<%43>
    WIDEN ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    WIDEN ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%45> = not ir<%cmp210.21>
    EMIT vp<%46> = logical-and vp<%44>, vp<%45>
    WIDEN ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    WIDEN ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%47> = not ir<%cmp210.22>
    EMIT vp<%48> = logical-and vp<%46>, vp<%47>
    WIDEN ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    WIDEN ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%49> = not ir<%cmp210.23>
    EMIT vp<%50> = logical-and vp<%48>, vp<%49>
    WIDEN ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    WIDEN ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    WIDEN-SELECT ir<%spec.select1224> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%51> = logical-and vp<%48>, ir<%cmp210.23>
    EMIT vp<%52> = or vp<%50>, vp<%51>
    EMIT vp<%53> = logical-and vp<%46>, ir<%cmp210.22>
    EMIT vp<%54> = or vp<%52>, vp<%53>
    EMIT vp<%55> = logical-and vp<%44>, ir<%cmp210.21>
    EMIT vp<%56> = or vp<%54>, vp<%55>
    EMIT vp<%57> = logical-and vp<%42>, ir<%cmp210.20>
    EMIT vp<%58> = or vp<%56>, vp<%57>
    EMIT vp<%59> = logical-and vp<%40>, ir<%cmp210.19>
    EMIT vp<%60> = or vp<%58>, vp<%59>
    EMIT vp<%61> = logical-and vp<%38>, ir<%cmp210.18>
    EMIT vp<%62> = or vp<%60>, vp<%61>
    EMIT vp<%63> = logical-and vp<%36>, ir<%cmp210.17>
    EMIT vp<%64> = or vp<%62>, vp<%63>
    EMIT vp<%65> = logical-and vp<%34>, ir<%cmp210.16>
    EMIT vp<%66> = or vp<%64>, vp<%65>
    EMIT vp<%67> = logical-and vp<%32>, ir<%cmp210.15>
    EMIT vp<%68> = or vp<%66>, vp<%67>
    EMIT vp<%69> = logical-and vp<%30>, ir<%cmp210.14>
    EMIT vp<%70> = or vp<%68>, vp<%69>
    EMIT vp<%71> = logical-and vp<%28>, ir<%cmp210.13>
    EMIT vp<%72> = or vp<%70>, vp<%71>
    EMIT vp<%73> = logical-and vp<%26>, ir<%cmp210.12>
    EMIT vp<%74> = or vp<%72>, vp<%73>
    EMIT vp<%75> = logical-and vp<%24>, ir<%cmp210.11>
    EMIT vp<%76> = or vp<%74>, vp<%75>
    EMIT vp<%77> = logical-and vp<%22>, ir<%cmp210.10>
    EMIT vp<%78> = or vp<%76>, vp<%77>
    EMIT vp<%79> = logical-and vp<%20>, ir<%cmp210.9>
    EMIT vp<%80> = or vp<%78>, vp<%79>
    EMIT vp<%81> = logical-and vp<%18>, ir<%cmp210.8>
    EMIT vp<%82> = or vp<%80>, vp<%81>
    EMIT vp<%83> = logical-and vp<%16>, ir<%cmp210.7>
    EMIT vp<%84> = or vp<%82>, vp<%83>
    EMIT vp<%85> = logical-and vp<%14>, ir<%cmp210.6>
    EMIT vp<%86> = or vp<%84>, vp<%85>
    EMIT vp<%87> = logical-and vp<%12>, ir<%cmp210.5>
    EMIT vp<%88> = or vp<%86>, vp<%87>
    EMIT vp<%89> = logical-and vp<%10>, ir<%cmp210.4>
    EMIT vp<%90> = or vp<%88>, vp<%89>
    EMIT vp<%91> = logical-and vp<%8>, ir<%cmp210.3>
    EMIT vp<%92> = or vp<%90>, vp<%91>
    EMIT vp<%93> = logical-and vp<%6>, ir<%cmp210.2>
    EMIT vp<%94> = or vp<%92>, vp<%93>
    EMIT vp<%95> = logical-and vp<%4>, ir<%cmp210.1>
    EMIT vp<%96> = or vp<%94>, vp<%95>
    EMIT vp<%97> = or vp<%96>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%95> ir<2>/vp<%93> ir<3>/vp<%91> ir<4>/vp<%89> ir<5>/vp<%87> ir<6>/vp<%85> ir<7>/vp<%83> ir<8>/vp<%81> ir<9>/vp<%79> ir<10>/vp<%77> ir<11>/vp<%75> ir<12>/vp<%73> ir<13>/vp<%71> ir<14>/vp<%69> ir<15>/vp<%67> ir<16>/vp<%65> ir<17>/vp<%63> ir<18>/vp<%61> ir<19>/vp<%59> ir<20>/vp<%57> ir<21>/vp<%55> ir<22>/vp<%53> ir<23>/vp<%51> ir<%spec.select1224>/vp<%50>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv1009>, ir<%indvars.iv1005>
    vp<%98> = vector-pointer ir<%arrayidx220>
    WIDEN store vp<%98>, ir<%k196.0.lcssa>
    CLONE ir<%indvars.iv.next1006> = add nuw nsw ir<%indvars.iv1005>, ir<1>
    CLONE ir<%exitcond1008.not> = icmp eq ir<%indvars.iv.next1006>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%99> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%99>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%101> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%101>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1005 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next1006, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv1005 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or201 = or i64 %222, %221 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1224 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1224, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv1009, i64 %indvars.iv1005 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1006 = add nuw nsw i64 %indvars.iv1005, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1008.not = icmp eq i64 %indvars.iv.next1006, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1008.not, label %for.inc224, label %for.body194 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1005 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next1006, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or201 = or i64 %222, %221 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1224 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 144 for VF 2 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1224, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv1009, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1006 = add nuw nsw i64 %indvars.iv1005, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1008.not = icmp eq i64 %indvars.iv.next1006, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1008.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width 2 costs: 100
A is not scalable.	B is not scalable.	
RTCostA: 2409, RTCostB: 225
A is not scalable.	B is not scalable.	
RTCostA: 2409, RTCostB: 225

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1005 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next1006, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or201 = or i64 %222, %221 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1224 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 288 for VF 4 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1224, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv1009, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1006 = add nuw nsw i64 %indvars.iv1005, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1008.not = icmp eq i64 %indvars.iv.next1006, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1008.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width 4 costs: 99
A is not scalable.	B is not scalable.	
RTCostA: 2385, RTCostB: 225
A is not scalable.	B is not scalable.	
RTCostA: 2385, RTCostB: 225

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1005 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next1006, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or201 = or i64 %222, %221 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1224 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF vscale x 1 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1224, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv1009, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1006 = add nuw nsw i64 %indvars.iv1005, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1008.not = icmp eq i64 %indvars.iv.next1006, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1008.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 225
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 225

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1005 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next1006, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %222 = load i64, ptr %arrayidx200, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or201 = or i64 %222, %221 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1224 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF vscale x 2 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1224, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv1009, i64 %indvars.iv1005 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1006 = add nuw nsw i64 %indvars.iv1005, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1008.not = icmp eq i64 %indvars.iv.next1006, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1008.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width vscale x 2 costs: 20
A is scalable.	B is not scalable.	
RTCostA: 489, RTCostB: 225
A is scalable.	B is not scalable.	
RTCostA: 489, RTCostB: 225
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1017 = phi %indvars.iv.next1018, 0, ir<1>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    CLONE store ir<25>, ir<%arrayidx238>
    CLONE ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    CLONE store ir<25>, ir<%arrayidx242>
    CLONE ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    CLONE store ir<25>, ir<%arrayidx238.1>
    CLONE ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    CLONE store ir<25>, ir<%arrayidx242.1>
    CLONE ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    CLONE store ir<25>, ir<%arrayidx238.2>
    CLONE ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    CLONE store ir<25>, ir<%arrayidx242.2>
    CLONE ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    CLONE store ir<25>, ir<%arrayidx238.3>
    CLONE ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    CLONE store ir<25>, ir<%arrayidx242.3>
    CLONE ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    CLONE store ir<25>, ir<%arrayidx238.4>
    CLONE ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    CLONE store ir<25>, ir<%arrayidx242.4>
    CLONE ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    CLONE store ir<25>, ir<%arrayidx238.5>
    CLONE ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    CLONE store ir<25>, ir<%arrayidx242.5>
    CLONE ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    CLONE store ir<25>, ir<%arrayidx238.6>
    CLONE ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    CLONE store ir<25>, ir<%arrayidx242.6>
    CLONE ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    CLONE store ir<25>, ir<%arrayidx238.7>
    CLONE ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    CLONE store ir<25>, ir<%arrayidx242.7>
    CLONE ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    CLONE store ir<25>, ir<%arrayidx238.8>
    CLONE ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    CLONE store ir<25>, ir<%arrayidx242.8>
    CLONE ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    CLONE store ir<25>, ir<%arrayidx238.9>
    CLONE ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    CLONE store ir<25>, ir<%arrayidx242.9>
    CLONE ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    CLONE store ir<25>, ir<%arrayidx238.10>
    CLONE ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    CLONE store ir<25>, ir<%arrayidx242.10>
    CLONE ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    CLONE store ir<25>, ir<%arrayidx238.11>
    CLONE ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    CLONE store ir<25>, ir<%arrayidx242.11>
    CLONE ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    CLONE store ir<25>, ir<%arrayidx238.12>
    CLONE ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    CLONE store ir<25>, ir<%arrayidx242.12>
    CLONE ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    CLONE store ir<25>, ir<%arrayidx238.13>
    CLONE ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    CLONE store ir<25>, ir<%arrayidx242.13>
    CLONE ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    CLONE store ir<25>, ir<%arrayidx238.14>
    CLONE ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    CLONE store ir<25>, ir<%arrayidx242.14>
    CLONE ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    CLONE store ir<25>, ir<%arrayidx238.15>
    CLONE ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    CLONE store ir<25>, ir<%arrayidx242.15>
    CLONE ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    CLONE store ir<25>, ir<%arrayidx238.16>
    CLONE ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    CLONE store ir<25>, ir<%arrayidx242.16>
    CLONE ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    CLONE store ir<25>, ir<%arrayidx238.17>
    CLONE ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    CLONE store ir<25>, ir<%arrayidx242.17>
    CLONE ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    CLONE store ir<25>, ir<%arrayidx238.18>
    CLONE ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    CLONE store ir<25>, ir<%arrayidx242.18>
    CLONE ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    CLONE store ir<25>, ir<%arrayidx238.19>
    CLONE ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    CLONE store ir<25>, ir<%arrayidx242.19>
    CLONE ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    CLONE store ir<25>, ir<%arrayidx238.20>
    CLONE ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    CLONE store ir<25>, ir<%arrayidx242.20>
    CLONE ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    CLONE store ir<25>, ir<%arrayidx238.21>
    CLONE ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    CLONE store ir<25>, ir<%arrayidx242.21>
    CLONE ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    CLONE store ir<25>, ir<%arrayidx238.22>
    CLONE ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    CLONE store ir<25>, ir<%arrayidx242.22>
    CLONE ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    CLONE store ir<25>, ir<%arrayidx238.23>
    CLONE ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    CLONE store ir<25>, ir<%arrayidx242.23>
    CLONE ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    CLONE store ir<25>, ir<%arrayidx238.24>
    CLONE ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    CLONE store ir<25>, ir<%arrayidx242.24>
    CLONE ir<%indvars.iv.next1018> = add nuw nsw ir<%indvars.iv1017>, ir<1>
    CLONE ir<%exitcond1020.not> = icmp eq ir<%indvars.iv.next1018>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1017 = phi %indvars.iv.next1018, 0, ir<1>
    REPLICATE ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    REPLICATE store ir<25>, ir<%arrayidx238>
    REPLICATE ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    REPLICATE store ir<25>, ir<%arrayidx242>
    REPLICATE ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    REPLICATE store ir<25>, ir<%arrayidx238.1>
    REPLICATE ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    REPLICATE store ir<25>, ir<%arrayidx242.1>
    REPLICATE ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    REPLICATE store ir<25>, ir<%arrayidx238.2>
    REPLICATE ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    REPLICATE store ir<25>, ir<%arrayidx242.2>
    REPLICATE ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    REPLICATE store ir<25>, ir<%arrayidx238.3>
    REPLICATE ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    REPLICATE store ir<25>, ir<%arrayidx242.3>
    REPLICATE ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    REPLICATE store ir<25>, ir<%arrayidx238.4>
    REPLICATE ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    REPLICATE store ir<25>, ir<%arrayidx242.4>
    REPLICATE ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    REPLICATE store ir<25>, ir<%arrayidx238.5>
    REPLICATE ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    REPLICATE store ir<25>, ir<%arrayidx242.5>
    REPLICATE ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    REPLICATE store ir<25>, ir<%arrayidx238.6>
    REPLICATE ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    REPLICATE store ir<25>, ir<%arrayidx242.6>
    REPLICATE ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    REPLICATE store ir<25>, ir<%arrayidx238.7>
    REPLICATE ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    REPLICATE store ir<25>, ir<%arrayidx242.7>
    REPLICATE ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    REPLICATE store ir<25>, ir<%arrayidx238.8>
    REPLICATE ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    REPLICATE store ir<25>, ir<%arrayidx242.8>
    REPLICATE ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    REPLICATE store ir<25>, ir<%arrayidx238.9>
    REPLICATE ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    REPLICATE store ir<25>, ir<%arrayidx242.9>
    REPLICATE ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    REPLICATE store ir<25>, ir<%arrayidx238.10>
    REPLICATE ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    REPLICATE store ir<25>, ir<%arrayidx242.10>
    REPLICATE ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    REPLICATE store ir<25>, ir<%arrayidx238.11>
    REPLICATE ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    REPLICATE store ir<25>, ir<%arrayidx242.11>
    REPLICATE ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    REPLICATE store ir<25>, ir<%arrayidx238.12>
    REPLICATE ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    REPLICATE store ir<25>, ir<%arrayidx242.12>
    REPLICATE ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    REPLICATE store ir<25>, ir<%arrayidx238.13>
    REPLICATE ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    REPLICATE store ir<25>, ir<%arrayidx242.13>
    REPLICATE ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    REPLICATE store ir<25>, ir<%arrayidx238.14>
    REPLICATE ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    REPLICATE store ir<25>, ir<%arrayidx242.14>
    REPLICATE ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    REPLICATE store ir<25>, ir<%arrayidx238.15>
    REPLICATE ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    REPLICATE store ir<25>, ir<%arrayidx242.15>
    REPLICATE ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    REPLICATE store ir<25>, ir<%arrayidx238.16>
    REPLICATE ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    REPLICATE store ir<25>, ir<%arrayidx242.16>
    REPLICATE ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    REPLICATE store ir<25>, ir<%arrayidx238.17>
    REPLICATE ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    REPLICATE store ir<25>, ir<%arrayidx242.17>
    REPLICATE ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    REPLICATE store ir<25>, ir<%arrayidx238.18>
    REPLICATE ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    REPLICATE store ir<25>, ir<%arrayidx242.18>
    REPLICATE ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    REPLICATE store ir<25>, ir<%arrayidx238.19>
    REPLICATE ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    REPLICATE store ir<25>, ir<%arrayidx242.19>
    REPLICATE ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    REPLICATE store ir<25>, ir<%arrayidx238.20>
    REPLICATE ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    REPLICATE store ir<25>, ir<%arrayidx242.20>
    REPLICATE ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    REPLICATE store ir<25>, ir<%arrayidx238.21>
    REPLICATE ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    REPLICATE store ir<25>, ir<%arrayidx242.21>
    REPLICATE ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    REPLICATE store ir<25>, ir<%arrayidx238.22>
    REPLICATE ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    REPLICATE store ir<25>, ir<%arrayidx242.22>
    REPLICATE ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    REPLICATE store ir<25>, ir<%arrayidx238.23>
    REPLICATE ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    REPLICATE store ir<25>, ir<%arrayidx242.23>
    REPLICATE ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    REPLICATE store ir<25>, ir<%arrayidx238.24>
    REPLICATE ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    REPLICATE store ir<25>, ir<%arrayidx242.24>
    REPLICATE ir<%indvars.iv.next1018> = add nuw nsw ir<%indvars.iv1017>, ir<1>
    CLONE ir<%exitcond1020.not> = icmp eq ir<%indvars.iv.next1018>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1017 = phi %indvars.iv.next1018, 0, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    REPLICATE store ir<25>, ir<%arrayidx238>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    REPLICATE store ir<25>, ir<%arrayidx242>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    REPLICATE store ir<25>, ir<%arrayidx238.1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    REPLICATE store ir<25>, ir<%arrayidx242.1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    REPLICATE store ir<25>, ir<%arrayidx238.2>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    REPLICATE store ir<25>, ir<%arrayidx242.2>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    REPLICATE store ir<25>, ir<%arrayidx238.3>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    REPLICATE store ir<25>, ir<%arrayidx242.3>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    REPLICATE store ir<25>, ir<%arrayidx238.4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    REPLICATE store ir<25>, ir<%arrayidx242.4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    REPLICATE store ir<25>, ir<%arrayidx238.5>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    REPLICATE store ir<25>, ir<%arrayidx242.5>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    REPLICATE store ir<25>, ir<%arrayidx238.6>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    REPLICATE store ir<25>, ir<%arrayidx242.6>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    REPLICATE store ir<25>, ir<%arrayidx238.7>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    REPLICATE store ir<25>, ir<%arrayidx242.7>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    REPLICATE store ir<25>, ir<%arrayidx238.8>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    REPLICATE store ir<25>, ir<%arrayidx242.8>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    REPLICATE store ir<25>, ir<%arrayidx238.9>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    REPLICATE store ir<25>, ir<%arrayidx242.9>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    REPLICATE store ir<25>, ir<%arrayidx238.10>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    REPLICATE store ir<25>, ir<%arrayidx242.10>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    REPLICATE store ir<25>, ir<%arrayidx238.11>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    REPLICATE store ir<25>, ir<%arrayidx242.11>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    REPLICATE store ir<25>, ir<%arrayidx238.12>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    REPLICATE store ir<25>, ir<%arrayidx242.12>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    REPLICATE store ir<25>, ir<%arrayidx238.13>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    REPLICATE store ir<25>, ir<%arrayidx242.13>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    REPLICATE store ir<25>, ir<%arrayidx238.14>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    REPLICATE store ir<25>, ir<%arrayidx242.14>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    REPLICATE store ir<25>, ir<%arrayidx238.15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    REPLICATE store ir<25>, ir<%arrayidx242.15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    REPLICATE store ir<25>, ir<%arrayidx238.16>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    REPLICATE store ir<25>, ir<%arrayidx242.16>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    REPLICATE store ir<25>, ir<%arrayidx238.17>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    REPLICATE store ir<25>, ir<%arrayidx242.17>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    REPLICATE store ir<25>, ir<%arrayidx238.18>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    REPLICATE store ir<25>, ir<%arrayidx242.18>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    REPLICATE store ir<25>, ir<%arrayidx238.19>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    REPLICATE store ir<25>, ir<%arrayidx242.19>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    REPLICATE store ir<25>, ir<%arrayidx238.20>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    REPLICATE store ir<25>, ir<%arrayidx242.20>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    REPLICATE store ir<25>, ir<%arrayidx238.21>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    REPLICATE store ir<25>, ir<%arrayidx242.21>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    REPLICATE store ir<25>, ir<%arrayidx238.22>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    REPLICATE store ir<25>, ir<%arrayidx242.22>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    REPLICATE store ir<25>, ir<%arrayidx238.23>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    REPLICATE store ir<25>, ir<%arrayidx242.23>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    REPLICATE store ir<25>, ir<%arrayidx238.24>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    REPLICATE store ir<25>, ir<%arrayidx242.24>
    WIDEN ir<%indvars.iv.next1018> = add nuw nsw ir<%indvars.iv1017>, ir<1>
    CLONE ir<%exitcond1020.not> = icmp eq ir<%indvars.iv.next1018>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1017 = phi %indvars.iv.next1018, 0, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    WIDEN store ir<%arrayidx238>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<0>
    WIDEN store ir<%arrayidx242>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    WIDEN store ir<%arrayidx238.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<1>
    WIDEN store ir<%arrayidx242.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    WIDEN store ir<%arrayidx238.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<2>
    WIDEN store ir<%arrayidx242.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    WIDEN store ir<%arrayidx238.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<3>
    WIDEN store ir<%arrayidx242.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    WIDEN store ir<%arrayidx238.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<4>
    WIDEN store ir<%arrayidx242.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    WIDEN store ir<%arrayidx238.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<5>
    WIDEN store ir<%arrayidx242.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    WIDEN store ir<%arrayidx238.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<6>
    WIDEN store ir<%arrayidx242.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    WIDEN store ir<%arrayidx238.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<7>
    WIDEN store ir<%arrayidx242.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    WIDEN store ir<%arrayidx238.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<8>
    WIDEN store ir<%arrayidx242.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    WIDEN store ir<%arrayidx238.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<9>
    WIDEN store ir<%arrayidx242.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    WIDEN store ir<%arrayidx238.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<10>
    WIDEN store ir<%arrayidx242.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    WIDEN store ir<%arrayidx238.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<11>
    WIDEN store ir<%arrayidx242.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    WIDEN store ir<%arrayidx238.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<12>
    WIDEN store ir<%arrayidx242.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    WIDEN store ir<%arrayidx238.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<13>
    WIDEN store ir<%arrayidx242.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    WIDEN store ir<%arrayidx238.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<14>
    WIDEN store ir<%arrayidx242.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    WIDEN store ir<%arrayidx238.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<15>
    WIDEN store ir<%arrayidx242.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    WIDEN store ir<%arrayidx238.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<16>
    WIDEN store ir<%arrayidx242.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    WIDEN store ir<%arrayidx238.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<17>
    WIDEN store ir<%arrayidx242.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    WIDEN store ir<%arrayidx238.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<18>
    WIDEN store ir<%arrayidx242.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    WIDEN store ir<%arrayidx238.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<19>
    WIDEN store ir<%arrayidx242.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    WIDEN store ir<%arrayidx238.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<20>
    WIDEN store ir<%arrayidx242.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    WIDEN store ir<%arrayidx238.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<21>
    WIDEN store ir<%arrayidx242.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    WIDEN store ir<%arrayidx238.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<22>
    WIDEN store ir<%arrayidx242.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    WIDEN store ir<%arrayidx238.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<23>
    WIDEN store ir<%arrayidx242.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    WIDEN store ir<%arrayidx238.24>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1017>, ir<24>
    WIDEN store ir<%arrayidx242.24>, ir<25>
    WIDEN ir<%indvars.iv.next1018> = add nuw nsw ir<%indvars.iv1017>, ir<1>
    CLONE ir<%exitcond1020.not> = icmp eq ir<%indvars.iv.next1018>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Scalar loop costs: 102.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width 2 costs: 651

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width 4 costs: 650

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2550

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 513
A is scalable.	B is not scalable.	
RTCostA: 12414, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: 12414, RTCostB: 2550

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1017 = phi i64 [ %indvars.iv.next1018, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.1, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.2, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.3, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.4, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.6, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.7, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.8, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.9, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.10, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.11, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.12, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.13, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.14, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.16, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.17, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.18, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.19, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.20, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.21, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.22, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.23, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1017, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.24, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1018 = add nuw nsw i64 %indvars.iv1017, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1020.not = icmp eq i64 %indvars.iv.next1018, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1020.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 506
A is scalable.	B is not scalable.	
RTCostA: 12261, RTCostB: 2550
A is scalable.	B is not scalable.	
RTCostA: 12261, RTCostB: 2550
LV: Selecting VF: 1 With Cost: 102.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 4
Loops Analyzed: 16
Loops Epilogues Vectorized: 4
================================================
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    CLONE ir<%and228> = and ir<%17>, ir<33554432>
    CLONE ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    CLONE ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    CLONE ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    CLONE ir<%18> = load ir<%arrayidx236>
    CLONE ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa446>
    CLONE ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    CLONE ir<%19> = load ir<%arrayidx240>
    CLONE ir<%add241> = add nsw ir<%div238>, ir<%19>
    CLONE store ir<%add241>, ir<%arrayidx240>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit441>, scalar.ph

ir-bb<cleanup.loopexit441>:
No successors

scalar.ph:
No successors
}

========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%17>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    REPLICATE ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    REPLICATE ir<%18> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa446>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%19> = load vp<%3>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%4>, ir<%add241>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit441>, scalar.ph

ir-bb<cleanup.loopexit441>:
No successors

scalar.ph:
No successors
}

========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%17>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    REPLICATE ir<%18> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa446>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%19> = load vp<%3>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%4>, ir<%add241>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit441>, scalar.ph

ir-bb<cleanup.loopexit441>:
No successors

scalar.ph:
No successors
}

========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%17>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    WIDEN ir<%18> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa446>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%19> = load vp<%3>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%4>, ir<%add241>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit441>, scalar.ph

ir-bb<cleanup.loopexit441>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of 5 for VF 1 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Scalar loop costs: 19.
-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of 15 for VF 2 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Vector loop of width 2 costs: 28
A is not scalable.	B is not scalable.	
RTCostA: 691, RTCostB: 475
A is not scalable.	B is not scalable.	
RTCostA: 691, RTCostB: 475

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of 27 for VF 4 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Vector loop of width 4 costs: 24
A is not scalable.	B is not scalable.	
RTCostA: 613, RTCostB: 475
A is not scalable.	B is not scalable.	
RTCostA: 613, RTCostB: 475

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 475
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 475

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of 5 for VF vscale x 2 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 14
A is scalable.	B is not scalable.	
RTCostA: 361, RTCostB: 475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 361, RTCostB: 475
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %17 = load i32, ptr @target_flags, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %18 = load i32, ptr %arrayidx236, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa446 of type:mul
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %19 = load i32, ptr %arrayidx240, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %add241, ptr %arrayidx240, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit441, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 316, RTCostB: 475
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 316, RTCostB: 361
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 12.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: record_address_regs at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%19> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%19>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    WIDEN ir<%20> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%20>, ir<%scale.tr.lcssa446>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%21>
    vp<%5> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%5>, ir<%add241>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit441>, scalar.ph

ir-bb<cleanup.loopexit441>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 43
Loops Epilogues Vectorized: 4
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o regmove.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                regmove.c
MVT: v2i32
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4, !tbaa !11 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<-1>, ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<-1>, ir<%arrayidx3>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%5>, ir<-1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%5>, ir<-1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 768, RTCostB: 1530
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 768, RTCostB: 1530
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 522, RTCostB: 1530
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 522, RTCostB: 768
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1530
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 522

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx3, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 396, RTCostB: 1530
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 396, RTCostB: 522
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: find_matches at line: regmove.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%1> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%7>, ir<-1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o regrename.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                regrename.c
========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv576 = phi %19, %indvars.iv.next577, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    CLONE ir<%indvars.iv.next577> = add nsw ir<%indvars.iv576>, ir<-1>
    CLONE ir<%add123> = add ir<%indvars.iv576>, ir<5>
    CLONE ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    CLONE ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    CLONE ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%21> = and ir<%indvars.iv.next577>, ir<4294967295>
    CLONE ir<%tobool121.not> = icmp eq ir<%21>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv576 = phi %19, %indvars.iv.next577, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN ir<%indvars.iv.next577> = add nsw ir<%indvars.iv576>, ir<-1>
    WIDEN ir<%add123> = add ir<%indvars.iv576>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%21> = and ir<%indvars.iv.next577>, ir<4294967295>
    CLONE ir<%tobool121.not> = icmp eq ir<%21>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv576 = phi %19, %indvars.iv.next577, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN ir<%indvars.iv.next577> = add nsw ir<%indvars.iv576>, ir<-1>
    WIDEN ir<%add123> = add ir<%indvars.iv576>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%21> = and ir<%indvars.iv.next577>, ir<4294967295>
    CLONE ir<%tobool121.not> = icmp eq ir<%21>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}


-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv576 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next577, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next577 = add nsw i64 %indvars.iv576, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add123 = add i64 %indvars.iv576, 5 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %21 = and i64 %indvars.iv.next577, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool121.not = icmp eq i64 %21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv576 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next577, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next577 = add nsw i64 %indvars.iv576, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add123 = add i64 %indvars.iv576, 5 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = and i64 %indvars.iv.next577, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tobool121.not = icmp eq i64 %21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv576 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next577, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next577 = add nsw i64 %indvars.iv576, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add123 = add i64 %indvars.iv576, 5 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %21 = and i64 %indvars.iv.next577, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tobool121.not = icmp eq i64 %21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450938
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225472

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv576 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next577, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next577 = add nsw i64 %indvars.iv576, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add123 = add i64 %indvars.iv576, 5 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = and i64 %indvars.iv.next577, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tobool121.not = icmp eq i64 %21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: regrename_optimize at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv576 = phi %19, %indvars.iv.next577, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN ir<%add123> = add ir<%indvars.iv576>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%add79> = add ir<%indvars.iv>, ir<19>
    CLONE ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%43> = and ir<%indvars.iv.next>, ir<4294967295>
    CLONE ir<%tobool77.not> = icmp eq ir<%43>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%43> = and ir<%indvars.iv.next>, ir<4294967295>
    CLONE ir<%tobool77.not> = icmp eq ir<%43>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%43> = and ir<%indvars.iv.next>, ir<4294967295>
    CLONE ir<%tobool77.not> = icmp eq ir<%43>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %43 = and i64 %indvars.iv.next, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool77.not = icmp eq i64 %43, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %43 = and i64 %indvars.iv.next, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tobool77.not = icmp eq i64 %43, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %43 = and i64 %indvars.iv.next, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tobool77.not = icmp eq i64 %43, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450938
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225472

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %43 = and i64 %indvars.iv.next, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tobool77.not = icmp eq i64 %43, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612748, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: regrename_optimize at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%9> = trunc ir<%indvars.iv.next>
    CLONE ir<%add72> = add ir<%.fr109>, ir<%9>
    CLONE ir<%sh_prom> = zext nneg ir<%add72>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}

========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%9> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}

========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%9> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}


-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %8, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add72 = add i32 %.fr109, %9 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %8, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add72 = add i32 %.fr109, %9 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %8, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add72 = add i32 %.fr109, %9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450938
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3758096383

-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %8, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add72 = add i32 %.fr109, %9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1879048203, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1879048203, RTCostB: 3758096383
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: clear_dead_regs at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%9> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 36
Loops Epilogues Vectorized: 0
================================================
========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%11> = trunc ir<%indvars.iv.next>
    CLONE ir<%add63> = add ir<%.fr93>, ir<%11>
    CLONE ir<%sh_prom> = zext nneg ir<%add63>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225471, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225471, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225471

-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225471
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: note_sets at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o reload.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                reload.c
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    CLONE ir<%1> = load ir<%what>
    CLONE ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    CLONE store ir<%to>, ir<%what>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    INTERLEAVE-GROUP with factor 6 at %1, ir<%what>
      ir<%1> = load from index 0
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    REPLICATE store ir<%to>, ir<%what>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    REPLICATE ir<%1> = load ir<%what>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    REPLICATE store ir<%to>, ir<%what>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    WIDEN ir<%1> = load ir<%what>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    WIDEN store ir<%what>, ir<%to>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 22 for VF 4 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 19864223725, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 19864223725, RTCostB: 12884901882

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1 = load i32, ptr %what, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %to, ptr %what, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
RTCostA: 44560285572, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 44560285572, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 4 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6141 = phi 0, %indvars.iv.next6142, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6141>
    CLONE ir<%218> = load ir<%arrayidx2270>
    CLONE ir<%219> = zext ir<%218>
    CLONE ir<%cmp2271> = icmp eq ir<%indvars.iv6146>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr inbounds ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6141>
    CLONE ir<%220> = load ir<%arrayidx2275>, ir<%cmp2271>
    CLONE ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%4> = not ir<%tobool2277.not>
    EMIT vp<%5> = logical-and ir<%cmp2271>, vp<%4>
    CLONE ir<%arrayidx2280> = getelementptr inbounds ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6141>
    CLONE store ir<0>, ir<%arrayidx2280>, vp<%5>
    CLONE store ir<0>, ir<%arrayidx2275>, vp<%5>
    CLONE ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%6> = not ir<%cmp2271>
    EMIT vp<%7> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%8> = or vp<%6>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%5>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%7> ir<%losers.115984>/vp<%6>
    CLONE ir<%indvars.iv.next6142> = add nuw nsw ir<%indvars.iv6141>, ir<1>
    CLONE ir<%exitcond6145.not> = icmp eq ir<%indvars.iv.next6142>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%12>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv6141 = phi 0, %indvars.iv.next6142, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6141>
    vp<%4> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%4>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6146>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6141>
    vp<%5> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%5>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%6> = not ir<%tobool2277.not>
    EMIT vp<%7> = logical-and ir<%cmp2271>, vp<%6>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6141>
    vp<%8> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%8>, ir<0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%9>, ir<0>, vp<%7>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%10> = not ir<%cmp2271>
    EMIT vp<%11> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%12> = or vp<%10>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%11> ir<%losers.115984>/vp<%10>
    CLONE ir<%indvars.iv.next6142> = add nuw nsw ir<%indvars.iv6141>, ir<1>
    CLONE ir<%exitcond6145.not> = icmp eq ir<%indvars.iv.next6142>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%16>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv6141 = phi 0, %indvars.iv.next6142, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6141>
    vp<%4> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%4>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6146>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6141>
    vp<%5> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%5>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%6> = not ir<%tobool2277.not>
    EMIT vp<%7> = logical-and ir<%cmp2271>, vp<%6>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6141>
    vp<%8> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%8>, ir<0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%9>, ir<0>, vp<%7>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%10> = not ir<%cmp2271>
    EMIT vp<%11> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%12> = or vp<%10>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%11> ir<%losers.115984>/vp<%10>
    CLONE ir<%indvars.iv.next6142> = add nuw nsw ir<%indvars.iv6141>, ir<1>
    CLONE ir<%exitcond6145.not> = icmp eq ir<%indvars.iv.next6142>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%16>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 2 costs: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 4 costs: 23
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 93
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 93, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 93
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 93, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 16 for VF 8 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 8 costs: 18
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 147
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 147, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 147
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 147, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 16 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 8 for VF 16 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 4 for VF 16 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 32 for VF 16 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 16 costs: 18
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 291
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 291, CostB * EstimatedWidthA: 128
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 291
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 291, CostB * EstimatedWidthA: 128

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6141 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6142, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6146, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6141 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx2280, align 1, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx2275, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6142 = add nuw nsw i64 %indvars.iv6141, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6145.not = icmp eq i64 %indvars.iv.next6142, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6145.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 14
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%5>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6146>, ir<%219>
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%6>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
    EMIT vp<%7> = not ir<%tobool2277.not>
    EMIT vp<%8> = logical-and ir<%cmp2271>, vp<%7>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, vp<%4>
    vp<%9> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%9>, ir<0>, vp<%8>
    vp<%10> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%10>, ir<0>, vp<%8>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
    EMIT vp<%11> = not ir<%cmp2271>
    EMIT vp<%12> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%12> ir<%losers.115984>/vp<%11>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%15>
}
================ Final VPlan ================

@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%4>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    CLONE ir<%121> = load ir<%arrayidx921>
    CLONE ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%4> = or ir<%badop.25918>, ir<%cmp924>
    CLONE ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6130.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6131>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%badop.25918>, vp<%4>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog.loopexit6409>, scalar.ph

ir-bb<sw.epilog.loopexit6409>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%7>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    vp<%4> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%4>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%5> = or ir<%badop.25918>, ir<%cmp924>
    WIDEN-SELECT ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6130.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6131>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%badop.25918>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit6409>, scalar.ph

ir-bb<sw.epilog.loopexit6409>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%8>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    vp<%4> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%4>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%5> = or ir<%badop.25918>, ir<%cmp924>
    WIDEN-SELECT ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6130.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6131>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%badop.25918>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit6409>, scalar.ph

ir-bb<sw.epilog.loopexit6409>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%8>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %121 = load i32, ptr %arrayidx921, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6130.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6131 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6130.not, label %sw.epilog.loopexit6409, label %for.body919 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%5>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%6> = or ir<%badop.25918>, ir<%cmp924>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%badop.25918>, vp<%6>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit6409>, scalar.ph

ir-bb<sw.epilog.loopexit6409>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
LV: Decision: Scalarize
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
LV: Decision: Scalarize
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 40 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)
LV: Decision: Scalarize
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 80 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)
LV: Decision: Scalarize
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6171 = phi 0, %indvars.iv.next6172, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6171 = phi 0, %indvars.iv.next6172\l" +
    "  ir<%319>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6171>
    CLONE ir<%317> = load ir<%arrayidx2528>
    CLONE ir<%tobool2529.not> = icmp eq ir<%317>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr inbounds ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6171>
    CLONE ir<%318> = load ir<%arrayidx2532>, ir<%tobool2529.not>
    CLONE ir<%cmp2533> = icmp sgt ir<%318>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%4> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    CLONE ir<%idxprom2538> = zext nneg ir<%318>
    CLONE ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    CLONE store ir<%319>, ir<%arrayidx2539>, vp<%4>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%5> = not ir<%tobool2529.not>
    EMIT vp<%6> = not ir<%cmp2533>
    EMIT vp<%7> = logical-and ir<%tobool2529.not>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%4>
    CLONE ir<%indvars.iv.next6172> = add nuw nsw ir<%indvars.iv6171>, ir<1>
    CLONE ir<%exitcond6175.not> = icmp eq ir<%indvars.iv.next6172>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv6171 = phi 0, %indvars.iv.next6172, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6171 = phi 0, %indvars.iv.next6172\l" +
    "  ir<%319>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6171>
    vp<%4> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%317> = load vp<%4>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%317>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6171>
    vp<%5> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%318> = load vp<%5>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%318>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%6> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%318> to i64
    REPLICATE ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    REPLICATE store ir<%319>, ir<%arrayidx2539>, vp<%6>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%7> = not ir<%tobool2529.not>
    EMIT vp<%8> = not ir<%cmp2533>
    EMIT vp<%9> = logical-and ir<%tobool2529.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    WIDEN ir<%indvars.iv.next6172> = add nuw nsw ir<%indvars.iv6171>, ir<1>
    CLONE ir<%exitcond6175.not> = icmp eq ir<%indvars.iv.next6172>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv6171 = phi 0, %indvars.iv.next6172, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6171 = phi 0, %indvars.iv.next6172\l" +
    "  ir<%319>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6171>
    vp<%4> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%317> = load vp<%4>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%317>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6171>
    vp<%5> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%318> = load vp<%5>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%318>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%6> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%318> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    REPLICATE store ir<%319>, ir<%arrayidx2539>, vp<%6>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%7> = not ir<%tobool2529.not>
    EMIT vp<%8> = not ir<%cmp2533>
    EMIT vp<%9> = logical-and ir<%tobool2529.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    WIDEN ir<%indvars.iv.next6172> = add nuw nsw ir<%indvars.iv6171>, ir<1>
    CLONE ir<%exitcond6175.not> = icmp eq ir<%indvars.iv.next6172>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv6171 = phi 0, %indvars.iv.next6172, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6171 = phi 0, %indvars.iv.next6172\l" +
    "  ir<%319>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6171>
    vp<%4> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%317> = load vp<%4>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%317>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6171>
    vp<%5> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%318> = load vp<%5>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%318>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%6> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%318> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    WIDEN store ir<%arrayidx2539>, ir<%319>, vp<%6>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%7> = not ir<%tobool2529.not>
    EMIT vp<%8> = not ir<%cmp2533>
    EMIT vp<%9> = logical-and ir<%tobool2529.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    WIDEN ir<%indvars.iv.next6172> = add nuw nsw ir<%indvars.iv6171>, ir<1>
    CLONE ir<%exitcond6175.not> = icmp eq ir<%indvars.iv.next6172>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 2 for VF 2 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 2 costs: 13
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 26
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 26
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 4 for VF 4 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 4 costs: 11
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 45
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 45, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 45
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 45, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 16 for VF 8 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 8 for VF 8 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 8 costs: 10
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 81
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 81, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 81
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 81, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 32 for VF 16 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 16 for VF 16 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Found an estimated cost of 16 for VF 16 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 16 costs: 9
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 159
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 159, CostB * EstimatedWidthA: 112
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 159
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 159, CostB * EstimatedWidthA: 112

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6171 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6172, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %317 = load i8, ptr %arrayidx2528, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool2529.not = icmp eq i8 %317, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6171 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %318 = load i32, ptr %arrayidx2532, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp2533 = icmp sgt i32 %318, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2538 = zext nneg i32 %318 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %319 = trunc nuw nsw i64 %indvars.iv6171 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %319, ptr %arrayidx2539, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next6172 = add nuw nsw i64 %indvars.iv6171, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6175.not = icmp eq i64 %indvars.iv.next6172, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6175.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 90
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 90, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 90
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 90, CostB * EstimatedWidthA: 56
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6176 = phi %indvars.iv.next6177, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6176>
    CLONE ir<%320> = load ir<%arrayidx2549>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6176>
    CLONE ir<%321> = load ir<%arrayidx2552>
    CLONE ir<%or25545529> = or ir<%321>, ir<%320>
    CLONE store ir<%or25545529>, ir<%arrayidx2552>
    CLONE ir<%indvars.iv.next6177> = add nuw nsw ir<%indvars.iv6176>, ir<1>
    CLONE ir<%exitcond6180.not> = icmp eq ir<%indvars.iv.next6177>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv6176 = phi %indvars.iv.next6177, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6176>
    vp<%4> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%320> = load vp<%4>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6176>
    vp<%5> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%321> = load vp<%5>
    WIDEN ir<%or25545529> = or ir<%321>, ir<%320>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%6>, ir<%or25545529>
    CLONE ir<%indvars.iv.next6177> = add nuw nsw ir<%indvars.iv6176>, ir<1>
    CLONE ir<%exitcond6180.not> = icmp eq ir<%indvars.iv.next6177>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv6176 = phi %indvars.iv.next6177, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6176>
    vp<%4> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%320> = load vp<%4>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6176>
    vp<%5> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%321> = load vp<%5>
    WIDEN ir<%or25545529> = or ir<%321>, ir<%320>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%6>, ir<%or25545529>
    CLONE ir<%indvars.iv.next6177> = add nuw nsw ir<%indvars.iv6176>, ir<1>
    CLONE ir<%exitcond6180.not> = icmp eq ir<%indvars.iv.next6177>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv6176 = phi i64 [ %indvars.iv.next6177, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %320 = load i8, ptr %arrayidx2549, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6176 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %321 = load i8, ptr %arrayidx2552, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or25545529 = or i8 %321, %320 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next6177 = add nuw nsw i64 %indvars.iv6176, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond6180.not = icmp eq i64 %indvars.iv.next6177, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond6180.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 15
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 60
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: find_reloads at line: reload.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%320> = load vp<%5>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%321> = load vp<%6>
    WIDEN ir<%or25545529> = or ir<%321>, ir<%320>
    vp<%7> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%7>, ir<%or25545529>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%352> = load vp<%4>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%353> = load vp<%5>
    WIDEN ir<%or25545529> = or ir<%353>, ir<%352>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%6>, ir<%or25545529>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %376 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6181 = phi 0, %indvars.iv.next6182, ir<1>
    CLONE ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6181>, ir<12>
    CLONE ir<%377> = load ir<%opnum>
    CLONE ir<%cmp2597> = icmp eq ir<%377>, ir<%commutative.6.lcssa6323.lcssa6435>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    CLONE ir<%cmp2609> = icmp eq ir<%377>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6323.lcssa6435>/vp<%5>
    CLONE store ir<%add2563.sink>, ir<%opnum>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    CLONE ir<%indvars.iv.next6182> = add nuw nsw ir<%indvars.iv6181>, ir<1>
    CLONE ir<%exitcond6185.not> = icmp eq ir<%indvars.iv.next6182>, ir<%wide.trip.count6184>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %376 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6181 = phi 0, %indvars.iv.next6182, ir<1>
    REPLICATE ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6181>, ir<12>
    REPLICATE ir<%377> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%377>, ir<%commutative.6.lcssa6323.lcssa6435>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%377>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6323.lcssa6435>/vp<%5>
    REPLICATE store ir<%add2563.sink>, ir<%opnum>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    REPLICATE ir<%indvars.iv.next6182> = add nuw nsw ir<%indvars.iv6181>, ir<1>
    CLONE ir<%exitcond6185.not> = icmp eq ir<%indvars.iv.next6182>, ir<%wide.trip.count6184>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %376 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6181 = phi 0, %indvars.iv.next6182, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6181>, ir<12>
    REPLICATE ir<%377> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%377>, ir<%commutative.6.lcssa6323.lcssa6435>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%377>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6323.lcssa6435>/vp<%5>
    REPLICATE store ir<%add2563.sink>, ir<%opnum>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next6182> = add nuw nsw ir<%indvars.iv6181>, ir<1>
    CLONE ir<%exitcond6185.not> = icmp eq ir<%indvars.iv.next6182>, ir<%wide.trip.count6184>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %376 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6181 = phi 0, %indvars.iv.next6182, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6181>, ir<12>
    WIDEN ir<%377> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%377>, ir<%commutative.6.lcssa6323.lcssa6435>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%377>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6323.lcssa6435>/vp<%5>
    WIDEN store ir<%opnum>, ir<%add2563.sink>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next6182> = add nuw nsw ir<%indvars.iv6181>, ir<1>
    CLONE ir<%exitcond6185.not> = icmp eq ir<%indvars.iv.next6182>, ir<%wide.trip.count6184>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width 2 costs: 22
A is not scalable.	B is not scalable.	
RTCostA: 47244640218, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 47244640218, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width 4 costs: 21
A is not scalable.	B is not scalable.	
RTCostA: 45097156542, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 45097156542, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 46707769275, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 46707769275, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6181 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6182, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6181, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %377 = load i32, ptr %opnum, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp2597 = icmp eq i32 %377, %commutative.6.lcssa6323.lcssa6435 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp2609 = icmp eq i32 %377, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6323.lcssa6435, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next6182 = add nuw nsw i64 %indvars.iv6181, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6185.not = icmp eq i64 %indvars.iv.next6182, %wide.trip.count6184 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6185.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45097156482, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45097156482, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6216 = phi 0, %indvars.iv.next6217, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26034.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6216>
    CLONE ir<%391> = load ir<%arrayidx3400.us>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6216>
    CLONE ir<%392> = load ir<%arrayidx3402.us>
    CLONE ir<%393> = load ir<%392>
    CLONE ir<%cmp3403.us> = icmp ne ir<%391>, ir<%393>
    CLONE ir<%conv3404.us> = zext ir<%cmp3403.us>
    CLONE ir<%or3405.us> = or ir<%retval17.26034.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6217> = add nuw nsw ir<%indvars.iv6216>, ir<1>
    CLONE ir<%exitcond6220.not> = icmp eq ir<%indvars.iv.next6217>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%retval17.26034.us>, ir<%or3405.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%6>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6216 = phi 0, %indvars.iv.next6217, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26034.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6216>
    vp<%4> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%391> = load vp<%4>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6216>
    vp<%5> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%392> = load vp<%5>
    REPLICATE ir<%393> = load ir<%392>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%391>, ir<%393>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26034.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6217> = add nuw nsw ir<%indvars.iv6216>, ir<1>
    CLONE ir<%exitcond6220.not> = icmp eq ir<%indvars.iv.next6217>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%retval17.26034.us>, ir<%or3405.us>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%8>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6216 = phi 0, %indvars.iv.next6217, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26034.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6216>
    vp<%4> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%391> = load vp<%4>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6216>
    vp<%5> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%392> = load vp<%5>
    REPLICATE ir<%393> = load ir<%392>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%391>, ir<%393>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26034.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6217> = add nuw nsw ir<%indvars.iv6216>, ir<1>
    CLONE ir<%exitcond6220.not> = icmp eq ir<%indvars.iv.next6217>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%retval17.26034.us>, ir<%or3405.us>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%8>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6216 = phi 0, %indvars.iv.next6217, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26034.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6216>
    vp<%4> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%391> = load vp<%4>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6216>
    vp<%5> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%392> = load vp<%5>
    WIDEN ir<%393> = load ir<%392>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%391>, ir<%393>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26034.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6217> = add nuw nsw ir<%indvars.iv6216>, ir<1>
    CLONE ir<%exitcond6220.not> = icmp eq ir<%indvars.iv.next6217>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%retval17.26034.us>, ir<%or3405.us>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%8>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6216 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6217, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %retval17.26034.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %393 = load ptr, ptr %392, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3403.us = icmp ne ptr %391, %393 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or3405.us = or i32 %retval17.26034.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6217 = add nuw nsw i64 %indvars.iv6216, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6220.not = icmp eq i64 %indvars.iv.next6217, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6220.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6216 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6217, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %retval17.26034.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %393 = load ptr, ptr %392, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3403.us = icmp ne ptr %391, %393 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or3405.us = or i32 %retval17.26034.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6217 = add nuw nsw i64 %indvars.iv6216, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6220.not = icmp eq i64 %indvars.iv.next6217, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6220.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 37
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 37, CostB * EstimatedWidthA: 22
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 37
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 37, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6216 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6217, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %retval17.26034.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %393 = load ptr, ptr %392, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp3403.us = icmp ne ptr %391, %393 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or3405.us = or i32 %retval17.26034.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6217 = add nuw nsw i64 %indvars.iv6216, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6220.not = icmp eq i64 %indvars.iv.next6217, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6220.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 70
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 70, CostB * EstimatedWidthA: 44
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 70
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 70, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6216 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6217, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %retval17.26034.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %393 = load ptr, ptr %392, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3403.us = icmp ne ptr %391, %393 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or3405.us = or i32 %retval17.26034.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6217 = add nuw nsw i64 %indvars.iv6216, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6220.not = icmp eq i64 %indvars.iv.next6217, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6220.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6216 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6217, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %retval17.26034.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %391 = load ptr, ptr %arrayidx3400.us, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %392 = load ptr, ptr %arrayidx3402.us, align 8, !tbaa !9 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %393 = load ptr, ptr %392, align 8, !tbaa !9 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3403.us = icmp ne ptr %391, %393 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or3405.us = or i32 %retval17.26034.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6217 = add nuw nsw i64 %indvars.iv6216, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6220.not = icmp eq i64 %indvars.iv.next6217, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6220.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 44
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 48
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 44
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%retval17.26034.us> = phi ir<0>, ir<%or3405.us>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, vp<%4>
    CLONE ir<%391> = load ir<%arrayidx3400.us>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, vp<%4>
    CLONE ir<%392> = load ir<%arrayidx3402.us>
    CLONE ir<%393> = load ir<%392>
    CLONE ir<%cmp3403.us> = icmp ne ir<%391>, ir<%393>
    CLONE ir<%conv3404.us> = zext ir<%cmp3403.us>
    CLONE ir<%or3405.us> = or ir<%retval17.26034.us>, ir<%conv3404.us>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%retval17.26034.us>, ir<%or3405.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%7>
}
================ Final VPlan ================

LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %525 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6224 = phi 0, %indvars.iv.next6225, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6224>, ir<2>
    CLONE ir<%526> = load ir<%what>
    CLONE ir<%527> = zext ir<%526>
    CLONE ir<%cmp3587> = icmp eq ir<%indvars.iv6231>, ir<%527>
  Successor(s): if.then3589

  if.then3589:
    CLONE store ir<%514>, ir<%what>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    CLONE ir<%indvars.iv.next6225> = add nuw nsw ir<%indvars.iv6224>, ir<1>
    CLONE ir<%exitcond6228.not> = icmp eq ir<%indvars.iv.next6225>, ir<%wide.trip.count6227>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end3596.loopexit>, scalar.ph

ir-bb<for.end3596.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %525 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6224 = phi 0, %indvars.iv.next6225, ir<1>
    REPLICATE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6224>, ir<2>
    INTERLEAVE-GROUP with factor 6 at %526, ir<%what>
      ir<%526> = load from index 0
    WIDEN-CAST ir<%527> = zext  ir<%526> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6231>, ir<%527>
  Successor(s): if.then3589

  if.then3589:
    REPLICATE store ir<%514>, ir<%what>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    REPLICATE ir<%indvars.iv.next6225> = add nuw nsw ir<%indvars.iv6224>, ir<1>
    CLONE ir<%exitcond6228.not> = icmp eq ir<%indvars.iv.next6225>, ir<%wide.trip.count6227>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %525 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6224 = phi 0, %indvars.iv.next6225, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6224>, ir<2>
    REPLICATE ir<%526> = load ir<%what>
    WIDEN-CAST ir<%527> = zext  ir<%526> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6231>, ir<%527>
  Successor(s): if.then3589

  if.then3589:
    REPLICATE store ir<%514>, ir<%what>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    WIDEN ir<%indvars.iv.next6225> = add nuw nsw ir<%indvars.iv6224>, ir<1>
    CLONE ir<%exitcond6228.not> = icmp eq ir<%indvars.iv.next6225>, ir<%wide.trip.count6227>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %525 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6224 = phi 0, %indvars.iv.next6225, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6224>, ir<2>
    WIDEN ir<%526> = load ir<%what>
    WIDEN-CAST ir<%527> = zext  ir<%526> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6231>, ir<%527>
  Successor(s): if.then3589

  if.then3589:
    WIDEN store ir<%what>, ir<%514>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    WIDEN ir<%indvars.iv.next6225> = add nuw nsw ir<%indvars.iv6224>, ir<1>
    CLONE ir<%exitcond6228.not> = icmp eq ir<%indvars.iv.next6225>, ir<%wide.trip.count6227>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 22 for VF 4 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width 4 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 21474836458, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 21474836458, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6224 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6225, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6224, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %526 = load i32, ptr %what, align 8, !tbaa !43 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %527 = zext i32 %526 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6231, %527 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %514, ptr %what, align 8, !tbaa !43 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next6225 = add nuw nsw i64 %indvars.iv6224, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6228.not = icmp eq i64 %indvars.iv.next6225, %wide.trip.count6227 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6228.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45365591937, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45365591937, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6242 = phi 0, %indvars.iv.next6243, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6242>
    CLONE store ir<-2>, ir<%arrayidx3866>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6242>
    CLONE store ir<-2>, ir<%arrayidx3868>
    CLONE ir<%indvars.iv.next6243> = add nuw nsw ir<%indvars.iv6242>, ir<1>
    CLONE ir<%exitcond6246.not> = icmp eq ir<%indvars.iv.next6243>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6242 = phi 0, %indvars.iv.next6243, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6242>
    vp<%4> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%4>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6242>
    vp<%5> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%indvars.iv.next6243> = add nuw nsw ir<%indvars.iv6242>, ir<1>
    CLONE ir<%exitcond6246.not> = icmp eq ir<%indvars.iv.next6243>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6242 = phi 0, %indvars.iv.next6243, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6242>
    vp<%4> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%4>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6242>
    vp<%5> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%indvars.iv.next6243> = add nuw nsw ir<%indvars.iv6242>, ir<1>
    CLONE ir<%exitcond6246.not> = icmp eq ir<%indvars.iv.next6243>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6242 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6243, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx3866, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6242 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx3868, align 4, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6243 = add nuw nsw i64 %indvars.iv6242, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6246.not = icmp eq i64 %indvars.iv.next6243, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6246.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%6>, ir<-2>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 59
Loops Epilogues Vectorized: 1
================================================
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1119 = phi 0, %indvars.iv.next1120, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1119>, ir<2>
    CLONE ir<%57> = load ir<%what>
    CLONE ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    CLONE store ir<%44>, ir<%what>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    CLONE ir<%indvars.iv.next1120> = add nuw nsw ir<%indvars.iv1119>, ir<1>
    CLONE ir<%exitcond1123.not> = icmp eq ir<%indvars.iv.next1120>, ir<%wide.trip.count1122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit1146>, scalar.ph

ir-bb<cleanup.loopexit1146>:
No successors

scalar.ph:
No successors
}

========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1119 = phi 0, %indvars.iv.next1120, ir<1>
    REPLICATE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1119>, ir<2>
    INTERLEAVE-GROUP with factor 6 at %57, ir<%what>
      ir<%57> = load from index 0
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    REPLICATE store ir<%44>, ir<%what>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    REPLICATE ir<%indvars.iv.next1120> = add nuw nsw ir<%indvars.iv1119>, ir<1>
    CLONE ir<%exitcond1123.not> = icmp eq ir<%indvars.iv.next1120>, ir<%wide.trip.count1122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1119 = phi 0, %indvars.iv.next1120, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1119>, ir<2>
    REPLICATE ir<%57> = load ir<%what>
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    REPLICATE store ir<%44>, ir<%what>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    WIDEN ir<%indvars.iv.next1120> = add nuw nsw ir<%indvars.iv1119>, ir<1>
    CLONE ir<%exitcond1123.not> = icmp eq ir<%indvars.iv.next1120>, ir<%wide.trip.count1122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1119 = phi 0, %indvars.iv.next1120, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1119>, ir<2>
    WIDEN ir<%57> = load ir<%what>
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    WIDEN store ir<%what>, ir<%44>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    WIDEN ir<%indvars.iv.next1120> = add nuw nsw ir<%indvars.iv1119>, ir<1>
    CLONE ir<%exitcond1123.not> = icmp eq ir<%indvars.iv.next1120>, ir<%wide.trip.count1122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 11 for VF 2 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 21474836466, RTCostB: 12884901882

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 22 for VF 4 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 19864223725, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 19864223725, RTCostB: 12884901882

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 45634027453, RTCostB: 12884901882

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1119 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1120, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1119, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %57 = load i32, ptr %what, align 8, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %44, ptr %what, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1120 = add nuw nsw i64 %indvars.iv1119, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1123.not = icmp eq i64 %indvars.iv.next1120, %wide.trip.count1122 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1123.not, label %cleanup.loopexit1146, label %for.body461 of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
RTCostA: 44560285572, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 44560285572, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    CLONE ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE ir<%1> = load ir<%subreg_loc>
    CLONE ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    CLONE ir<%2> = load ir<%arrayidx>, vp<%4>
    CLONE ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    CLONE store ir<%y>, ir<%arrayidx>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    CLONE store ir<%y.sink>, ir<%subreg_loc>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    REPLICATE ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    INTERLEAVE-GROUP with factor 3 at %1, ir<%subreg_loc>
      ir<%1> = load from index 0
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    REPLICATE ir<%2> = load ir<%arrayidx>, vp<%4>
    WIDEN ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    REPLICATE store ir<%y>, ir<%arrayidx>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    REPLICATE store ir<%y.sink>, ir<%subreg_loc>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE ir<%1> = load ir<%subreg_loc>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    REPLICATE ir<%2> = load ir<%arrayidx>, vp<%4>
    WIDEN ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    REPLICATE store ir<%y>, ir<%arrayidx>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    REPLICATE store ir<%y.sink>, ir<%subreg_loc>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%1> = load ir<%subreg_loc>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    WIDEN ir<%2> = load ir<%arrayidx>, vp<%4>
    WIDEN ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    WIDEN store ir<%arrayidx>, ir<%y>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    WIDEN store ir<%subreg_loc>, ir<%y.sink>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %y, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store ptr %y, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3000014
A is not scalable.	B is not scalable.	
RTCostA: 6442482076512875, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 6442482076512875, RTCostB: 17179869176

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %y, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %y, ptr %arrayidx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 42
A is scalable.	B is not scalable.	
RTCostA: 90731183983, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 90731183983, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o reload1.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                reload1.c
========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1210 to i64) + (-1 * (1 umin (zext i32 %cond115.1210 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %43, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    CLONE ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    CLONE ir<%45> = add nsw ir<%indvars.iv.next.1>, ir<%44>
    CLONE ir<%shl122.1> = shl nuw ir<1>, ir<%45>
    CLONE ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1210 to i64) + (-1 * (1 umin (zext i32 %cond115.1210 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %43, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%45> = add nsw ir<%indvars.iv.next.1>, ir<%44>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%45>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1210 to i64) + (-1 * (1 umin (zext i32 %cond115.1210 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %43, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%45> = add nsw ir<%indvars.iv.next.1>, ir<%44>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%45>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}


-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv.1 = phi i64 [ %43, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %45 = add nsw i64 %indvars.iv.next.1, %44 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl122.1 = shl nuw i64 1, %45 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv.1 = phi i64 [ %43, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %45 = add nsw i64 %indvars.iv.next.1, %44 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl122.1 = shl nuw i64 1, %45 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv.1 = phi i64 [ %43, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %45 = add nsw i64 %indvars.iv.next.1, %44 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl122.1 = shl nuw i64 1, %45 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv.1 = phi i64 [ %43, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %45 = add nsw i64 %indvars.iv.next.1, %44 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl122.1 = shl nuw i64 1, %45 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: compute_use_by_pseudos at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1210 to i64) + (-1 * (1 umin (zext i32 %cond115.1210 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %43, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%45> = add nsw ir<%indvars.iv.next.1>, ir<%44>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%45>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115207 to i64) + (-1 * (1 umin (zext i32 %cond115207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %21, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%23> = add nsw ir<%indvars.iv.next>, ir<%22>
    CLONE ir<%shl122> = shl nuw ir<1>, ir<%23>
    CLONE ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115207 to i64) + (-1 * (1 umin (zext i32 %cond115207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %21, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%23> = add nsw ir<%indvars.iv.next>, ir<%22>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%23>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115207 to i64) + (-1 * (1 umin (zext i32 %cond115207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %21, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%23> = add nsw ir<%indvars.iv.next>, ir<%22>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%23>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %21, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %23 = add nsw i64 %indvars.iv.next, %22 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl122 = shl nuw i64 1, %23 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %21, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %23 = add nsw i64 %indvars.iv.next, %22 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl122 = shl nuw i64 1, %23 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %21, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %23 = add nsw i64 %indvars.iv.next, %22 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl122 = shl nuw i64 1, %23 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %21, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %23 = add nsw i64 %indvars.iv.next, %22 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl122 = shl nuw i64 1, %23 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: compute_use_by_pseudos at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115207 to i64) + (-1 * (1 umin (zext i32 %cond115207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %21, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%23> = add nsw ir<%indvars.iv.next>, ir<%22>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%23>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%12> = load ir<%arrayidx>
    CLONE ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%13> = load ir<%arrayidx45>
    CLONE ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%3> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    CLONE store ir<1>, ir<%arrayidx49>, vp<%3>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%4> = not ir<%tobool43.not>
    EMIT vp<%5> = not ir<%tobool46.not>
    EMIT vp<%6> = logical-and ir<%tobool43.not>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, vp<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%3>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%4>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%5> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%6>, ir<1>, vp<%5>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%7> = not ir<%tobool43.not>
    EMIT vp<%8> = not ir<%tobool46.not>
    EMIT vp<%9> = logical-and ir<%tobool43.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%3>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%4>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%5> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%6>, ir<1>, vp<%5>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%7> = not ir<%tobool43.not>
    EMIT vp<%8> = not ir<%tobool46.not>
    EMIT vp<%9> = logical-and ir<%tobool43.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 579, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 579, RTCostB: 371

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 371, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 371, RTCostB: 371

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 311, RTCostB: 371
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 311, RTCostB: 371
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 293, RTCostB: 371
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 293, RTCostB: 311
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 293

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 371
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 293
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 77, RTCostB: 371
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 77, RTCostB: 98
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 56, RTCostB: 371
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 56, RTCostB: 77
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %12 = load i8, ptr %arrayidx, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %13 = load i8, ptr %arrayidx45, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx49, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 154, RTCostB: 371
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 154, RTCostB: 56
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 311
A is scalable.	B is scalable.	
RTCostA: 77, RTCostB: 98
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: reload at line: reload1.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%5>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
    EMIT vp<%6> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%7>, ir<1>, vp<%6>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%31> = load vp<%4>
    WIDEN ir<%tobool43.not> = icmp eq ir<%31>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%32> = load vp<%5>
    WIDEN ir<%tobool46.not> = icmp eq ir<%32>, ir<0>
    EMIT vp<%6> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%7>, ir<1>, vp<%6>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1592 = phi %indvars.iv.next1593, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1592>
    CLONE ir<%63> = load ir<%arrayidx135>
    CLONE ir<%tobool136.not> = icmp eq ir<%63>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1592>
    CLONE store ir<1>, ir<%arrayidx139>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%3> = not ir<%tobool136.not>
    EMIT vp<%4> = or vp<%3>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1593> = add nuw nsw ir<%indvars.iv1592>, ir<1>
    CLONE ir<%exitcond1595.not> = icmp eq ir<%indvars.iv.next1593>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1592 = phi %indvars.iv.next1593, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1592>
    vp<%3> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%63> = load vp<%3>
    WIDEN ir<%tobool136.not> = icmp eq ir<%63>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1592>
    vp<%4> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%4>, ir<1>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%5> = not ir<%tobool136.not>
    EMIT vp<%6> = or vp<%5>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1593> = add nuw nsw ir<%indvars.iv1592>, ir<1>
    CLONE ir<%exitcond1595.not> = icmp eq ir<%indvars.iv.next1593>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1592 = phi %indvars.iv.next1593, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1592>
    vp<%3> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%63> = load vp<%3>
    WIDEN ir<%tobool136.not> = icmp eq ir<%63>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1592>
    vp<%4> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%4>, ir<1>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%5> = not ir<%tobool136.not>
    EMIT vp<%6> = or vp<%5>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1593> = add nuw nsw ir<%indvars.iv1592>, ir<1>
    CLONE ir<%exitcond1595.not> = icmp eq ir<%indvars.iv.next1593>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 448, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 448, RTCostB: 318

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 331, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 331, RTCostB: 318

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 318
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 282, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 282, RTCostB: 294
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 282

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 71, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 71, RTCostB: 282
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 60, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 60, RTCostB: 71
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 45, RTCostB: 60
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv1592 = phi i64 [ %indvars.iv.next1593, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %63 = load i8, ptr %arrayidx135, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool136.not = icmp eq i8 %63, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1592 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx139, align 1, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next1593 = add nuw nsw i64 %indvars.iv1592, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond1595.not = icmp eq i64 %indvars.iv.next1593, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond1595.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 131, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 131, RTCostB: 45
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is scalable.	B is not scalable.	
RTCostA: 71, RTCostB: 294
A is scalable.	B is scalable.	
RTCostA: 60, RTCostB: 71
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: reload at line: reload1.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%63> = load vp<%4>
    WIDEN ir<%tobool136.not> = icmp eq ir<%63>, ir<0>
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%5>, ir<1>, ir<%tobool136.not>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%78> = load vp<%4>
    WIDEN ir<%tobool136.not> = icmp eq ir<%78>, ir<0>
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%5>, ir<1>, ir<%tobool136.not>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv1612 = phi 0, %indvars.iv.next1613, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1612>
    CLONE ir<%255> = load ir<%arrayidx1147>
    CLONE ir<%tobool1149.not> = icmp eq ir<%255>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%3> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1612>
    CLONE ir<%256> = load ir<%arrayidx1152>
    CLONE ir<%tobool1153.not> = icmp eq ir<%256>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%4> = logical-and vp<%3>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1612>
    CLONE ir<%257> = load ir<%arrayidx1156>
    CLONE ir<%tobool1158.not> = icmp eq ir<%257>, ir<0>
    CLONE ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    CLONE ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%5> = or vp<%4>, ir<%tobool1149.not>
    EMIT vp<%6> = not ir<%tobool1153.not>
    EMIT vp<%7> = logical-and vp<%3>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%4>
    CLONE ir<%indvars.iv.next1613> = add nuw nsw ir<%indvars.iv1612>, ir<1>
    CLONE ir<%exitcond1615.not> = icmp eq ir<%indvars.iv.next1613>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%12> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%11>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv1612 = phi 0, %indvars.iv.next1613, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1612>
    vp<%3> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%255> = load vp<%3>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%255>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%4> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv1612>
    vp<%5> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%256> = load vp<%5>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%256>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv1612>
    vp<%7> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%257> = load vp<%7>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%257>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%8> = or vp<%6>, ir<%tobool1149.not>
    EMIT vp<%9> = not ir<%tobool1153.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%6>
    CLONE ir<%indvars.iv.next1613> = add nuw nsw ir<%indvars.iv1612>, ir<1>
    CLONE ir<%exitcond1615.not> = icmp eq ir<%indvars.iv.next1613>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%15> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%14>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv1612 = phi 0, %indvars.iv.next1613, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1612>
    vp<%3> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%255> = load vp<%3>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%255>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%4> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv1612>
    vp<%5> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%256> = load vp<%5>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%256>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv1612>
    vp<%7> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%257> = load vp<%7>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%257>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%8> = or vp<%6>, ir<%tobool1149.not>
    EMIT vp<%9> = not ir<%tobool1153.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%6>
    CLONE ir<%indvars.iv.next1613> = add nuw nsw ir<%indvars.iv1612>, ir<1>
    CLONE ir<%exitcond1615.not> = icmp eq ir<%indvars.iv.next1613>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%15> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%14>
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 2 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 814, RTCostB: 424
A is not scalable.	B is not scalable.	
RTCostA: 814, RTCostB: 424

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 2 for VF 4 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 160 for VF 4 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 4 costs: 43
A is not scalable.	B is not scalable.	
RTCostA: 2283, RTCostB: 424
A is not scalable.	B is not scalable.	
RTCostA: 2283, RTCostB: 424

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 4 for VF 8 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 320 for VF 8 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 8 costs: 42
A is not scalable.	B is not scalable.	
RTCostA: 2056, RTCostB: 424
A is not scalable.	B is not scalable.	
RTCostA: 2056, RTCostB: 424

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 16 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 8 for VF 16 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 640 for VF 16 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 16 costs: 41
A is not scalable.	B is not scalable.	
RTCostA: 2032, RTCostB: 424
A is not scalable.	B is not scalable.	
RTCostA: 2032, RTCostB: 424

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 424
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 424

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1612 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1613, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %255 = load i8, ptr %arrayidx1147, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1149.not = icmp eq i8 %255, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %256 = load i8, ptr %arrayidx1152, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1153.not = icmp eq i8 %256, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1612 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %257 = load i8, ptr %arrayidx1156, align 1, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1158.not = icmp eq i8 %257, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1613 = add nuw nsw i64 %indvars.iv1612, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1615.not = icmp eq i64 %indvars.iv.next1613, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1615.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 424
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 424
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%255> = load vp<%4>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%255>, ir<0>
    EMIT vp<%5> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%256> = load vp<%6>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%256>, ir<0>
    EMIT vp<%7> = logical-and vp<%5>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%8> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%257> = load vp<%8>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%257>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%7>
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%12> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%11>
}
================ Final VPlan ================

@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %314 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1616 = phi 0, %indvars.iv.next1617, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1616>
    CLONE ir<%315> = load ir<%arrayidx1199>
    CLONE ir<%conv1200> = sext ir<%315>
    CLONE ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    CLONE ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    CLONE ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1617> = add nuw nsw ir<%indvars.iv1616>, ir<1>
    CLONE ir<%exitcond1619.not> = icmp eq ir<%indvars.iv.next1617>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%6>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %314 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1616 = phi 0, %indvars.iv.next1617, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1616>
    vp<%4> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%315> = load vp<%4>
    WIDEN-CAST ir<%conv1200> = sext  ir<%315> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1617> = add nuw nsw ir<%indvars.iv1616>, ir<1>
    CLONE ir<%exitcond1619.not> = icmp eq ir<%indvars.iv.next1617>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%7>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %314 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1616 = phi 0, %indvars.iv.next1617, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1616>
    vp<%4> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%315> = load vp<%4>
    WIDEN-CAST ir<%conv1200> = sext  ir<%315> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1617> = add nuw nsw ir<%indvars.iv1616>, ir<1>
    CLONE ir<%exitcond1619.not> = icmp eq ir<%indvars.iv.next1617>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%7>
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418237, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418237, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450953, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450953, RTCostB: 10737418237
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 6 for VF 8 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5637144604, RTCostB: 15032385529
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5637144604, RTCostB: 6442450953
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5637144604

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1616 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1617, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1616 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %315 = load i16, ptr %arrayidx1199, align 2, !tbaa !36 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv1200 = sext i16 %315 to i64 of type:sext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1617 = add nuw nsw i64 %indvars.iv1616, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1619.not = icmp eq i64 %indvars.iv.next1617, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1619.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225487, RTCostB: 5637144604
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %314 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%315> = load vp<%5>
    WIDEN-CAST ir<%conv1200> = sext  ir<%315> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 19
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE ir<%7> = load ir<%arrayidx25>
    CLONE ir<%bf.load26> = load ir<%7>
    CLONE ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    CLONE ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    CLONE ir<%8> = load ir<%fld30>, ir<%cmp28>
    CLONE ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    CLONE ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    CLONE ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%4> = logical-and ir<%cmp28>, ir<%cmp34>
    CLONE ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    CLONE ir<%9> = load ir<%fld39>, vp<%4>
    CLONE ir<%10> = and ir<%9>, ir<-8>
    CLONE ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%5> = logical-and vp<%4>, ir<%or.cond339>
    CLONE ir<%sh_prom> = zext nneg ir<%9>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%6> = not ir<%or.cond339>
    EMIT vp<%7> = logical-and vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    EMIT vp<%9> = not ir<%cmp34>
    EMIT vp<%10> = logical-and ir<%cmp28>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    EMIT vp<%12> = not ir<%cmp28>
    EMIT vp<%13> = or vp<%11>, vp<%12>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%7> ir<%clobbered.0348>/vp<%10> ir<%clobbered.0348>/vp<%12>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%16>
}

========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%4>
    REPLICATE ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    REPLICATE ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    REPLICATE ir<%8> = load ir<%fld30>, ir<%cmp28>
    REPLICATE ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%5> = logical-and ir<%cmp28>, ir<%cmp34>
    REPLICATE ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    REPLICATE ir<%9> = load ir<%fld39>, vp<%5>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%6> = logical-and vp<%5>, ir<%or.cond339>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    EMIT vp<%10> = not ir<%cmp34>
    EMIT vp<%11> = logical-and ir<%cmp28>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = not ir<%cmp28>
    EMIT vp<%14> = or vp<%12>, vp<%13>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%11> ir<%clobbered.0348>/vp<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%17>
}

========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%4>
    REPLICATE ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    REPLICATE ir<%8> = load ir<%fld30>, ir<%cmp28>
    REPLICATE ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%5> = logical-and ir<%cmp28>, ir<%cmp34>
    WIDEN-GEP Var[Inv] ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    REPLICATE ir<%9> = load ir<%fld39>, vp<%5>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%6> = logical-and vp<%5>, ir<%or.cond339>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    EMIT vp<%10> = not ir<%cmp34>
    EMIT vp<%11> = logical-and ir<%cmp28>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = not ir<%cmp28>
    EMIT vp<%14> = or vp<%12>, vp<%13>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%11> ir<%clobbered.0348>/vp<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%17>
}

========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%4>
    WIDEN ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    WIDEN ir<%8> = load ir<%fld30>, ir<%cmp28>
    WIDEN ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%5> = logical-and ir<%cmp28>, ir<%cmp34>
    WIDEN-GEP Var[Inv] ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    WIDEN ir<%9> = load ir<%fld39>, vp<%5>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%6> = logical-and vp<%5>, ir<%or.cond339>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    EMIT vp<%10> = not ir<%cmp34>
    EMIT vp<%11> = logical-and ir<%cmp28>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = not ir<%cmp28>
    EMIT vp<%14> = or vp<%12>, vp<%13>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%11> ir<%clobbered.0348>/vp<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%17>
}


-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %8 = load ptr, ptr %fld30, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i32, ptr %fld39, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %8 = load ptr, ptr %fld30, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %9 = load i32, ptr %fld39, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 18 for VF 2 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width 2 costs: 4500033
A is not scalable.	B is not scalable.	
RTCostA: 9663748347702155, RTCostB: 30064771058
A is not scalable.	B is not scalable.	
RTCostA: 9663748347702155, RTCostB: 30064771058

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %8 = load ptr, ptr %fld30, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %9 = load i32, ptr %fld39, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 240 for VF 4 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width 4 costs: 2250083
A is not scalable.	B is not scalable.	
RTCostA: 4832016440142494, RTCostB: 30064771058
A is not scalable.	B is not scalable.	
RTCostA: 4832016440142494, RTCostB: 30064771058

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = load ptr, ptr %fld30, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i32, ptr %fld39, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %8 = load ptr, ptr %fld30, align 8, !tbaa !16 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %9 = load i32, ptr %fld39, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width vscale x 2 costs: 44
A is scalable.	B is not scalable.	
RTCostA: 95563022200, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: 95563022200, RTCostB: 30064771058
LV: Selecting VF: 1 With Cost: 14.
maxbefore: 2
maxafter: 2
========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv287 = phi %25, %indvars.iv.next288, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv287>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and192> = and ir<%and192284>, ir<%not>
    CLONE ir<%indvars.iv.next288> = add nuw nsw ir<%indvars.iv287>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next288>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}

========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv287 = phi %25, %indvars.iv.next288, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv287>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    WIDEN ir<%indvars.iv.next288> = add nuw nsw ir<%indvars.iv287>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next288>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}

========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv287 = phi %25, %indvars.iv.next288, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv287>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    WIDEN ir<%indvars.iv.next288> = add nuw nsw ir<%indvars.iv287>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next288>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}


-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv287 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next288, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv287 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next288 = add nuw nsw i64 %indvars.iv287, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next288, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv287 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next288, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv287 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next288 = add nuw nsw i64 %indvars.iv287, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next288, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv287 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next288, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv287 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next288 = add nuw nsw i64 %indvars.iv287, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next288, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv287 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next288, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv287 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next288 = add nuw nsw i64 %indvars.iv287, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next288, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: clear_reload_reg_in_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv287 = phi %25, %indvars.iv.next288, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv287>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 55
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1139 = phi 0, %indvars.iv.next1140, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1139>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    CLONE store ir<0>, ir<%store_ruid>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1139>
    CLONE ir<%16> = load ir<%arrayidx45>
    CLONE ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    CLONE ir<%spec.select1164> = select ir<%tobool46.not>, ir<6>, ir<-1>
    CLONE ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    CLONE store ir<%spec.select1164>, ir<%17>
    CLONE ir<%indvars.iv.next1140> = add nuw nsw ir<%indvars.iv1139>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1140>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1139 = phi 0, %indvars.iv.next1140, ir<1>
    REPLICATE ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1139>
    REPLICATE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    REPLICATE store ir<0>, ir<%store_ruid>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1139>
    vp<%3> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%3>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1164> = select ir<%tobool46.not>, ir<6>, ir<-1>
    REPLICATE ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    REPLICATE store ir<%spec.select1164>, ir<%17>
    REPLICATE ir<%indvars.iv.next1140> = add nuw nsw ir<%indvars.iv1139>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1140>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1139 = phi 0, %indvars.iv.next1140, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1139>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    REPLICATE store ir<0>, ir<%store_ruid>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1139>
    vp<%3> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%3>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1164> = select ir<%tobool46.not>, ir<6>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    REPLICATE store ir<%spec.select1164>, ir<%17>
    WIDEN ir<%indvars.iv.next1140> = add nuw nsw ir<%indvars.iv1139>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1140>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1139 = phi 0, %indvars.iv.next1140, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1139>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    WIDEN store ir<%store_ruid>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1139>
    vp<%3> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%3>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1164> = select ir<%tobool46.not>, ir<6>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    WIDEN store ir<%17>, ir<%spec.select1164>
    WIDEN ir<%indvars.iv.next1140> = add nuw nsw ir<%indvars.iv1139>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1140>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 2 costs: 32
A is not scalable.	B is not scalable.	
RTCostA: 1674, RTCostB: 530
A is not scalable.	B is not scalable.	
RTCostA: 1674, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 4 costs: 29
A is not scalable.	B is not scalable.	
RTCostA: 1544, RTCostB: 530
A is not scalable.	B is not scalable.	
RTCostA: 1544, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 8 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 8 costs: 28
A is not scalable.	B is not scalable.	
RTCostA: 1430, RTCostB: 530
A is not scalable.	B is not scalable.	
RTCostA: 1430, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF 16 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 16 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 16 costs: 28
A is not scalable.	B is not scalable.	
RTCostA: 1418, RTCostB: 530
A is not scalable.	B is not scalable.	
RTCostA: 1418, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 530
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1141, RTCostB: 530
A is scalable.	B is not scalable.	
RTCostA: 1141, RTCostB: 530

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1139 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1140, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %store_ruid, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1139 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i8, ptr %arrayidx45, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select1164 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %spec.select1164, ptr %17, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1140 = add nuw nsw i64 %indvars.iv1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1140, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1142.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1058, RTCostB: 530
A is scalable.	B is not scalable.	
RTCostA: 1058, RTCostB: 530
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, vp<%3>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    CLONE store ir<0>, ir<%store_ruid>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    CLONE ir<%16> = load ir<%arrayidx45>
    CLONE ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    CLONE ir<%spec.select1164> = select ir<%tobool46.not>, ir<6>, ir<-1>
    CLONE ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    CLONE store ir<%spec.select1164>, ir<%17>
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1154 = phi 0, %indvars.iv.next1155, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1154>
    CLONE ir<%91> = load ir<%arrayidx611>
    CLONE ir<%tobool612.not> = icmp eq ir<%91>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%3> = not ir<%tobool612.not>
    CLONE ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1154>
    CLONE ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    CLONE store ir<6>, ir<%use_index616>, vp<%3>
    CLONE ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    CLONE store ir<%90>, ir<%store_ruid619>, vp<%3>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%4> = or ir<%tobool612.not>, vp<%3>
    CLONE ir<%indvars.iv.next1155> = add nuw nsw ir<%indvars.iv1154>, ir<1>
    CLONE ir<%exitcond1157.not> = icmp eq ir<%indvars.iv.next1155>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1154 = phi 0, %indvars.iv.next1155, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1154>
    vp<%3> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%91> = load vp<%3>
    WIDEN ir<%tobool612.not> = icmp eq ir<%91>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%4> = not ir<%tobool612.not>
    REPLICATE ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1154>
    REPLICATE ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    REPLICATE store ir<6>, ir<%use_index616>, vp<%4>
    REPLICATE ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    REPLICATE store ir<%90>, ir<%store_ruid619>, vp<%4>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%5> = or ir<%tobool612.not>, vp<%4>
    REPLICATE ir<%indvars.iv.next1155> = add nuw nsw ir<%indvars.iv1154>, ir<1>
    CLONE ir<%exitcond1157.not> = icmp eq ir<%indvars.iv.next1155>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1154 = phi 0, %indvars.iv.next1155, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1154>
    vp<%3> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%91> = load vp<%3>
    WIDEN ir<%tobool612.not> = icmp eq ir<%91>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%4> = not ir<%tobool612.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1154>
    WIDEN-GEP Var[Inv] ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    REPLICATE store ir<6>, ir<%use_index616>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    REPLICATE store ir<%90>, ir<%store_ruid619>, vp<%4>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%5> = or ir<%tobool612.not>, vp<%4>
    WIDEN ir<%indvars.iv.next1155> = add nuw nsw ir<%indvars.iv1154>, ir<1>
    CLONE ir<%exitcond1157.not> = icmp eq ir<%indvars.iv.next1155>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1154 = phi 0, %indvars.iv.next1155, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1154>
    vp<%3> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%91> = load vp<%3>
    WIDEN ir<%tobool612.not> = icmp eq ir<%91>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%4> = not ir<%tobool612.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1154>
    WIDEN-GEP Var[Inv] ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    WIDEN store ir<%use_index616>, ir<6>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    WIDEN store ir<%store_ruid619>, ir<%90>, vp<%4>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%5> = or ir<%tobool612.not>, vp<%4>
    WIDEN ir<%indvars.iv.next1155> = add nuw nsw ir<%indvars.iv1154>, ir<1>
    CLONE ir<%exitcond1157.not> = icmp eq ir<%indvars.iv.next1155>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 17 for VF 2 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 2 costs: 1500014
A is not scalable.	B is not scalable.	
RTCostA: 78000735, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 78000735, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 34 for VF 4 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 4 costs: 750011
A is not scalable.	B is not scalable.	
RTCostA: 39000618, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 39000618, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 16 for VF 8 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 68 for VF 8 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 8 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 8 costs: 375011
A is not scalable.	B is not scalable.	
RTCostA: 18000563, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 18000563, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 32 for VF 16 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF 16 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 136 for VF 16 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 16 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 16 costs: 187510
A is not scalable.	B is not scalable.	
RTCostA: 9000551, RTCostB: 371
A is not scalable.	B is not scalable.	
RTCostA: 9000551, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 1125, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: 1125, RTCostB: 371

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1154 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1155, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %91 = load i8, ptr %arrayidx611, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool612.not = icmp eq i8 %91, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1154 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index616, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %90, ptr %store_ruid619, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1155 = add nuw nsw i64 %indvars.iv1154, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1157.not = icmp eq i64 %indvars.iv.next1155, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1157.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
RTCostA: 1037, RTCostB: 371
A is scalable.	B is not scalable.	
RTCostA: 1037, RTCostB: 371
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1151 = phi 52, %indvars.iv.next1152, ir<-1>
    CLONE ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1151>
    CLONE ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    CLONE ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    CLONE ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1151>, ir<1>
    CLONE store ir<-1>, ir<%use_index800>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    CLONE ir<%indvars.iv.next1152> = add nsw ir<%indvars.iv1151>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1151>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1166>, scalar.ph

ir-bb<if.end806.loopexit1166>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1151 = phi 52, %indvars.iv.next1152, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1151>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    REPLICATE ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1151>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index800>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    WIDEN ir<%indvars.iv.next1152> = add nsw ir<%indvars.iv1151>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1151>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1166>, scalar.ph

ir-bb<if.end806.loopexit1166>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1151 = phi 52, %indvars.iv.next1152, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1151>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1151>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index800>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    WIDEN ir<%indvars.iv.next1152> = add nsw ir<%indvars.iv1151>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1151>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1166>, scalar.ph

ir-bb<if.end806.loopexit1166>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1151 = phi 52, %indvars.iv.next1152, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1151>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1151>, ir<1>
    WIDEN store ir<%use_index800>, ir<-1>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    WIDEN ir<%indvars.iv.next1152> = add nsw ir<%indvars.iv1151>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1151>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1166>, scalar.ph

ir-bb<if.end806.loopexit1166>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 291, RTCostB: 265
A is not scalable.	B is not scalable.	
RTCostA: 291, RTCostB: 265

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 278, RTCostB: 265
A is not scalable.	B is not scalable.	
RTCostA: 278, RTCostB: 265

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 265
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 265

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 603, RTCostB: 265
A is scalable.	B is not scalable.	
RTCostA: 603, RTCostB: 265

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1151 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1152, %for.inc802 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1151 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1151, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index800, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1152 = add nsw i64 %indvars.iv1151, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1151, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1166, label %for.body792 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 565, RTCostB: 265
A is scalable.	B is not scalable.	
RTCostA: 565, RTCostB: 265
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
LV: Decision: Scalarize
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
LV: Decision: Scalarize
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
LV: Decision: Scalarize
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
LV: Decision: Scalarize
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1143 = phi %indvars.iv.next1144, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1143>
    CLONE ir<%36> = load ir<%arrayidx77>
    CLONE ir<%tobool78.not> = icmp eq ir<%36>, ir<0>
  Successor(s): if.then79

  if.then79:
    CLONE ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1143>, ir<1>
    CLONE store ir<6>, ir<%use_index82>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%3> = not ir<%tobool78.not>
    EMIT vp<%4> = or vp<%3>, ir<%tobool78.not>
    CLONE ir<%indvars.iv.next1144> = add nuw nsw ir<%indvars.iv1143>, ir<1>
    CLONE ir<%exitcond1146.not> = icmp eq ir<%indvars.iv.next1144>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1143 = phi %indvars.iv.next1144, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1143>
    vp<%3> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%36> = load vp<%3>
    WIDEN ir<%tobool78.not> = icmp eq ir<%36>, ir<0>
  Successor(s): if.then79

  if.then79:
    REPLICATE ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1143>, ir<1>
    REPLICATE store ir<6>, ir<%use_index82>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = not ir<%tobool78.not>
    EMIT vp<%5> = or vp<%4>, ir<%tobool78.not>
    REPLICATE ir<%indvars.iv.next1144> = add nuw nsw ir<%indvars.iv1143>, ir<1>
    CLONE ir<%exitcond1146.not> = icmp eq ir<%indvars.iv.next1144>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1143 = phi %indvars.iv.next1144, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1143>
    vp<%3> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%36> = load vp<%3>
    WIDEN ir<%tobool78.not> = icmp eq ir<%36>, ir<0>
  Successor(s): if.then79

  if.then79:
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1143>, ir<1>
    REPLICATE store ir<6>, ir<%use_index82>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = not ir<%tobool78.not>
    EMIT vp<%5> = or vp<%4>, ir<%tobool78.not>
    WIDEN ir<%indvars.iv.next1144> = add nuw nsw ir<%indvars.iv1143>, ir<1>
    CLONE ir<%exitcond1146.not> = icmp eq ir<%indvars.iv.next1144>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1143 = phi %indvars.iv.next1144, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1143>
    vp<%3> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%36> = load vp<%3>
    WIDEN ir<%tobool78.not> = icmp eq ir<%36>, ir<0>
  Successor(s): if.then79

  if.then79:
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1143>, ir<1>
    WIDEN store ir<%use_index82>, ir<6>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = not ir<%tobool78.not>
    EMIT vp<%5> = or vp<%4>, ir<%tobool78.not>
    WIDEN ir<%indvars.iv.next1144> = add nuw nsw ir<%indvars.iv1143>, ir<1>
    CLONE ir<%exitcond1146.not> = icmp eq ir<%indvars.iv.next1144>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 344, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 344, RTCostB: 318

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 227, RTCostB: 318
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 227, RTCostB: 318
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 16 for VF 8 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 198, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 198, RTCostB: 227
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 32 for VF 16 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Found an estimated cost of 16 for VF 16 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 16 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 186, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 186, RTCostB: 198
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 186

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 591, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: 591, RTCostB: 186

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1143 = phi i64 [ %indvars.iv.next1144, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %36 = load i8, ptr %arrayidx77, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool78.not = icmp eq i8 %36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1143, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index82, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1144 = add nuw nsw i64 %indvars.iv1143, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1146.not = icmp eq i64 %indvars.iv.next1144, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1146.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 546, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: 546, RTCostB: 186
LV: Selecting VF: 16 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Vectorizing epilogue loop with VF = 4 at function: reload_combine at line: reload1.c
LEV: EpilogueVF.Width: 4
Executing best plan with VF=16, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%36> = load vp<%4>
    WIDEN ir<%tobool78.not> = icmp eq ir<%36>, ir<0>
  Successor(s): pred.store

  <xVFxUF> pred.store: {
    pred.store.entry:
      BRANCH-ON-MASK ir<%tobool78.not>
    Successor(s): pred.store.if, pred.store.continue

    pred.store.if:
      REPLICATE ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, vp<%3>, ir<1>
      REPLICATE store ir<6>, ir<%use_index82>
    Successor(s): pred.store.continue

    pred.store.continue:
    No successors
  }
  Successor(s): if.then79.0

  if.then79.0:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=4, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%88> = load vp<%4>
    WIDEN ir<%tobool78.not> = icmp eq ir<%88>, ir<0>
  Successor(s): pred.store

  <xVFxUF> pred.store: {
    pred.store.entry:
      BRANCH-ON-MASK ir<%tobool78.not>
    Successor(s): pred.store.if, pred.store.continue

    pred.store.if:
      REPLICATE ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, vp<%3>, ir<1>
      REPLICATE store ir<6>, ir<%use_index82>
    Successor(s): pred.store.continue

    pred.store.continue:
    No successors
  }
  Successor(s): if.then79.0

  if.then79.0:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 67
Loops Epilogues Vectorized: 3
================================================
MVT: v8i8
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 44 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 88 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)-> ShuffleCost(8) = LT.first(4) * (2) -> ASM: [REV64, EXT]
MVT: v2i32
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 11 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 22 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v8i8
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 44 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(40)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 88 -> VectorType: <16 x i32> -> ttilog -> MaskedMemoryOpCost(80)-> ShuffleCost(8) = LT.first(4) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%37> = load ir<%arrayidx337>
    CLONE ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%3> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr inbounds ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx341>, vp<%3>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%4> = or ir<%tobool338.not>, vp<%3>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%3>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%4> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%5>, ir<0>, vp<%4>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%6> = or ir<%tobool338.not>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%3>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%4> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%5>, ir<0>, vp<%4>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%6> = or ir<%tobool338.not>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 2 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 500, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 500, RTCostB: 318

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 22 for VF 4 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 370, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 370, RTCostB: 318

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 44 for VF 8 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 8 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 324, RTCostB: 318
A is not scalable.	B is not scalable.	
RTCostA: 324, RTCostB: 318

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 88 for VF 16 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 312, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 312, RTCostB: 318
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 318
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 312

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 97, RTCostB: 312
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %37 = load i8, ptr %arrayidx337, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx341, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 72, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 72, RTCostB: 97
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: reload_cse_move2add at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<52> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%5>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
    EMIT vp<%6> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, vp<%4>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%7>, ir<0>, vp<%6>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 69
Loops Epilogues Vectorized: 3
================================================
========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%add> = add ir<%8>, ir<%9>
    CLONE ir<%sh_prom> = zext nneg ir<%add>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}


-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418240

-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 21474836475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: find_reg at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 10
Loops Analyzed: 95
Loops Epilogues Vectorized: 3
================================================
MVT: v2i32
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98141 to i64) + (-1 * (1 umin (zext i32 %cond98141 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    CLONE ir<%25> = load ir<%arrayidx103>
    CLONE ir<%add104> = add nsw ir<%25>, ir<%2>
    CLONE store ir<%add104>, ir<%arrayidx103>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98141 to i64) + (-1 * (1 umin (zext i32 %cond98141 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%4>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%5>, ir<%add104>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98141 to i64) + (-1 * (1 umin (zext i32 %cond98141 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%4>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%5>, ir<%add104>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934584
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934584
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354574, RTCostB: 8589934584
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354574, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934584
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354574

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2147483664, RTCostB: 8589934584
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483664, RTCostB: 2684354574
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %25 = load i32, ptr %arrayidx103, align 4, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add104, ptr %arrayidx103, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741872, RTCostB: 8589934584
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741872, RTCostB: 2147483664
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: count_pseudo at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98141 to i64) + (-1 * (1 umin (zext i32 %cond98141 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%22> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%6>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%7>, ir<%add104>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 11
Loops Analyzed: 96
Loops Epilogues Vectorized: 3
================================================
MVT: v2i32
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    CLONE ir<%26> = load ir<%arrayidx107>
    CLONE ir<%sub108> = sub nsw ir<%26>, ir<%21>
    CLONE store ir<%sub108>, ir<%arrayidx107>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%4>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%5>, ir<%sub108>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%4>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%5>, ir<%sub108>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934584
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934584
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354574, RTCostB: 8589934584
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354574, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934584
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354574

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2147483664, RTCostB: 8589934584
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483664, RTCostB: 2684354574
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %26 = load i32, ptr %arrayidx107, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741872, RTCostB: 8589934584
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741872, RTCostB: 2147483664
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: count_spilled_pseudo at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%23> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%6>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%7>, ir<%sub108>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 12
Loops Analyzed: 97
Loops Epilogues Vectorized: 3
================================================
========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2293 = phi 0, %indvars.iv.next2294, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    CLONE ir<%87> = add nsw ir<%indvars.iv2293>, ir<%idxprom214>
    CLONE ir<%shl559> = shl nuw ir<1>, ir<%87>
    CLONE ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    CLONE ir<%indvars.iv.next2294> = add nuw nsw ir<%indvars.iv2293>, ir<1>
    CLONE ir<%exitcond2299.not> = icmp eq ir<%indvars.iv.next2294>, ir<%wide.trip.count2298>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2293 = phi 0, %indvars.iv.next2294, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%87> = add nsw ir<%indvars.iv2293>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%87>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    WIDEN ir<%indvars.iv.next2294> = add nuw nsw ir<%indvars.iv2293>, ir<1>
    CLONE ir<%exitcond2299.not> = icmp eq ir<%indvars.iv.next2294>, ir<%wide.trip.count2298>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2293 = phi 0, %indvars.iv.next2294, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%87> = add nsw ir<%indvars.iv2293>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%87>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    WIDEN ir<%indvars.iv.next2294> = add nuw nsw ir<%indvars.iv2293>, ir<1>
    CLONE ir<%exitcond2299.not> = icmp eq ir<%indvars.iv.next2294>, ir<%wide.trip.count2298>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2293 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2294, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %87 = add nsw i64 %indvars.iv2293, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl559 = shl nuw i64 1, %87 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2294 = add nuw nsw i64 %indvars.iv2293, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2299.not = icmp eq i64 %indvars.iv.next2294, %wide.trip.count2298 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2299.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2293 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2294, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %87 = add nsw i64 %indvars.iv2293, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl559 = shl nuw i64 1, %87 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2294 = add nuw nsw i64 %indvars.iv2293, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2299.not = icmp eq i64 %indvars.iv.next2294, %wide.trip.count2298 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2299.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2293 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2294, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %87 = add nsw i64 %indvars.iv2293, %idxprom214 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl559 = shl nuw i64 1, %87 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next2294 = add nuw nsw i64 %indvars.iv2293, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2299.not = icmp eq i64 %indvars.iv.next2294, %wide.trip.count2298 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2299.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2293 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2294, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %87 = add nsw i64 %indvars.iv2293, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl559 = shl nuw i64 1, %87 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next2294 = add nuw nsw i64 %indvars.iv2293, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2299.not = icmp eq i64 %indvars.iv.next2294, %wide.trip.count2298 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2299.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2293 = phi 0, %indvars.iv.next2294, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%87> = add nsw ir<%indvars.iv2293>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%87>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2284 = phi 0, %indvars.iv.next2285, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    CLONE ir<%61> = add nsw ir<%indvars.iv2284>, ir<%idxprom214>
    CLONE ir<%shl417> = shl nuw ir<1>, ir<%61>
    CLONE ir<%and418> = and ir<%59>, ir<%shl417>
    CLONE ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    CLONE ir<%lnot.ext> = zext ir<%tobool419.not>
    CLONE ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    CLONE ir<%indvars.iv.next2285> = add nuw nsw ir<%indvars.iv2284>, ir<1>
    CLONE ir<%exitcond2289.not> = icmp eq ir<%indvars.iv.next2285>, ir<%wide.trip.count2288>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2284 = phi 0, %indvars.iv.next2285, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2284>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    WIDEN ir<%indvars.iv.next2285> = add nuw nsw ir<%indvars.iv2284>, ir<1>
    CLONE ir<%exitcond2289.not> = icmp eq ir<%indvars.iv.next2285>, ir<%wide.trip.count2288>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2284 = phi 0, %indvars.iv.next2285, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2284>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    WIDEN ir<%indvars.iv.next2285> = add nuw nsw ir<%indvars.iv2284>, ir<1>
    CLONE ir<%exitcond2289.not> = icmp eq ir<%indvars.iv.next2285>, ir<%wide.trip.count2288>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 7516192761
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 7516192761
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 7516192761
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 4294967295
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192761
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3489660936

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2147483661, RTCostB: 7516192761
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483661, RTCostB: 3489660936
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv2284 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2285, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %61 = add nsw i64 %indvars.iv2284, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next2285 = add nuw nsw i64 %indvars.iv2284, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond2289.not = icmp eq i64 %indvars.iv.next2285, %wide.trip.count2288 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond2289.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1744830500, RTCostB: 7516192761
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1744830500, RTCostB: 2147483661
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223842392 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2284 = phi 0, %indvars.iv.next2285, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2284>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
LV: Decision: Scalarize
@@ Instruction =>  %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %219 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2331 = phi 0, %indvars.iv.next2332, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2331>
    CLONE ir<%234> = load ir<%arrayidx1370>
    CLONE ir<%tobool1371.not> = icmp eq ir<%234>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%4> = not ir<%tobool1371.not>
    CLONE ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2331>
    CLONE store ir<%234>, ir<%arrayidx1376>, vp<%4>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%5> = or ir<%tobool1371.not>, vp<%4>
    CLONE ir<%indvars.iv.next2332> = add nuw nsw ir<%indvars.iv2331>, ir<1>
    CLONE ir<%exitcond2336.not> = icmp eq ir<%indvars.iv.next2332>, ir<%wide.trip.count2335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %219 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2331 = phi 0, %indvars.iv.next2332, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2331>
    vp<%4> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%234> = load vp<%4>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%234>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%5> = not ir<%tobool1371.not>
    REPLICATE ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2331>
    REPLICATE store ir<%234>, ir<%arrayidx1376>, vp<%5>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%6> = or ir<%tobool1371.not>, vp<%5>
    REPLICATE ir<%indvars.iv.next2332> = add nuw nsw ir<%indvars.iv2331>, ir<1>
    CLONE ir<%exitcond2336.not> = icmp eq ir<%indvars.iv.next2332>, ir<%wide.trip.count2335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %219 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2331 = phi 0, %indvars.iv.next2332, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2331>
    vp<%4> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%234> = load vp<%4>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%234>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%5> = not ir<%tobool1371.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2331>
    REPLICATE store ir<%234>, ir<%arrayidx1376>, vp<%5>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%6> = or ir<%tobool1371.not>, vp<%5>
    WIDEN ir<%indvars.iv.next2332> = add nuw nsw ir<%indvars.iv2331>, ir<1>
    CLONE ir<%exitcond2336.not> = icmp eq ir<%indvars.iv.next2332>, ir<%wide.trip.count2335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %219 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2331 = phi 0, %indvars.iv.next2332, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2331>
    vp<%4> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%234> = load vp<%4>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%234>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%5> = not ir<%tobool1371.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2331>
    WIDEN store ir<%arrayidx1376>, ir<%234>, vp<%5>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%6> = or ir<%tobool1371.not>, vp<%5>
    WIDEN ir<%indvars.iv.next2332> = add nuw nsw ir<%indvars.iv2331>, ir<1>
    CLONE ir<%exitcond2336.not> = icmp eq ir<%indvars.iv.next2332>, ir<%wide.trip.count2335>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2331 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2332, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1371.not = icmp eq ptr %234, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %234, ptr %arrayidx1376, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2332 = add nuw nsw i64 %indvars.iv2331, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2336.not = icmp eq i64 %indvars.iv.next2332, %wide.trip.count2335 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2336.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2331 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2332, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1371.not = icmp eq ptr %234, null of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %234, ptr %arrayidx1376, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2332 = add nuw nsw i64 %indvars.iv2331, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2336.not = icmp eq i64 %indvars.iv.next2332, %wide.trip.count2335 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2336.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 12884901882

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2331 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2332, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1371.not = icmp eq ptr %234, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %234, ptr %arrayidx1376, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next2332 = add nuw nsw i64 %indvars.iv2331, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2336.not = icmp eq i64 %indvars.iv.next2332, %wide.trip.count2335 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2336.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2331 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2332, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %234 = load ptr, ptr %arrayidx1370, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1371.not = icmp eq ptr %234, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2331 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %234, ptr %arrayidx1376, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next2332 = add nuw nsw i64 %indvars.iv2331, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2336.not = icmp eq i64 %indvars.iv.next2332, %wide.trip.count2335 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2336.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24159191013, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 24159191013, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682405 to i64) + (-1 * (1 umin (zext i32 %cond16682405 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2346 = phi %283, %indvars.iv.next2347, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    CLONE ir<%indvars.iv.next2347> = add nsw ir<%indvars.iv2346>, ir<-1>
    CLONE ir<%285> = add nuw nsw ir<%indvars.iv.next2347>, ir<%284>
    CLONE ir<%shl1676> = shl nuw ir<1>, ir<%285>
    CLONE ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2346>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682405 to i64) + (-1 * (1 umin (zext i32 %cond16682405 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2346 = phi %283, %indvars.iv.next2347, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2347> = add nsw ir<%indvars.iv2346>, ir<-1>
    WIDEN ir<%285> = add nuw nsw ir<%indvars.iv.next2347>, ir<%284>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%285>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2346>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682405 to i64) + (-1 * (1 umin (zext i32 %cond16682405 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2346 = phi %283, %indvars.iv.next2347, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2347> = add nsw ir<%indvars.iv2346>, ir<-1>
    WIDEN ir<%285> = add nuw nsw ir<%indvars.iv.next2347>, ir<%284>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%285>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2346>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2346 = phi i64 [ %283, %while.body1673.preheader ], [ %indvars.iv.next2347, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2347 = add nsw i64 %indvars.iv2346, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %285 = add nuw nsw i64 %indvars.iv.next2347, %284 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl1676 = shl nuw i64 1, %285 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2346, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2346 = phi i64 [ %283, %while.body1673.preheader ], [ %indvars.iv.next2347, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2347 = add nsw i64 %indvars.iv2346, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %285 = add nuw nsw i64 %indvars.iv.next2347, %284 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl1676 = shl nuw i64 1, %285 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2346, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2346 = phi i64 [ %283, %while.body1673.preheader ], [ %indvars.iv.next2347, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next2347 = add nsw i64 %indvars.iv2346, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %285 = add nuw nsw i64 %indvars.iv.next2347, %284 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl1676 = shl nuw i64 1, %285 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2346, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2684354560

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2346 = phi i64 [ %283, %while.body1673.preheader ], [ %indvars.iv.next2347, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next2347 = add nsw i64 %indvars.iv2346, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %285 = add nuw nsw i64 %indvars.iv.next2347, %284 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl1676 = shl nuw i64 1, %285 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2346, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177290, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682405 to i64) + (-1 * (1 umin (zext i32 %cond16682405 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2346 = phi %283, %indvars.iv.next2347, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2347> = add nsw ir<%indvars.iv2346>, ir<-1>
    WIDEN ir<%285> = add nuw nsw ir<%indvars.iv.next2347>, ir<%284>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%285>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 15
Loops Analyzed: 110
Loops Epilogues Vectorized: 3
================================================
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1717 = phi 0, %indvars.iv.next1718, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1717 = phi 0, %indvars.iv.next1718\l" +
    "  ir<%129>, ir<1>
    CLONE ir<%128> = add nuw nsw ir<%indvars.iv1717>, ir<%127>
    CLONE ir<%shl778> = shl nuw ir<1>, ir<%128>
    CLONE ir<%not779> = xor ir<%shl778>, ir<-1>
    CLONE ir<%and780> = and ir<%and78016581663>, ir<%not779>
    CLONE ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0>
    CLONE ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    CLONE store ir<%cond790>, ir<%arrayidx793>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    CLONE store ir<%0>, ir<%arrayidx796>
    CLONE ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    CLONE ir<%indvars.iv.next1718> = add nuw nsw ir<%indvars.iv1717>, ir<1>
    CLONE ir<%exitcond1722.not> = icmp eq ir<%indvars.iv.next1718>, ir<%wide.trip.count1721>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%7> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%6>
Live-out i64 %or800.lcssa = vp<%7>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1717 = phi 0, %indvars.iv.next1718, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1717 = phi 0, %indvars.iv.next1718\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1717>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    WIDEN ir<%indvars.iv.next1718> = add nuw nsw ir<%indvars.iv1717>, ir<1>
    CLONE ir<%exitcond1722.not> = icmp eq ir<%indvars.iv.next1718>, ir<%wide.trip.count1721>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1717 = phi 0, %indvars.iv.next1718, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1717 = phi 0, %indvars.iv.next1718\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1717>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    WIDEN ir<%indvars.iv.next1718> = add nuw nsw ir<%indvars.iv1717>, ir<1>
    CLONE ir<%exitcond1722.not> = icmp eq ir<%indvars.iv.next1718>, ir<%wide.trip.count1721>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1717 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1718, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %128 = add nuw nsw i64 %indvars.iv1717, %127 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1717 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1718 = add nuw nsw i64 %indvars.iv1717, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1722.not = icmp eq i64 %indvars.iv.next1718, %wide.trip.count1721 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1722.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1717 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1718, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %128 = add nuw nsw i64 %indvars.iv1717, %127 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1717 to i32 of type:trunc
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1718 = add nuw nsw i64 %indvars.iv1717, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1722.not = icmp eq i64 %indvars.iv.next1718, %wide.trip.count1721 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1722.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 26
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 26
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1717 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1718, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %128 = add nuw nsw i64 %indvars.iv1717, %127 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1717 to i32 of type:trunc
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1718 = add nuw nsw i64 %indvars.iv1717, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1722.not = icmp eq i64 %indvars.iv.next1718, %wide.trip.count1721 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1722.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 52
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 2, EstimatedWidthB: 2, CostB: 16
CostA * EstimatedWidthB: 58, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1717 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1718, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %128 = add nuw nsw i64 %indvars.iv1717, %127 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1717 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1718 = add nuw nsw i64 %indvars.iv1717, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1722.not = icmp eq i64 %indvars.iv.next1718, %wide.trip.count1721 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1722.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 29
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 58

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1717 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1718, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %128 = add nuw nsw i64 %indvars.iv1717, %127 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1717 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx796, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1718 = add nuw nsw i64 %indvars.iv1717, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1722.not = icmp eq i64 %indvars.iv.next1718, %wide.trip.count1721 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1722.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 52
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 29
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 116
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1717 = phi 0, %indvars.iv.next1718, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1717 = phi 0, %indvars.iv.next1718\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1717>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1705 = phi 0, %indvars.iv.next1706, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1705 = phi 0, %indvars.iv.next1706\l" +
    "  ir<%85>, ir<1>
    CLONE ir<%84> = add nuw nsw ir<%indvars.iv1705>, ir<%idxprom425>
    CLONE ir<%shl477> = shl nuw ir<1>, ir<%84>
    CLONE ir<%not478> = xor ir<%shl477>, ir<-1>
    CLONE ir<%and479> = and ir<%and47916481653>, ir<%not478>
    CLONE ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0>
    CLONE ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    CLONE store ir<%cond489>, ir<%arrayidx492>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    CLONE store ir<%0>, ir<%arrayidx495>
    CLONE ir<%or> = or ir<%or16501652>, ir<%shl477>
    CLONE ir<%indvars.iv.next1706> = add nuw nsw ir<%indvars.iv1705>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1706>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%7> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%6>
Live-out i64 %or.lcssa = vp<%7>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1705 = phi 0, %indvars.iv.next1706, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1705 = phi 0, %indvars.iv.next1706\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1705>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    WIDEN ir<%indvars.iv.next1706> = add nuw nsw ir<%indvars.iv1705>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1706>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1705 = phi 0, %indvars.iv.next1706, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1705 = phi 0, %indvars.iv.next1706\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1705>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    WIDEN ir<%indvars.iv.next1706> = add nuw nsw ir<%indvars.iv1705>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1706>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1705 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1706, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %84 = add nuw nsw i64 %indvars.iv1705, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1705 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1706 = add nuw nsw i64 %indvars.iv1705, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1706, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1710.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1705 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1706, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %84 = add nuw nsw i64 %indvars.iv1705, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1705 to i32 of type:trunc
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1706 = add nuw nsw i64 %indvars.iv1705, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1706, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1710.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 26
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 26
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1705 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1706, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %84 = add nuw nsw i64 %indvars.iv1705, %idxprom425 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1705 to i32 of type:trunc
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1706 = add nuw nsw i64 %indvars.iv1705, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1706, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1710.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 52
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 2, EstimatedWidthB: 2, CostB: 16
CostA * EstimatedWidthB: 58, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1705 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1706, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %84 = add nuw nsw i64 %indvars.iv1705, %idxprom425 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1705 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1706 = add nuw nsw i64 %indvars.iv1705, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1706, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1710.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 29
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 58

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1705 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1706, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %84 = add nuw nsw i64 %indvars.iv1705, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1705 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx495, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1706 = add nuw nsw i64 %indvars.iv1705, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1706, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1710.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 52
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 29
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 116
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239173817481751 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1705 = phi 0, %indvars.iv.next1706, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1705 = phi 0, %indvars.iv.next1706\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1705>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}
================ Final VPlan ================

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391739 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1693 = phi 0, %indvars.iv.next1694, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    CLONE ir<%59> = add nuw nsw ir<%indvars.iv1693>, ir<%58>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%59>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and263> = and ir<%and26316411643>, ir<%not>
    CLONE ir<%indvars.iv.next1694> = add nuw nsw ir<%indvars.iv1693>, ir<1>
    CLONE ir<%exitcond1698.not> = icmp eq ir<%indvars.iv.next1694>, ir<%wide.trip.count1697>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391739 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1693 = phi 0, %indvars.iv.next1694, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1693>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    WIDEN ir<%indvars.iv.next1694> = add nuw nsw ir<%indvars.iv1693>, ir<1>
    CLONE ir<%exitcond1698.not> = icmp eq ir<%indvars.iv.next1694>, ir<%wide.trip.count1697>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391739 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1693 = phi 0, %indvars.iv.next1694, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1693>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    WIDEN ir<%indvars.iv.next1694> = add nuw nsw ir<%indvars.iv1693>, ir<1>
    CLONE ir<%exitcond1698.not> = icmp eq ir<%indvars.iv.next1694>, ir<%wide.trip.count1697>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1693 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1694, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %59 = add nuw nsw i64 %indvars.iv1693, %58 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1694 = add nuw nsw i64 %indvars.iv1693, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1698.not = icmp eq i64 %indvars.iv.next1694, %wide.trip.count1697 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1698.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1693 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1694, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %59 = add nuw nsw i64 %indvars.iv1693, %58 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1694 = add nuw nsw i64 %indvars.iv1693, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1698.not = icmp eq i64 %indvars.iv.next1694, %wide.trip.count1697 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1698.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1693 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1694, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %59 = add nuw nsw i64 %indvars.iv1693, %58 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1694 = add nuw nsw i64 %indvars.iv1693, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1698.not = icmp eq i64 %indvars.iv.next1694, %wide.trip.count1697 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1698.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1693 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1694, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %59 = add nuw nsw i64 %indvars.iv1693, %58 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1694 = add nuw nsw i64 %indvars.iv1693, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1698.not = icmp eq i64 %indvars.iv.next1694, %wide.trip.count1697 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1698.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391739 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1693 = phi 0, %indvars.iv.next1694, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1693>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 18
Loops Analyzed: 125
Loops Epilogues Vectorized: 3
================================================
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78193 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv179 = phi %indvars.iv.next180, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    CLONE ir<%19> = add nuw nsw ir<%indvars.iv179>, ir<%18>
    CLONE ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    CLONE ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    CLONE ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    CLONE store ir<null>, ir<%arrayidx94.us>
    CLONE ir<%indvars.iv.next180> = add nuw nsw ir<%indvars.iv179>, ir<1>
    CLONE ir<%exitcond184.not> = icmp eq ir<%indvars.iv.next180>, ir<%wide.trip.count183>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%6>
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78193 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv179 = phi %indvars.iv.next180, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv179>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    WIDEN ir<%indvars.iv.next180> = add nuw nsw ir<%indvars.iv179>, ir<1>
    CLONE ir<%exitcond184.not> = icmp eq ir<%indvars.iv.next180>, ir<%wide.trip.count183>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78193 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv179 = phi %indvars.iv.next180, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv179>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    WIDEN ir<%indvars.iv.next180> = add nuw nsw ir<%indvars.iv179>, ir<1>
    CLONE ir<%exitcond184.not> = icmp eq ir<%indvars.iv.next180>, ir<%wide.trip.count183>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}


-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv179 = phi i64 [ %indvars.iv.next180, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %19 = add nuw nsw i64 %indvars.iv179, %18 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next180 = add nuw nsw i64 %indvars.iv179, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond184.not = icmp eq i64 %indvars.iv.next180, %wide.trip.count183 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond184.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv179 = phi i64 [ %indvars.iv.next180, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = add nuw nsw i64 %indvars.iv179, %18 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next180 = add nuw nsw i64 %indvars.iv179, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond184.not = icmp eq i64 %indvars.iv.next180, %wide.trip.count183 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond184.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv179 = phi i64 [ %indvars.iv.next180, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = add nuw nsw i64 %indvars.iv179, %18 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next180 = add nuw nsw i64 %indvars.iv179, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond184.not = icmp eq i64 %indvars.iv.next180, %wide.trip.count183 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond184.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv179 = phi i64 [ %indvars.iv.next180, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = add nuw nsw i64 %indvars.iv179, %18 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx94.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next180 = add nuw nsw i64 %indvars.iv179, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond184.not = icmp eq i64 %indvars.iv.next180, %wide.trip.count183 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond184.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: forget_old_reloads_1 at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78193 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv179 = phi %indvars.iv.next180, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv179>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}
================ Final VPlan ================

MVT: v4i16
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 22 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v8i8
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 44 -> VectorType: <8 x ptr> -> ttilog -> MaskedMemoryOpCost(40)-> ShuffleCost(4) = LT.first(4) * (1) -> ASM: [EXT]
MVT: v16i8
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 88 -> VectorType: <16 x ptr> -> ttilog -> MaskedMemoryOpCost(80)-> ShuffleCost(8) = LT.first(8) * (1) -> ASM: [EXT]
MVT: v2i32
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 11 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(10)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v4i16
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 22 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(20)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v8i8
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 44 -> VectorType: <8 x ptr> -> ttilog -> MaskedMemoryOpCost(40)-> ShuffleCost(4) = LT.first(4) * (1) -> ASM: [EXT]
MVT: v16i8
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 88 -> VectorType: <16 x ptr> -> ttilog -> MaskedMemoryOpCost(80)-> ShuffleCost(8) = LT.first(8) * (1) -> ASM: [EXT]
MVT: nxv16i8
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113, align 8, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv185 = phi %indvars.iv.next186, %55, ir<-1>
    CLONE ir<%57> = trunc ir<%indvars.iv185>
    CLONE ir<%add104> = add ir<%add19>, ir<%57>
    CLONE ir<%idxprom105> = zext ir<%add104>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%53>, ir<%idxprom105>
    CLONE ir<%58> = load ir<%arrayidx106>
    CLONE ir<%cmp108> = icmp eq ir<%58>, ir<0>
  Successor(s): if.then110

  if.then110:
    CLONE ir<%arrayidx113> = getelementptr inbounds ir<%54>, ir<%idxprom105>
    CLONE store ir<null>, ir<%arrayidx113>, ir<%cmp108>
  Successor(s): if.end114

  if.end114:
    EMIT vp<%4> = not ir<%cmp108>
    EMIT vp<%5> = or ir<%cmp108>, vp<%4>
    CLONE ir<%indvars.iv.next186> = add nsw ir<%indvars.iv185>, ir<-1>
    CLONE ir<%cmp98.not> = icmp eq ir<%indvars.iv185>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit205>, scalar.ph

ir-bb<cleanup.loopexit205>:
No successors

scalar.ph:
No successors
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv185 = phi %indvars.iv.next186, %55, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv185 = phi %indvars.iv.next186, %55\l" +
    "  ir<%57>, ir<-1>
    CLONE ir<%add104> = add ir<%add19>, ir<%57>
    CLONE ir<%idxprom105> = zext ir<%add104>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%53>, ir<%idxprom105>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx106>
    WIDEN ir<%58> = load vp<%4>
    WIDEN ir<%cmp108> = icmp eq ir<%58>, ir<0>
  Successor(s): if.then110

  if.then110:
    CLONE ir<%arrayidx113> = getelementptr ir<%54>, ir<%idxprom105>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx113>
    WIDEN store vp<%5>, ir<null>, ir<%cmp108>
  Successor(s): if.end114

  if.end114:
    EMIT vp<%6> = not ir<%cmp108>
    EMIT vp<%7> = or ir<%cmp108>, vp<%6>
    CLONE ir<%indvars.iv.next186> = add nsw ir<%indvars.iv185>, ir<-1>
    CLONE ir<%cmp98.not> = icmp eq ir<%indvars.iv185>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit205>, scalar.ph

ir-bb<cleanup.loopexit205>:
No successors

scalar.ph:
No successors
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv185 = phi %indvars.iv.next186, %55, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv185 = phi %indvars.iv.next186, %55\l" +
    "  ir<%57>, ir<-1>
    CLONE ir<%add104> = add ir<%add19>, ir<%57>
    CLONE ir<%idxprom105> = zext ir<%add104>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%53>, ir<%idxprom105>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx106>
    WIDEN ir<%58> = load vp<%4>
    WIDEN ir<%cmp108> = icmp eq ir<%58>, ir<0>
  Successor(s): if.then110

  if.then110:
    CLONE ir<%arrayidx113> = getelementptr ir<%54>, ir<%idxprom105>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx113>
    WIDEN store vp<%5>, ir<null>, ir<%cmp108>
  Successor(s): if.end114

  if.end114:
    EMIT vp<%6> = not ir<%cmp108>
    EMIT vp<%7> = or ir<%cmp108>, vp<%6>
    CLONE ir<%indvars.iv.next186> = add nsw ir<%indvars.iv185>, ir<-1>
    CLONE ir<%cmp98.not> = icmp eq ir<%indvars.iv185>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit205>, scalar.ph

ir-bb<cleanup.loopexit205>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 2 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 22 for VF 4 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 44 for VF 8 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width 8 costs: 6
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 50
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 50, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 50
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 50, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 88 for VF 16 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 95
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 95, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 95
B VF: 8, EstimatedWidthB: 8, CostB: 50
CostA * EstimatedWidthB: 760, CostB * EstimatedWidthA: 800
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 95
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 190

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv185 = phi i64 [ %indvars.iv.next186, %if.end114 ], [ %55, %while.body100.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %57 = trunc nuw i64 %indvars.iv185 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add104 = add i32 %add19, %57 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom105 = zext i32 %add104 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx106 = getelementptr inbounds i8, ptr %53, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %58 = load i8, ptr %arrayidx106, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp108 = icmp eq i8 %58, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp108, label %if.then110, label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx113 = getelementptr inbounds ptr, ptr %54, i64 %idxprom105 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx113, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end114 of type:br

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next186 = add nsw i64 %indvars.iv185, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp98.not = icmp eq i64 %indvars.iv185, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp98.not, label %cleanup.loopexit205, label %while.body100 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 95
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 380
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: forget_old_reloads_1 at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<-1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%5>    = DERIVED-IV ir<%55> + vp<%4> * ir<-1>
    SCALAR-CAST vp<%6> = trunc vp<%5> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%add104> = add ir<%add19>, vp<%7>
    CLONE ir<%idxprom105> = zext ir<%add104>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<%53>, ir<%idxprom105>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx106>
    WIDEN ir<%71> = load vp<%8>
    WIDEN ir<%cmp108> = icmp eq ir<%71>, ir<0>
    CLONE ir<%arrayidx113> = getelementptr ir<%54>, ir<%idxprom105>
    vp<%9> = vector-pointer (reverse) ir<%arrayidx113>
    WIDEN store vp<%9>, ir<null>, ir<%cmp108>
    EMIT vp<%10> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<cleanup.loopexit205>, scalar.ph

ir-bb<cleanup.loopexit205>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv188 = phi %indvars.iv.next189, %55, ir<-1>
    CLONE ir<%119> = trunc ir<%indvars.iv188>
    CLONE ir<%add111.us> = add ir<%add19>, ir<%119>
    CLONE ir<%idxprom112.us> = zext ir<%add111.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%54>, ir<%idxprom112.us>
    CLONE store ir<null>, ir<%arrayidx113.us>
    CLONE ir<%indvars.iv.next189> = add nsw ir<%indvars.iv188>, ir<-1>
    CLONE ir<%cmp98.not.us> = icmp eq ir<%indvars.iv188>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv188 = phi %indvars.iv.next189, %55, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv188 = phi %indvars.iv.next189, %55\l" +
    "  ir<%119>, ir<-1>
    CLONE ir<%add111.us> = add ir<%add19>, ir<%119>
    CLONE ir<%idxprom112.us> = zext ir<%add111.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%54>, ir<%idxprom112.us>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx113.us>
    WIDEN store vp<%4>, ir<null>
    CLONE ir<%indvars.iv.next189> = add nsw ir<%indvars.iv188>, ir<-1>
    CLONE ir<%cmp98.not.us> = icmp eq ir<%indvars.iv188>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv188 = phi %indvars.iv.next189, %55, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv188 = phi %indvars.iv.next189, %55\l" +
    "  ir<%119>, ir<-1>
    CLONE ir<%add111.us> = add ir<%add19>, ir<%119>
    CLONE ir<%idxprom112.us> = zext ir<%add111.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%54>, ir<%idxprom112.us>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx113.us>
    WIDEN store vp<%4>, ir<null>
    CLONE ir<%indvars.iv.next189> = add nsw ir<%indvars.iv188>, ir<-1>
    CLONE ir<%cmp98.not.us> = icmp eq ir<%indvars.iv188>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv188 = phi i64 [ %indvars.iv.next189, %while.body100.us ], [ %55, %while.body100.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %119 = trunc nuw i64 %indvars.iv188 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add111.us = add i32 %add19, %119 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom112.us = zext i32 %add111.us to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx113.us = getelementptr inbounds ptr, ptr %54, i64 %idxprom112.us of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next189 = add nsw i64 %indvars.iv188, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp98.not.us = icmp eq i64 %indvars.iv188, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp98.not.us, label %cleanup.loopexit, label %while.body100.us of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv188 = phi i64 [ %indvars.iv.next189, %while.body100.us ], [ %55, %while.body100.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %119 = trunc nuw i64 %indvars.iv188 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add111.us = add i32 %add19, %119 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom112.us = zext i32 %add111.us to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx113.us = getelementptr inbounds ptr, ptr %54, i64 %idxprom112.us of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next189 = add nsw i64 %indvars.iv188, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp98.not.us = icmp eq i64 %indvars.iv188, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp98.not.us, label %cleanup.loopexit, label %while.body100.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv188 = phi i64 [ %indvars.iv.next189, %while.body100.us ], [ %55, %while.body100.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %119 = trunc nuw i64 %indvars.iv188 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add111.us = add i32 %add19, %119 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom112.us = zext i32 %add111.us to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx113.us = getelementptr inbounds ptr, ptr %54, i64 %idxprom112.us of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next189 = add nsw i64 %indvars.iv188, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp98.not.us = icmp eq i64 %indvars.iv188, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp98.not.us, label %cleanup.loopexit, label %while.body100.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv188 = phi i64 [ %indvars.iv.next189, %while.body100.us ], [ %55, %while.body100.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %119 = trunc nuw i64 %indvars.iv188 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add111.us = add i32 %add19, %119 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom112.us = zext i32 %add111.us to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx113.us = getelementptr inbounds ptr, ptr %54, i64 %idxprom112.us of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx113.us, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next189 = add nsw i64 %indvars.iv188, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp98.not.us = icmp eq i64 %indvars.iv188, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp98.not.us, label %cleanup.loopexit, label %while.body100.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: forget_old_reloads_1 at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body100.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nr.0199)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<-1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%5>    = DERIVED-IV ir<%55> + vp<%4> * ir<-1>
    SCALAR-CAST vp<%6> = trunc vp<%5> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%add111.us> = add ir<%add19>, vp<%7>
    CLONE ir<%idxprom112.us> = zext ir<%add111.us>
    CLONE ir<%arrayidx113.us> = getelementptr inbounds ir<%54>, ir<%idxprom112.us>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx113.us>
    WIDEN store vp<%8>, ir<null>
    EMIT vp<%9> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 21
Loops Analyzed: 130
Loops Epilogues Vectorized: 3
================================================
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    CLONE store ir<%1>, ir<%reg_rtx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    REPLICATE ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    REPLICATE store ir<%1>, ir<%reg_rtx>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    REPLICATE store ir<%1>, ir<%reg_rtx>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    WIDEN store ir<%reg_rtx>, ir<%1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %1, ptr %reg_rtx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %1, ptr %reg_rtx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 35433480165, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 35433480165, RTCostB: 12884901882

-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %1, ptr %reg_rtx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %1, ptr %reg_rtx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    CLONE ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    CLONE store ir<-1>, ir<%use_index>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    CLONE store ir<%19>, ir<%store_ruid>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit259>, scalar.ph

ir-bb<cleanup.loopexit259>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    REPLICATE ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    REPLICATE ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    REPLICATE store ir<-1>, ir<%use_index>
    REPLICATE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    REPLICATE store ir<%19>, ir<%store_ruid>
    REPLICATE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit259>, scalar.ph

ir-bb<cleanup.loopexit259>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    REPLICATE store ir<-1>, ir<%use_index>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    REPLICATE store ir<%19>, ir<%store_ruid>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit259>, scalar.ph

ir-bb<cleanup.loopexit259>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    WIDEN store ir<%use_index>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    WIDEN store ir<%store_ruid>, ir<%19>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit259>, scalar.ph

ir-bb<cleanup.loopexit259>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Vector loop of width 2 costs: 9

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Vector loop of width 4 costs: 8

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %19, ptr %store_ruid, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit259 of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: reload_combine_note_store at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%20> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, vp<%5>
    CLONE ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    CLONE store ir<-1>, ir<%use_index>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    CLONE store ir<%19>, ir<%store_ruid>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit259>, scalar.ph

ir-bb<cleanup.loopexit259>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv254 = phi %47, %indvars.iv.next255, ir<-1>
    CLONE ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv254>
    CLONE ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    CLONE store ir<%46>, ir<%store_ruid172>
    CLONE ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    CLONE store ir<6>, ir<%use_index175>
    CLONE ir<%indvars.iv.next255> = add nsw ir<%indvars.iv254>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv254>, ir<%48>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv254 = phi %47, %indvars.iv.next255, ir<-1>
    REPLICATE ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv254>
    REPLICATE ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    REPLICATE store ir<%46>, ir<%store_ruid172>
    REPLICATE ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    REPLICATE store ir<6>, ir<%use_index175>
    REPLICATE ir<%indvars.iv.next255> = add nsw ir<%indvars.iv254>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv254>, ir<%48>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv254 = phi %47, %indvars.iv.next255, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv254>
    WIDEN-GEP Var[Inv] ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    REPLICATE store ir<%46>, ir<%store_ruid172>
    WIDEN-GEP Var[Inv] ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    REPLICATE store ir<6>, ir<%use_index175>
    WIDEN ir<%indvars.iv.next255> = add nsw ir<%indvars.iv254>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv254>, ir<%48>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv254 = phi %47, %indvars.iv.next255, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv254>
    WIDEN-GEP Var[Inv] ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    WIDEN store ir<%store_ruid172>, ir<%46>
    WIDEN-GEP Var[Inv] ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    WIDEN store ir<%use_index175>, ir<6>
    WIDEN ir<%indvars.iv.next255> = add nsw ir<%indvars.iv254>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv254>, ir<%48>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 9

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 8

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv254 = phi i64 [ %47, %for.body169.lr.ph ], [ %indvars.iv.next255, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv254 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %46, ptr %store_ruid172, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index175, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next255 = add nsw i64 %indvars.iv254, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv254, %48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 165
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 165, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: reload_combine_note_store at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%47> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, vp<%5>
    CLONE ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    CLONE store ir<%46>, ir<%store_ruid172>
    CLONE ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    CLONE store ir<6>, ir<%use_index175>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 21
Loops Analyzed: 188
Loops Epilogues Vectorized: 3
================================================
========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213477 to i64) + (-1 * (1 umin (zext i32 %cond213477 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    CLONE ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    CLONE store ir<-1>, ir<%use_index225>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit498>, scalar.ph

ir-bb<cleanup309.loopexit498>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213477 to i64) + (-1 * (1 umin (zext i32 %cond213477 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    REPLICATE ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index225>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit498>, scalar.ph

ir-bb<cleanup309.loopexit498>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213477 to i64) + (-1 * (1 umin (zext i32 %cond213477 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index225>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit498>, scalar.ph

ir-bb<cleanup309.loopexit498>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213477 to i64) + (-1 * (1 umin (zext i32 %cond213477 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    WIDEN store ir<%use_index225>, ir<-1>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit498>, scalar.ph

ir-bb<cleanup309.loopexit498>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 15569256424, RTCostB: 5368709115
A is not scalable.	B is not scalable.	
RTCostA: 15569256424, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 15300820950, RTCostB: 5368709115
A is not scalable.	B is not scalable.	
RTCostA: 15300820950, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 11811160035, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: 11811160035, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index225, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit498 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 11542724557, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: 11542724557, RTCostB: 5368709115
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: reload_combine_note_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213477 to i64) + (-1 * (1 umin (zext i32 %cond213477 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%34> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    CLONE ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    CLONE store ir<-1>, ir<%use_index225>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup309.loopexit498>, scalar.ph

ir-bb<cleanup309.loopexit498>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77474 to i64) + (-1 * (1 umin (zext i32 %cond77474 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv461 = phi %14, %indvars.iv.next462, ir<-1>
    CLONE ir<%indvars.iv.next462> = add nsw ir<%indvars.iv461>, ir<-1>
    CLONE ir<%16> = add nsw ir<%indvars.iv.next462>, ir<%15>
    CLONE ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    CLONE store ir<-1>, ir<%use_index>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv461>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit497>, scalar.ph

ir-bb<cleanup309.loopexit497>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77474 to i64) + (-1 * (1 umin (zext i32 %cond77474 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv461 = phi %14, %indvars.iv.next462, ir<-1>
    WIDEN ir<%indvars.iv.next462> = add nsw ir<%indvars.iv461>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next462>, ir<%15>
    REPLICATE ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv461>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit497>, scalar.ph

ir-bb<cleanup309.loopexit497>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77474 to i64) + (-1 * (1 umin (zext i32 %cond77474 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv461 = phi %14, %indvars.iv.next462, ir<-1>
    WIDEN ir<%indvars.iv.next462> = add nsw ir<%indvars.iv461>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next462>, ir<%15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    REPLICATE store ir<-1>, ir<%use_index>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv461>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit497>, scalar.ph

ir-bb<cleanup309.loopexit497>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77474 to i64) + (-1 * (1 umin (zext i32 %cond77474 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv461 = phi %14, %indvars.iv.next462, ir<-1>
    WIDEN ir<%indvars.iv.next462> = add nsw ir<%indvars.iv461>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next462>, ir<%15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    WIDEN store ir<%use_index>, ir<-1>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv461>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit497>, scalar.ph

ir-bb<cleanup309.loopexit497>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 15569256424, RTCostB: 5368709115
A is not scalable.	B is not scalable.	
RTCostA: 15569256424, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 15300820950, RTCostB: 5368709115
A is not scalable.	B is not scalable.	
RTCostA: 15300820950, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 11811160035, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: 11811160035, RTCostB: 5368709115

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv461 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next462, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next462 = add nsw i64 %indvars.iv461, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %16 = add nsw i64 %indvars.iv.next462, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv461, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit497 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 11542724557, RTCostB: 5368709115
A is scalable.	B is not scalable.	
RTCostA: 11542724557, RTCostB: 5368709115
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: reload_combine_note_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77474 to i64) + (-1 * (1 umin (zext i32 %cond77474 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%14> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next462> = add nsw vp<%5>, ir<-1>
    CLONE ir<%16> = add nsw ir<%indvars.iv.next462>, ir<%15>
    CLONE ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    CLONE store ir<-1>, ir<%use_index>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup309.loopexit497>, scalar.ph

ir-bb<cleanup309.loopexit497>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 21
Loops Analyzed: 192
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o reorg.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                reorg.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o resource.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                resource.c
========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv729 = phi %23, %indvars.iv.next730, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    CLONE ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv729>
    CLONE ir<%or168> = or ir<%24>, ir<%shl166>
    CLONE ir<%indvars.iv.next730> = add nuw nsw ir<%indvars.iv729>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next730>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv729 = phi %23, %indvars.iv.next730, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv729>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    WIDEN ir<%indvars.iv.next730> = add nuw nsw ir<%indvars.iv729>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next730>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv729 = phi %23, %indvars.iv.next730, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv729>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    WIDEN ir<%indvars.iv.next730> = add nuw nsw ir<%indvars.iv729>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next730>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv729 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next730, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv729 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next730 = add nuw nsw i64 %indvars.iv729, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next730, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond733.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv729 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next730, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv729 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next730 = add nuw nsw i64 %indvars.iv729, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next730, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond733.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv729 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next730, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv729 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next730 = add nuw nsw i64 %indvars.iv729, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next730, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond733.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv729 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next730, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv729 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next730 = add nuw nsw i64 %indvars.iv729, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next730, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond733.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_referenced_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv729 = phi %23, %indvars.iv.next730, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv729>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv734 = phi %11, %indvars.iv.next735, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv734>
    CLONE ir<%or> = or ir<%12>, ir<%shl>
    CLONE ir<%indvars.iv.next735> = add nuw nsw ir<%indvars.iv734>, ir<1>
    CLONE ir<%exitcond738.not> = icmp eq ir<%indvars.iv.next735>, ir<%wide.trip.count737>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv734 = phi %11, %indvars.iv.next735, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv734>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    WIDEN ir<%indvars.iv.next735> = add nuw nsw ir<%indvars.iv734>, ir<1>
    CLONE ir<%exitcond738.not> = icmp eq ir<%indvars.iv.next735>, ir<%wide.trip.count737>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv734 = phi %11, %indvars.iv.next735, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv734>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    WIDEN ir<%indvars.iv.next735> = add nuw nsw ir<%indvars.iv734>, ir<1>
    CLONE ir<%exitcond738.not> = icmp eq ir<%indvars.iv.next735>, ir<%wide.trip.count737>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv734 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next735, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv734 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next735 = add nuw nsw i64 %indvars.iv734, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond738.not = icmp eq i64 %indvars.iv.next735, %wide.trip.count737 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond738.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv734 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next735, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv734 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next735 = add nuw nsw i64 %indvars.iv734, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond738.not = icmp eq i64 %indvars.iv.next735, %wide.trip.count737 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond738.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv734 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next735, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv734 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next735 = add nuw nsw i64 %indvars.iv734, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond738.not = icmp eq i64 %indvars.iv.next735, %wide.trip.count737 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond738.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv734 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next735, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv734 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next735 = add nuw nsw i64 %indvars.iv734, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond738.not = icmp eq i64 %indvars.iv.next735, %wide.trip.count737 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond738.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_referenced_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv734 = phi %11, %indvars.iv.next735, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv734>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv857 = phi %54, %indvars.iv.next858, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    CLONE ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv857>
    CLONE ir<%or360> = or ir<%55>, ir<%shl358>
    CLONE ir<%indvars.iv.next858> = add nuw nsw ir<%indvars.iv857>, ir<1>
    CLONE ir<%exitcond860.not> = icmp eq ir<%indvars.iv.next858>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv857 = phi %54, %indvars.iv.next858, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv857>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    WIDEN ir<%indvars.iv.next858> = add nuw nsw ir<%indvars.iv857>, ir<1>
    CLONE ir<%exitcond860.not> = icmp eq ir<%indvars.iv.next858>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv857 = phi %54, %indvars.iv.next858, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv857>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    WIDEN ir<%indvars.iv.next858> = add nuw nsw ir<%indvars.iv857>, ir<1>
    CLONE ir<%exitcond860.not> = icmp eq ir<%indvars.iv.next858>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv857 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next858, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv857 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next858 = add nuw nsw i64 %indvars.iv857, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond860.not = icmp eq i64 %indvars.iv.next858, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond860.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv857 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next858, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv857 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next858 = add nuw nsw i64 %indvars.iv857, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond860.not = icmp eq i64 %indvars.iv.next858, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond860.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv857 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next858, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv857 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next858 = add nuw nsw i64 %indvars.iv857, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond860.not = icmp eq i64 %indvars.iv.next858, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond860.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv857 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next858, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv857 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next858 = add nuw nsw i64 %indvars.iv857, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond860.not = icmp eq i64 %indvars.iv.next858, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond860.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_set_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv857 = phi %54, %indvars.iv.next858, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv857>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv861 = phi %42, %indvars.iv.next862, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    CLONE ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv861>
    CLONE ir<%or251> = or ir<%43>, ir<%shl249>
    CLONE ir<%indvars.iv.next862> = add nuw nsw ir<%indvars.iv861>, ir<1>
    CLONE ir<%exitcond865.not> = icmp eq ir<%indvars.iv.next862>, ir<%wide.trip.count864>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv861 = phi %42, %indvars.iv.next862, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv861>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    WIDEN ir<%indvars.iv.next862> = add nuw nsw ir<%indvars.iv861>, ir<1>
    CLONE ir<%exitcond865.not> = icmp eq ir<%indvars.iv.next862>, ir<%wide.trip.count864>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv861 = phi %42, %indvars.iv.next862, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv861>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    WIDEN ir<%indvars.iv.next862> = add nuw nsw ir<%indvars.iv861>, ir<1>
    CLONE ir<%exitcond865.not> = icmp eq ir<%indvars.iv.next862>, ir<%wide.trip.count864>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv861 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next862, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv861 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next862 = add nuw nsw i64 %indvars.iv861, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond865.not = icmp eq i64 %indvars.iv.next862, %wide.trip.count864 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond865.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv861 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next862, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv861 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next862 = add nuw nsw i64 %indvars.iv861, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond865.not = icmp eq i64 %indvars.iv.next862, %wide.trip.count864 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond865.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv861 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next862, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv861 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next862 = add nuw nsw i64 %indvars.iv861, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond865.not = icmp eq i64 %indvars.iv.next862, %wide.trip.count864 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond865.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv861 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next862, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv861 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next862 = add nuw nsw i64 %indvars.iv861, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond865.not = icmp eq i64 %indvars.iv.next862, %wide.trip.count864 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond865.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_set_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv861 = phi %42, %indvars.iv.next862, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv861>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %98 to i64))<nsw> + ((1 + (zext i32 %98 to i64))<nuw><nsw> umax ((zext i32 %98 to i64) + (zext i32 %cond6151084 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1071 = phi %105, %indvars.iv.next1072, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410351037> = phi ir<%and624.lcssa10421045>, ir<%and624>
    CLONE ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1071>
    CLONE ir<%not623> = xor ir<%shl622>, ir<-1>
    CLONE ir<%and624> = and ir<%and62410351037>, ir<%not623>
    CLONE ir<%indvars.iv.next1072> = add nuw nsw ir<%indvars.iv1071>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1072>, ir<%106>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410351037>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %98 to i64))<nsw> + ((1 + (zext i32 %98 to i64))<nuw><nsw> umax ((zext i32 %98 to i64) + (zext i32 %cond6151084 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1071 = phi %105, %indvars.iv.next1072, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410351037> = phi ir<%and624.lcssa10421045>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1071>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410351037>, ir<%not623>
    WIDEN ir<%indvars.iv.next1072> = add nuw nsw ir<%indvars.iv1071>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1072>, ir<%106>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410351037>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %98 to i64))<nsw> + ((1 + (zext i32 %98 to i64))<nuw><nsw> umax ((zext i32 %98 to i64) + (zext i32 %cond6151084 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1071 = phi %105, %indvars.iv.next1072, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410351037> = phi ir<%and624.lcssa10421045>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1071>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410351037>, ir<%not623>
    WIDEN ir<%indvars.iv.next1072> = add nuw nsw ir<%indvars.iv1071>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1072>, ir<%106>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410351037>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1071 = phi i64 [ %105, %for.body620.preheader ], [ %indvars.iv.next1072, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and62410351037 = phi i64 [ %and624.lcssa10421045, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1071 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and624 = and i64 %and62410351037, %not623 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1072 = add nuw nsw i64 %indvars.iv1071, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1072, %106 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1071 = phi i64 [ %105, %for.body620.preheader ], [ %indvars.iv.next1072, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and62410351037 = phi i64 [ %and624.lcssa10421045, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1071 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and624 = and i64 %and62410351037, %not623 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1072 = add nuw nsw i64 %indvars.iv1071, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1072, %106 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1071 = phi i64 [ %105, %for.body620.preheader ], [ %indvars.iv.next1072, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and62410351037 = phi i64 [ %and624.lcssa10421045, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1071 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and624 = and i64 %and62410351037, %not623 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1072 = add nuw nsw i64 %indvars.iv1071, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1072, %106 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1071 = phi i64 [ %105, %for.body620.preheader ], [ %indvars.iv.next1072, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and62410351037 = phi i64 [ %and624.lcssa10421045, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1071 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and624 = and i64 %and62410351037, %not623 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1072 = add nuw nsw i64 %indvars.iv1071, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1072, %106 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_target_live_regs at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %98 to i64))<nsw> + ((1 + (zext i32 %98 to i64))<nuw><nsw> umax ((zext i32 %98 to i64) + (zext i32 %cond6151084 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1071 = phi %105, %indvars.iv.next1072, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410351037> = phi ir<%and624.lcssa10421045>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1071>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410351037>, ir<%not623>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410351037>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %84 to i64))<nsw> + ((1 + (zext i32 %84 to i64))<nuw><nsw> umax ((zext i32 %84 to i64) + (zext i32 %cond4731081 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %91, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110221024> = phi ir<%or481.lcssa10291032>, ir<%or481>
    CLONE ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1068>
    CLONE ir<%or481> = or ir<%or48110221024>, ir<%shl480>
    CLONE ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1069>, ir<%92>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110221024>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %84 to i64))<nsw> + ((1 + (zext i32 %84 to i64))<nuw><nsw> umax ((zext i32 %84 to i64) + (zext i32 %cond4731081 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %91, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110221024> = phi ir<%or481.lcssa10291032>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%or481> = or ir<%or48110221024>, ir<%shl480>
    WIDEN ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1069>, ir<%92>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110221024>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %84 to i64))<nsw> + ((1 + (zext i32 %84 to i64))<nuw><nsw> umax ((zext i32 %84 to i64) + (zext i32 %cond4731081 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %91, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110221024> = phi ir<%or481.lcssa10291032>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%or481> = or ir<%or48110221024>, ir<%shl480>
    WIDEN ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1069>, ir<%92>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110221024>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1068 = phi i64 [ %91, %for.body478.preheader ], [ %indvars.iv.next1069, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or48110221024 = phi i64 [ %or481.lcssa10291032, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or481 = or i64 %or48110221024, %shl480 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1069, %92 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1068 = phi i64 [ %91, %for.body478.preheader ], [ %indvars.iv.next1069, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or48110221024 = phi i64 [ %or481.lcssa10291032, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or481 = or i64 %or48110221024, %shl480 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1069, %92 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1068 = phi i64 [ %91, %for.body478.preheader ], [ %indvars.iv.next1069, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or48110221024 = phi i64 [ %or481.lcssa10291032, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or481 = or i64 %or48110221024, %shl480 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1069, %92 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1068 = phi i64 [ %91, %for.body478.preheader ], [ %indvars.iv.next1069, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or48110221024 = phi i64 [ %or481.lcssa10291032, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or481 = or i64 %or48110221024, %shl480 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1069, %92 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: mark_target_live_regs at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %84 to i64))<nsw> + ((1 + (zext i32 %84 to i64))<nuw><nsw> umax ((zext i32 %84 to i64) + (zext i32 %cond4731081 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %91, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110221024> = phi ir<%or481.lcssa10291032>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%or481> = or ir<%or48110221024>, ir<%shl480>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110221024>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 25
Loops Epilogues Vectorized: 0
================================================
========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    CLONE ir<%sh_prom85> = zext nneg ir<%i.1139>
    CLONE ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    CLONE ir<%or> = or ir<%or134138>, ir<%shl86>
    CLONE ir<%not89> = xor ir<%shl86>, ir<-1>
    CLONE ir<%and90> = and ir<%and90135137>, ir<%not89>
    CLONE ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    WIDEN ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    WIDEN ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}


-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: update_live_status at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}
================ Final VPlan ================

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    CLONE ir<%sh_prom> = zext nneg ir<%i.0144>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and79> = and ir<%and79141143>, ir<%not>
    CLONE ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    WIDEN ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    WIDEN ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}


-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: update_live_status at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rtl.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                rtl.c
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx49>
    CLONE store ir<%1>, ir<%arrayidx46>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%1> = load vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%1> = load vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 514, RTCostB: 1530
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 514, RTCostB: 1530
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1530
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 514

-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i64, ptr %arrayidx49, align 8, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %1, ptr %arrayidx46, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 270, RTCostB: 1530
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 270, RTCostB: 514
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: shallow_copy_rtx at line: rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, vp<%4>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%5> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%6>, ir<%5>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rtlanal.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                rtlanal.c
MVT: v2i64
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 -> Cost: 4 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2i64
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 -> Cost: 4 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: nxv2i64
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx11>
    CLONE ir<%bf.load12> = load ir<%4>
    CLONE ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    CLONE ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    CLONE ir<%5> = load ir<%fld20>, ir<%cmp14>
    CLONE ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    CLONE ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    CLONE ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%4> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    CLONE ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = not ir<%cmp14>
    EMIT vp<%6> = or ir<%cmp14>, vp<%5>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%4>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%9>
}

========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%4>
    REPLICATE ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    REPLICATE ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    REPLICATE ir<%5> = load ir<%fld20>, ir<%cmp14>
    REPLICATE ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%5> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    WIDEN-SELECT ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = or ir<%cmp14>, vp<%6>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%5>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}

========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%4>
    REPLICATE ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    REPLICATE ir<%5> = load ir<%fld20>, ir<%cmp14>
    REPLICATE ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%5> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    WIDEN-SELECT ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = or ir<%cmp14>, vp<%6>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%5>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}

========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    WIDEN ir<%5> = load ir<%fld20>, ir<%cmp14>
    WIDEN ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%5> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    WIDEN-SELECT ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = or ir<%cmp14>, vp<%6>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%5>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}


-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load ptr, ptr %fld20, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %5 = load ptr, ptr %fld20, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width 2 costs: 3000024
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6000049
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 6000049, CostB * EstimatedWidthA: 22
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6000049
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 6000049, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %5 = load ptr, ptr %fld20, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 12 for VF 4 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width 4 costs: 1500022
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6000091
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 6000091, CostB * EstimatedWidthA: 44
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6000091
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 6000091, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load ptr, ptr %fld20, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8, !tbaa !12 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %5 = load ptr, ptr %fld20, align 8, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width vscale x 2 costs: 33
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 133
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 133, CostB * EstimatedWidthA: 44
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 133
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 133, CostB * EstimatedWidthA: 44
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rtl-error.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                rtl-error.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sbitmap.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sbitmap.c
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_vector_alloc' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_vecs to i64)
  EMIT vp<%3> = EXPAND SCEV (16 + (8 * ((63 + %n_elms) /u 64))<nuw><nsw>)<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %offset.040 = phi %mul7, %add19, vp<%3>
    CLONE ir<%idx.ext> = zext ir<%offset.040>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%idx.ext>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%add.ptr>, ir<%arrayidx>
    CLONE store ir<%n_elms>, ir<%add.ptr>
    CLONE ir<%size17> = getelementptr inbounds ir<%add.ptr>, ir<4>
    CLONE store ir<%div37>, ir<%size17>
    CLONE ir<%bytes18> = getelementptr inbounds ir<%add.ptr>, ir<8>
    CLONE store ir<%0>, ir<%bytes18>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%add19> = add ir<%1>, ir<%offset.040>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_vector_alloc' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_vecs to i64)
  EMIT vp<%3> = EXPAND SCEV (16 + (8 * ((63 + %n_elms) /u 64))<nuw><nsw>)<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %offset.040 = phi %mul7, %add19, vp<%3>
    WIDEN-CAST ir<%idx.ext> = zext  ir<%offset.040> to i64
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%idx.ext>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%add.ptr>
    REPLICATE store ir<%n_elms>, ir<%add.ptr>
    REPLICATE ir<%size17> = getelementptr inbounds ir<%add.ptr>, ir<4>
    REPLICATE store ir<%div37>, ir<%size17>
    REPLICATE ir<%bytes18> = getelementptr inbounds ir<%add.ptr>, ir<8>
    REPLICATE store ir<%0>, ir<%bytes18>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN ir<%add19> = add ir<%1>, ir<%offset.040>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_vector_alloc' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_vecs to i64)
  EMIT vp<%3> = EXPAND SCEV (16 + (8 * ((63 + %n_elms) /u 64))<nuw><nsw>)<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %offset.040 = phi %mul7, %add19, vp<%3>
    WIDEN-CAST ir<%idx.ext> = zext  ir<%offset.040> to i64
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%idx.ext>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%add.ptr>
    REPLICATE store ir<%n_elms>, ir<%add.ptr>
    WIDEN-GEP Var[Inv] ir<%size17> = getelementptr inbounds ir<%add.ptr>, ir<4>
    REPLICATE store ir<%div37>, ir<%size17>
    WIDEN-GEP Var[Inv] ir<%bytes18> = getelementptr inbounds ir<%add.ptr>, ir<8>
    REPLICATE store ir<%0>, ir<%bytes18>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN ir<%add19> = add ir<%1>, ir<%offset.040>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_vector_alloc' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_vecs to i64)
  EMIT vp<%3> = EXPAND SCEV (16 + (8 * ((63 + %n_elms) /u 64))<nuw><nsw>)<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %offset.040 = phi %mul7, %add19, vp<%3>
    WIDEN-CAST ir<%idx.ext> = zext  ir<%offset.040> to i64
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%idx.ext>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%add.ptr>
    WIDEN store ir<%add.ptr>, ir<%n_elms>
    WIDEN-GEP Var[Inv] ir<%size17> = getelementptr inbounds ir<%add.ptr>, ir<4>
    WIDEN store ir<%size17>, ir<%div37>
    WIDEN-GEP Var[Inv] ir<%bytes18> = getelementptr inbounds ir<%add.ptr>, ir<8>
    WIDEN store ir<%bytes18>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN ir<%add19> = add ir<%1>, ir<%offset.040>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_vector_alloc' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %offset.040 = phi i32 [ %mul7, %for.body.preheader ], [ %add19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.ext = zext i32 %offset.040 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %idx.ext of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %n_elms, ptr %add.ptr, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size17 = getelementptr inbounds i8, ptr %add.ptr, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %div37, ptr %size17, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bytes18 = getelementptr inbounds i8, ptr %add.ptr, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %0, ptr %bytes18, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add19 = add i32 %1, %offset.040 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'sbitmap_vector_alloc' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %offset.040 = phi i32 [ %mul7, %for.body.preheader ], [ %add19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.ext = zext i32 %offset.040 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %idx.ext of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 %n_elms, ptr %add.ptr, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %size17 = getelementptr inbounds i8, ptr %add.ptr, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 %div37, ptr %size17, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bytes18 = getelementptr inbounds i8, ptr %add.ptr, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 %0, ptr %bytes18, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add19 = add i32 %1, %offset.040 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 41
A is not scalable.	B is not scalable.	
RTCostA: 176093659065, RTCostB: 47244640245
A is not scalable.	B is not scalable.	
RTCostA: 176093659065, RTCostB: 47244640245

-----------------Function that is being costed:'sbitmap_vector_alloc' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %offset.040 = phi i32 [ %mul7, %for.body.preheader ], [ %add19, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idx.ext = zext i32 %offset.040 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %idx.ext of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 %n_elms, ptr %add.ptr, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %size17 = getelementptr inbounds i8, ptr %add.ptr, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 %div37, ptr %size17, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bytes18 = getelementptr inbounds i8, ptr %add.ptr, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 %0, ptr %bytes18, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add19 = add i32 %1, %offset.040 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 40
A is not scalable.	B is not scalable.	
RTCostA: 175019917182, RTCostB: 47244640245
A is not scalable.	B is not scalable.	
RTCostA: 175019917182, RTCostB: 47244640245

-----------------Function that is being costed:'sbitmap_vector_alloc' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %offset.040 = phi i32 [ %mul7, %for.body.preheader ], [ %add19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.ext = zext i32 %offset.040 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %idx.ext of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %n_elms, ptr %add.ptr, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %size17 = getelementptr inbounds i8, ptr %add.ptr, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %div37, ptr %size17, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bytes18 = getelementptr inbounds i8, ptr %add.ptr, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %0, ptr %bytes18, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add19 = add i32 %1, %offset.040 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245

-----------------Function that is being costed:'sbitmap_vector_alloc' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %offset.040 = phi i32 [ %mul7, %for.body.preheader ], [ %add19, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.ext = zext i32 %offset.040 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %idx.ext of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %arrayidx, align 8, !tbaa !6 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %n_elms, ptr %add.ptr, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %size17 = getelementptr inbounds i8, ptr %add.ptr, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %div37, ptr %size17, align 4, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bytes18 = getelementptr inbounds i8, ptr %add.ptr, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %0, ptr %bytes18, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add19 = add i32 %1, %offset.040 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 136365211554, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: 136365211554, RTCostB: 47244640245
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: sbitmap_vector_alloc at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_vecs to i64)
  EMIT vp<%3> = EXPAND SCEV (16 + (8 * ((63 + %n_elms) /u 64))<nuw><nsw>)<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%mul7> + vp<%4> * vp<%3>
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%idx.ext> = zext vp<%7>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%idx.ext>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, vp<%5>
    CLONE store ir<%add.ptr>, ir<%arrayidx>
    CLONE store ir<%n_elms>, ir<%add.ptr>
    CLONE ir<%size17> = getelementptr inbounds ir<%add.ptr>, ir<4>
    CLONE store ir<%div37>, ir<%size17>
    CLONE ir<%bytes18> = getelementptr inbounds ir<%add.ptr>, ir<8>
    CLONE store ir<%0>, ir<%bytes18>
    EMIT vp<%8> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not, ptr %dstp.08, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %not, ptr %dstp.08, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not, ptr %dstp.08, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_not' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%srcp.09> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.08> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.07 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%srcp.09>, ir<8>
    CLONE ir<%1> = load ir<%srcp.09>
    CLONE ir<%not> = xor ir<%1>, ir<-1>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%dstp.08>, ir<8>
    CLONE store ir<%not>, ir<%dstp.08>
    CLONE ir<%inc> = add nuw ir<%i.07>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_not' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%srcp.09> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.08> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.07 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%srcp.09>, ir<8>
    vp<%4> = vector-pointer ir<%srcp.09>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%not> = xor ir<%1>, ir<-1>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%dstp.08>, ir<8>
    vp<%5> = vector-pointer ir<%dstp.08>
    WIDEN store vp<%5>, ir<%not>
    CLONE ir<%inc> = add nuw ir<%i.07>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_not' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%srcp.09> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.08> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.07 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%srcp.09>, ir<8>
    vp<%4> = vector-pointer ir<%srcp.09>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%not> = xor ir<%1>, ir<-1>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%dstp.08>, ir<8>
    vp<%5> = vector-pointer ir<%dstp.08>
    WIDEN store vp<%5>, ir<%not>
    CLONE ir<%inc> = add nuw ir<%i.07>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_not' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %srcp.09 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dstp.08 = phi ptr [ %incdec.ptr3, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.07 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %srcp.09, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %1, -1 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %dstp.08, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %not, ptr %dstp.08, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw i32 %i.07, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'sbitmap_not' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %srcp.09 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dstp.08 = phi ptr [ %incdec.ptr3, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.07 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %srcp.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %1, -1 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %dstp.08, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %not, ptr %dstp.08, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw i32 %i.07, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_not' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %srcp.09 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dstp.08 = phi ptr [ %incdec.ptr3, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.07 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %srcp.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %1, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %dstp.08, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %not, ptr %dstp.08, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw i32 %i.07, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771065
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418242

-----------------Function that is being costed:'sbitmap_not' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %srcp.09 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dstp.08 = phi ptr [ %incdec.ptr3, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.07 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %srcp.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i64, ptr %srcp.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %1, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %dstp.08, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %not, ptr %dstp.08, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw i32 %i.07, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 30064771065
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 10737418242
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_not at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms1>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%5> = load vp<%10>
    WIDEN ir<%not> = xor ir<%5>, ir<-1>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%not>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %1 = load i64, ptr %ap.012, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %bp.013, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and, ptr %dstp.011, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i64, ptr %ap.012, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %2 = load i64, ptr %bp.013, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %and, ptr %dstp.011, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %1 = load i64, ptr %ap.012, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %bp.013, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and, ptr %dstp.011, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_difference' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%bp.013> = WIDEN-POINTER-INDUCTION ir<%elms3>, 8
    EMIT ir<%ap.012> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.011> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.010 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ap.012>, ir<8>
    CLONE ir<%1> = load ir<%ap.012>
    CLONE ir<%incdec.ptr5> = getelementptr inbounds ir<%bp.013>, ir<8>
    CLONE ir<%2> = load ir<%bp.013>
    CLONE ir<%not> = xor ir<%2>, ir<-1>
    CLONE ir<%and> = and ir<%1>, ir<%not>
    CLONE ir<%incdec.ptr6> = getelementptr inbounds ir<%dstp.011>, ir<8>
    CLONE store ir<%and>, ir<%dstp.011>
    CLONE ir<%inc> = add nuw ir<%i.010>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_difference' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%bp.013> = WIDEN-POINTER-INDUCTION ir<%elms3>, 8
    EMIT ir<%ap.012> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.011> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.010 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ap.012>, ir<8>
    vp<%4> = vector-pointer ir<%ap.012>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr5> = getelementptr inbounds ir<%bp.013>, ir<8>
    vp<%5> = vector-pointer ir<%bp.013>
    WIDEN ir<%2> = load vp<%5>
    WIDEN ir<%not> = xor ir<%2>, ir<-1>
    WIDEN ir<%and> = and ir<%1>, ir<%not>
    CLONE ir<%incdec.ptr6> = getelementptr inbounds ir<%dstp.011>, ir<8>
    vp<%6> = vector-pointer ir<%dstp.011>
    WIDEN store vp<%6>, ir<%and>
    CLONE ir<%inc> = add nuw ir<%i.010>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_difference' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%bp.013> = WIDEN-POINTER-INDUCTION ir<%elms3>, 8
    EMIT ir<%ap.012> = WIDEN-POINTER-INDUCTION ir<%elms1>, 8
    EMIT ir<%dstp.011> = WIDEN-POINTER-INDUCTION ir<%elms>, 8
    WIDEN-INDUCTION %i.010 = phi %inc, 0, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ap.012>, ir<8>
    vp<%4> = vector-pointer ir<%ap.012>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr5> = getelementptr inbounds ir<%bp.013>, ir<8>
    vp<%5> = vector-pointer ir<%bp.013>
    WIDEN ir<%2> = load vp<%5>
    WIDEN ir<%not> = xor ir<%2>, ir<-1>
    WIDEN ir<%and> = and ir<%1>, ir<%not>
    CLONE ir<%incdec.ptr6> = getelementptr inbounds ir<%dstp.011>, ir<8>
    vp<%6> = vector-pointer ir<%dstp.011>
    WIDEN store vp<%6>, ir<%and>
    CLONE ir<%inc> = add nuw ir<%i.010>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_difference' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bp.013 = phi ptr [ %incdec.ptr5, %for.body ], [ %elms3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ap.012 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dstp.011 = phi ptr [ %incdec.ptr6, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ap.012, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i64, ptr %ap.012, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr5 = getelementptr inbounds i8, ptr %bp.013, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i64, ptr %bp.013, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %2, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i64 %1, %not of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr6 = getelementptr inbounds i8, ptr %dstp.011, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and, ptr %dstp.011, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw i32 %i.010, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'sbitmap_difference' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bp.013 = phi ptr [ %incdec.ptr5, %for.body ], [ %elms3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ap.012 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dstp.011 = phi ptr [ %incdec.ptr6, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ap.012, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i64, ptr %ap.012, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr5 = getelementptr inbounds i8, ptr %bp.013, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load i64, ptr %bp.013, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %2, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i64 %1, %not of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr6 = getelementptr inbounds i8, ptr %dstp.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %and, ptr %dstp.011, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw i32 %i.010, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385539, RTCostB: 42949672950
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385539, RTCostB: 42949672950
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_difference' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bp.013 = phi ptr [ %incdec.ptr5, %for.body ], [ %elms3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ap.012 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dstp.011 = phi ptr [ %incdec.ptr6, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ap.012, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i64, ptr %ap.012, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr5 = getelementptr inbounds i8, ptr %bp.013, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i64, ptr %bp.013, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %not = xor i64 %2, -1 of type:xor
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and = and i64 %1, %not of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr6 = getelementptr inbounds i8, ptr %dstp.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and, ptr %dstp.011, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw i32 %i.010, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672950
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385539

-----------------Function that is being costed:'sbitmap_difference' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bp.013 = phi ptr [ %incdec.ptr5, %for.body ], [ %elms3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ap.012 = phi ptr [ %incdec.ptr, %for.body ], [ %elms1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dstp.011 = phi ptr [ %incdec.ptr6, %for.body ], [ %elms, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ap.012, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i64, ptr %ap.012, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr5 = getelementptr inbounds i8, ptr %bp.013, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i64, ptr %bp.013, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i64 %2, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i64 %1, %not of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr6 = getelementptr inbounds i8, ptr %dstp.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %and, ptr %dstp.011, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw i32 %i.010, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192791, RTCostB: 42949672950
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192791, RTCostB: 15032385539
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_difference at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%16>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms3>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms1>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<8>
    EMIT vp<%12> = ptradd ir<%elms>, vp<%11>
    vp<%13> = vector-pointer vp<%9>
    WIDEN ir<%7> = load vp<%13>
    vp<%14> = vector-pointer vp<%6>
    WIDEN ir<%8> = load vp<%14>
    WIDEN ir<%not> = xor ir<%8>, ir<-1>
    WIDEN ir<%and> = and ir<%7>, ir<%not>
    vp<%15> = vector-pointer vp<%12>
    WIDEN store vp<%15>, ir<%and>
    EMIT vp<%16> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%16>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    CLONE ir<%9> = load ir<%p.054.us>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    CLONE ir<%10> = load ir<%r.055.us>
    CLONE ir<%and.us> = and ir<%10>, ir<%9>
    CLONE store ir<%and.us>, ir<%r.055.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705655
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901891

-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %and.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 38654705655
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 12884901891
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_intersection_of_succs at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms19>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%and.us> = and ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%and.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    CLONE ir<%9> = load ir<%p.052.us>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    CLONE ir<%10> = load ir<%r.053.us>
    CLONE ir<%and.us> = and ir<%10>, ir<%9>
    CLONE store ir<%and.us>, ir<%r.053.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705655
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901891

-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %and.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 38654705655
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 12884901891
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_intersection_of_preds at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms20>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%and.us> = and ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%and.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 18
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    CLONE ir<%9> = load ir<%p.054.us>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    CLONE ir<%10> = load ir<%r.055.us>
    CLONE ir<%or.us> = or ir<%10>, ir<%9>
    CLONE store ir<%or.us>, ir<%r.055.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705655
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901891

-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %or.us, ptr %r.055.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 38654705655
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 12884901891
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_union_of_succs at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms19>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%or.us> = or ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%or.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 21
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    CLONE ir<%9> = load ir<%p.052.us>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    CLONE ir<%10> = load ir<%r.053.us>
    CLONE ir<%or.us> = or ir<%10>, ir<%9>
    CLONE store ir<%or.us>, ir<%r.053.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901891, RTCostB: 38654705655
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705655
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901891

-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i64 %or.us, ptr %r.053.us, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 38654705655
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450965, RTCostB: 12884901891
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: sbitmap_union_of_preds at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms20>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%or.us> = or ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%or.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sched-deps.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sched-deps.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sched-ebb.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sched-ebb.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sched-rgn.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sched-rgn.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sched-vis.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sched-vis.c
========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    CLONE ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE ir<%2> = load ir<%bitmask>
    CLONE ir<%and> = and ir<%1>, ir<%2>
    CLONE ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    CLONE ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    CLONE ir<%3> = load ir<%multiplicity>, vp<%3>
    CLONE ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    CLONE ir<%4> = mul ir<%3>, ir<%conv>
    CLONE ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}

========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    REPLICATE ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    REPLICATE ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    REPLICATE ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}

========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    REPLICATE ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}

========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    WIDEN ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}


-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width 2 costs: 1500026
A is not scalable.	B is not scalable.	
RTCostA: 39000689, RTCostB: 182
A is not scalable.	B is not scalable.	
RTCostA: 39000689, RTCostB: 182

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width 4 costs: 750024
A is not scalable.	B is not scalable.	
RTCostA: 18000608, RTCostB: 182
A is not scalable.	B is not scalable.	
RTCostA: 18000608, RTCostB: 182

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 182
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 182

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 22
A is scalable.	B is not scalable.	
RTCostA: 560, RTCostB: 182
A is scalable.	B is not scalable.	
RTCostA: 560, RTCostB: 182

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %2 = load i32, ptr %bitmask, align 8, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %3 = load i32, ptr %multiplicity, align 4, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 530, RTCostB: 182
A is scalable.	B is not scalable.	
RTCostA: 530, RTCostB: 182
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sdbout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sdbout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sibcall.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                sibcall.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o simplify-rtx.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                simplify-rtx.c
========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1018 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv970 = phi 0, %indvars.iv.next971, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1017>, ir<%spec.select>
    CLONE ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv970>
    CLONE ir<%26> = load ir<%arrayidx260>
    CLONE ir<%bf.load262> = load ir<%26>
    CLONE ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    CLONE ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    CLONE ir<%inc267> = zext ir<%cmp264>
    CLONE ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    CLONE ir<%indvars.iv.next971> = add nuw nsw ir<%indvars.iv970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.body272.preheader>, scalar.ph

ir-bb<do.body272.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1018 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv970 = phi 0, %indvars.iv.next971, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1017>, ir<%spec.select>
    CLONE ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv970>
    INTERLEAVE-GROUP with factor 2 at %26, ir<%arrayidx260>
      ir<%26> = load from index 0
    REPLICATE ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    CLONE ir<%indvars.iv.next971> = add nuw nsw ir<%indvars.iv970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1018 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv970 = phi 0, %indvars.iv.next971, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1017>, ir<%spec.select>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv970>
    REPLICATE ir<%26> = load ir<%arrayidx260>
    REPLICATE ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    WIDEN ir<%indvars.iv.next971> = add nuw nsw ir<%indvars.iv970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1018 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv970 = phi 0, %indvars.iv.next971, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1017>, ir<%spec.select>
    CLONE ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv970>
    INTERLEAVE-GROUP with factor 2 at %26, ir<%arrayidx260>
      ir<%26> = load from index 0
    WIDEN ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    CLONE ir<%indvars.iv.next971> = add nuw nsw ir<%indvars.iv970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv970 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next971, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1017, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv970 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next971 = add nuw nsw i64 %indvars.iv970, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv970 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next971, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1017, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv970 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next971 = add nuw nsw i64 %indvars.iv970, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 40802189284, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 40802189284, RTCostB: 21474836470

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv970 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next971, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1017, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv970 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 4 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next971 = add nuw nsw i64 %indvars.iv970, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 37580963800, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 37580963800, RTCostB: 21474836470

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv970 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next971, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1017, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv970 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next971 = add nuw nsw i64 %indvars.iv970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv970 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next971, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1017, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv970 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next971 = add nuw nsw i64 %indvars.iv970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 26306674669, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: 26306674669, RTCostB: 21474836470
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1018 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1017>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, vp<%4>
    CLONE ir<%26> = load ir<%arrayidx260>
    CLONE ir<%bf.load262> = load ir<%26>
    CLONE ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    CLONE ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    CLONE ir<%inc267> = zext ir<%cmp264>
    CLONE ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.body272.preheader>, scalar.ph

ir-bb<do.body272.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}
================ Final VPlan ================

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41040 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv990 = phi 0, %indvars.iv.next991, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    CLONE ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv990>
    CLONE ir<%52> = load ir<%arrayidx610>
    CLONE ir<%bf.load612> = load ir<%52>
    CLONE ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    CLONE ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    CLONE ir<%inc617> = zext ir<%cmp614>
    CLONE ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    CLONE ir<%indvars.iv.next991> = add nuw nsw ir<%indvars.iv990>, ir<1>
    CLONE ir<%exitcond994.not> = icmp eq ir<%indvars.iv.next991>, ir<%wide.trip.count993>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end621.loopexit>, scalar.ph

ir-bb<for.end621.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select904.lcssa = vp<%6>
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41040 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv990 = phi 0, %indvars.iv.next991, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    CLONE ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv990>
    INTERLEAVE-GROUP with factor 2 at %52, ir<%arrayidx610>
      ir<%52> = load from index 0
    REPLICATE ir<%bf.load612> = load ir<%52>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    CLONE ir<%indvars.iv.next991> = add nuw nsw ir<%indvars.iv990>, ir<1>
    CLONE ir<%exitcond994.not> = icmp eq ir<%indvars.iv.next991>, ir<%wide.trip.count993>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41040 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv990 = phi 0, %indvars.iv.next991, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv990>
    REPLICATE ir<%52> = load ir<%arrayidx610>
    REPLICATE ir<%bf.load612> = load ir<%52>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    WIDEN ir<%indvars.iv.next991> = add nuw nsw ir<%indvars.iv990>, ir<1>
    CLONE ir<%exitcond994.not> = icmp eq ir<%indvars.iv.next991>, ir<%wide.trip.count993>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41040 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv990 = phi 0, %indvars.iv.next991, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    CLONE ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv990>
    INTERLEAVE-GROUP with factor 2 at %52, ir<%arrayidx610>
      ir<%52> = load from index 0
    WIDEN ir<%bf.load612> = load ir<%52>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    CLONE ir<%indvars.iv.next991> = add nuw nsw ir<%indvars.iv990>, ir<1>
    CLONE ir<%exitcond994.not> = icmp eq ir<%indvars.iv.next991>, ir<%wide.trip.count993>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv990 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next991, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv990 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %52 = load ptr, ptr %arrayidx610, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %bf.load612 = load i32, ptr %52, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next991 = add nuw nsw i64 %indvars.iv990, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond994.not = icmp eq i64 %indvars.iv.next991, %wide.trip.count993 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond994.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv990 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next991, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv990 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %52 = load ptr, ptr %arrayidx610, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %bf.load612 = load i32, ptr %52, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next991 = add nuw nsw i64 %indvars.iv990, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond994.not = icmp eq i64 %indvars.iv.next991, %wide.trip.count993 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond994.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv990 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next991, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv990 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 4 For instruction:   %52 = load ptr, ptr %arrayidx610, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %bf.load612 = load i32, ptr %52, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next991 = add nuw nsw i64 %indvars.iv990, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond994.not = icmp eq i64 %indvars.iv.next991, %wide.trip.count993 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond994.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 70
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 70, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 70
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 70, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv990 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next991, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv990 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %52 = load ptr, ptr %arrayidx610, align 8, !tbaa !6 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.load612 = load i32, ptr %52, align 8 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next991 = add nuw nsw i64 %indvars.iv990, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond994.not = icmp eq i64 %indvars.iv.next991, %wide.trip.count993 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond994.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv990 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next991, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv990 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %52 = load ptr, ptr %arrayidx610, align 8, !tbaa !6 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %bf.load612 = load i32, ptr %52, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next991 = add nuw nsw i64 %indvars.iv990, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond994.not = icmp eq i64 %indvars.iv.next991, %wide.trip.count993 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond994.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 49
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 49, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 49
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 49, CostB * EstimatedWidthA: 40
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41040 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, vp<%4>
    CLONE ir<%52> = load ir<%arrayidx610>
    CLONE ir<%bf.load612> = load ir<%52>
    CLONE ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    CLONE ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    CLONE ir<%inc617> = zext ir<%cmp614>
    CLONE ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end621.loopexit>, scalar.ph

ir-bb<for.end621.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select904.lcssa = vp<%7>
}
================ Final VPlan ================

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41039 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1000 = phi 0, %indvars.iv.next1001, ir<1>
    CLONE ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv1000>, ir<1>
    CLONE store ir<0>, ir<%neg656>
    CLONE ir<%indvars.iv.next1001> = add nuw nsw ir<%indvars.iv1000>, ir<1>
    CLONE ir<%exitcond1004.not> = icmp eq ir<%indvars.iv.next1001>, ir<%wide.trip.count1003>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41039 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1000 = phi 0, %indvars.iv.next1001, ir<1>
    REPLICATE ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv1000>, ir<1>
    REPLICATE store ir<0>, ir<%neg656>
    REPLICATE ir<%indvars.iv.next1001> = add nuw nsw ir<%indvars.iv1000>, ir<1>
    CLONE ir<%exitcond1004.not> = icmp eq ir<%indvars.iv.next1001>, ir<%wide.trip.count1003>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41039 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1000 = phi 0, %indvars.iv.next1001, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv1000>, ir<1>
    REPLICATE store ir<0>, ir<%neg656>
    WIDEN ir<%indvars.iv.next1001> = add nuw nsw ir<%indvars.iv1000>, ir<1>
    CLONE ir<%exitcond1004.not> = icmp eq ir<%indvars.iv.next1001>, ir<%wide.trip.count1003>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41039 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1000 = phi 0, %indvars.iv.next1001, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv1000>, ir<1>
    WIDEN store ir<%neg656>, ir<0>
    WIDEN ir<%indvars.iv.next1001> = add nuw nsw ir<%indvars.iv1000>, ir<1>
    CLONE ir<%exitcond1004.not> = icmp eq ir<%indvars.iv.next1001>, ir<%wide.trip.count1003>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1000 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next1001, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv1000, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %neg656, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next1001 = add nuw nsw i64 %indvars.iv1000, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1004.not = icmp eq i64 %indvars.iv.next1001, %wide.trip.count1003 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1004.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 32
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41039 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, vp<%4>, ir<1>
    CLONE store ir<0>, ir<%neg656>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ssa.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ssa.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ssa-ccp.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ssa-ccp.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ssa-dce.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ssa-dce.c
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    CLONE store ir<-3>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<-3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<-3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1610612745

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -3, ptr %arrayidx, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306393, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306393, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: ssa_eliminate_dead_code at line: ssa-dce.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<-3>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %22 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv746 = phi 0, %indvars.iv.next747, ir<1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%call4>, ir<%indvars.iv746>
    CLONE ir<%23> = load ir<%arrayidx11>
    CLONE ir<%cmp12> = icmp eq ir<%23>, ir<-3>
  Successor(s): if.then

  if.then:
    CLONE store ir<-2>, ir<%arrayidx11>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%4> = not ir<%cmp12>
    EMIT vp<%5> = or vp<%4>, ir<%cmp12>
    CLONE ir<%indvars.iv.next747> = add nuw nsw ir<%indvars.iv746>, ir<1>
    CLONE ir<%exitcond750.not> = icmp eq ir<%indvars.iv.next747>, ir<%wide.trip.count749>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %22 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv746 = phi 0, %indvars.iv.next747, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, ir<%indvars.iv746>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%23> = load vp<%4>
    WIDEN ir<%cmp12> = icmp eq ir<%23>, ir<-3>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%5>, ir<-2>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%6> = not ir<%cmp12>
    EMIT vp<%7> = or vp<%6>, ir<%cmp12>
    CLONE ir<%indvars.iv.next747> = add nuw nsw ir<%indvars.iv746>, ir<1>
    CLONE ir<%exitcond750.not> = icmp eq ir<%indvars.iv.next747>, ir<%wide.trip.count749>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %22 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv746 = phi 0, %indvars.iv.next747, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, ir<%indvars.iv746>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%23> = load vp<%4>
    WIDEN ir<%cmp12> = icmp eq ir<%23>, ir<-3>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%5>, ir<-2>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%6> = not ir<%cmp12>
    EMIT vp<%7> = or vp<%6>, ir<%cmp12>
    CLONE ir<%indvars.iv.next747> = add nuw nsw ir<%indvars.iv746>, ir<1>
    CLONE ir<%exitcond750.not> = icmp eq ir<%indvars.iv.next747>, ir<%wide.trip.count749>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 15032385528, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 15032385528, RTCostB: 12884901882

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 12884901882

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354573, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv746 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next747, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv746 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %23 = load i32, ptr %arrayidx11, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp12 = icmp eq i32 %23, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx11, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next747 = add nuw nsw i64 %indvars.iv746, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond750.not = icmp eq i64 %indvars.iv.next747, %wide.trip.count749 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond750.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177317, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1342177317, RTCostB: 2684354573
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: ssa_eliminate_dead_code at line: ssa-dce.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %22 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%23> = load vp<%5>
    WIDEN ir<%cmp12> = icmp eq ir<%23>, ir<-3>
    vp<%6> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%6>, ir<-2>, ir<%cmp12>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stmt.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                stmt.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stor-layout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                stor-layout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stringpool.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                stringpool.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o timevar.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                timevar.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o toplev.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                toplev.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o tree.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                tree.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o tree-dump.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                tree-dump.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o tree-inline.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                tree-inline.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o unroll.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                unroll.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o varasm.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                varasm.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o varray.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                varray.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vmsdbgout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                vmsdbgout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xcoffout.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                xcoffout.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ggc-page.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ggc-page.c
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i64> -> ttilog -> 
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx23>
    CLONE ir<%div24> = udiv ir<%1>, ir<%2>
    CLONE ir<%conv25> = trunc ir<%div24>
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    CLONE ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>)
    CLONE store ir<%spec.select>, ir<%arrayidx27>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<34>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}

========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%3>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%4>, ir<%spec.select>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<34>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}

========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%3>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%4>, ir<%spec.select>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<34>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [34 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx27 = getelementptr inbounds [34 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 34 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [34 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx27 = getelementptr inbounds [34 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 34 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 136, RTCostB: 306
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 136, RTCostB: 306
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [34 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx27 = getelementptr inbounds [34 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 34 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 106, RTCostB: 306
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 106, RTCostB: 136
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [34 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx27 = getelementptr inbounds [34 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 34 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 306
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 106

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [34 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i64, ptr %arrayidx23, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx27 = getelementptr inbounds [34 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 34 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 306
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 106
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: init_ggc at line: ggc-page.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, vp<%3>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%5> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%5>, ir<%spec.select>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<34>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o i386.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                i386.c
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv769 = phi 0, %indvars.iv.next770, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv769 = phi 0, %indvars.iv.next770\l" +
    "  ir<%23>, ir<1>
    CLONE ir<%rem240> = srem ir<%23>, ir<%call214>
    CLONE ir<%idxprom241> = zext nneg ir<%rem240>
    CLONE ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    CLONE ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv769>
    CLONE store ir<%24>, ir<%arrayidx244>
    CLONE ir<%indvars.iv.next770> = add nuw nsw ir<%indvars.iv769>, ir<1>
    CLONE ir<%exitcond773.not> = icmp eq ir<%indvars.iv.next770>, ir<%wide.trip.count772>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end390.loopexit811>, scalar.ph

ir-bb<if.end390.loopexit811>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv769 = phi 0, %indvars.iv.next770, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv769 = phi 0, %indvars.iv.next770\l" +
    "  ir<%23>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    REPLICATE ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    REPLICATE ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv769>
    vp<%4> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%4>, ir<%24>
    WIDEN ir<%indvars.iv.next770> = add nuw nsw ir<%indvars.iv769>, ir<1>
    CLONE ir<%exitcond773.not> = icmp eq ir<%indvars.iv.next770>, ir<%wide.trip.count772>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end390.loopexit811>, scalar.ph

ir-bb<if.end390.loopexit811>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv769 = phi 0, %indvars.iv.next770, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv769 = phi 0, %indvars.iv.next770\l" +
    "  ir<%23>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    REPLICATE ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv769>
    vp<%4> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%4>, ir<%24>
    WIDEN ir<%indvars.iv.next770> = add nuw nsw ir<%indvars.iv769>, ir<1>
    CLONE ir<%exitcond773.not> = icmp eq ir<%indvars.iv.next770>, ir<%wide.trip.count772>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end390.loopexit811>, scalar.ph

ir-bb<if.end390.loopexit811>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv769 = phi 0, %indvars.iv.next770, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv769 = phi 0, %indvars.iv.next770\l" +
    "  ir<%23>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    WIDEN ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv769>
    vp<%4> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%4>, ir<%24>
    WIDEN ir<%indvars.iv.next770> = add nuw nsw ir<%indvars.iv769>, ir<1>
    CLONE ir<%exitcond773.not> = icmp eq ir<%indvars.iv.next770>, ir<%wide.trip.count772>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end390.loopexit811>, scalar.ph

ir-bb<if.end390.loopexit811>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 1 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 2 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 38654705637, RTCostB: 19327352823
A is not scalable.	B is not scalable.	
RTCostA: 38654705637, RTCostB: 19327352823

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 4 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Vector loop of width 4 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 37580963797, RTCostB: 19327352823
A is not scalable.	B is not scalable.	
RTCostA: 37580963797, RTCostB: 19327352823

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 25769803755, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: 25769803755, RTCostB: 19327352823

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv769 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next770, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv769 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %24 = load i32, ptr %arrayidx242, align 4, !tbaa !9 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv769 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %24, ptr %arrayidx244, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next770 = add nuw nsw i64 %indvars.iv769, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond773.not = icmp eq i64 %indvars.iv.next770, %wide.trip.count772 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond773.not, label %if.end390.loopexit811, label %for.body239 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24427626468, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: 24427626468, RTCostB: 19327352823
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: classify_argument at line: i386.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    SCALAR-CAST vp<%6> = trunc vp<%4> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%rem240> = srem vp<%7>, ir<%call214>
    CLONE ir<%idxprom241> = zext nneg ir<%rem240>
    CLONE ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    CLONE ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, vp<%5>
    CLONE store ir<%24>, ir<%arrayidx244>
    EMIT vp<%8> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end390.loopexit811>, scalar.ph

ir-bb<if.end390.loopexit811>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 36
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xmalloc.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                xmalloc.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xexit.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                xexit.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hashtab.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hashtab.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o safe-ctype.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                safe-ctype.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o splay-tree.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                splay-tree.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xstrdup.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                xstrdup.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o md5.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                md5.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fibheap.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                fibheap.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o xstrerror.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                xstrerror.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o concat.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                concat.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o partition.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                partition.c
========== Loop: partition_new' from partition.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_elements to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elements>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx>
    CLONE ir<%next> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE store ir<%arrayidx>, ir<%next>
    CLONE ir<%class_count> = getelementptr inbounds ir<%arrayidx>, ir<16>
    CLONE store ir<1>, ir<%class_count>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: partition_new' from partition.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_elements to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%elements>, ir<0>, ir<%indvars.iv>
    REPLICATE store ir<%0>, ir<%arrayidx>
    REPLICATE ir<%next> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE store ir<%arrayidx>, ir<%next>
    REPLICATE ir<%class_count> = getelementptr inbounds ir<%arrayidx>, ir<16>
    REPLICATE store ir<1>, ir<%class_count>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: partition_new' from partition.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_elements to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<%elements>, ir<0>, ir<%indvars.iv>
    REPLICATE store ir<%0>, ir<%arrayidx>
    WIDEN-GEP Var[Inv] ir<%next> = getelementptr inbounds ir<%arrayidx>, ir<8>
    REPLICATE store ir<%arrayidx>, ir<%next>
    WIDEN-GEP Var[Inv] ir<%class_count> = getelementptr inbounds ir<%arrayidx>, ir<16>
    REPLICATE store ir<1>, ir<%class_count>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: partition_new' from partition.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_elements to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<%elements>, ir<0>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<%0>
    WIDEN-GEP Var[Inv] ir<%next> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN store ir<%next>, ir<%arrayidx>
    WIDEN-GEP Var[Inv] ir<%class_count> = getelementptr inbounds ir<%arrayidx>, ir<16>
    WIDEN store ir<%class_count>, ir<1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'partition_new' from partition.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [1 x %struct.partition_elem], ptr %elements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %0, ptr %arrayidx, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %next = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx, ptr %next, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %class_count = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %class_count, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'partition_new' from partition.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [1 x %struct.partition_elem], ptr %elements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 %0, ptr %arrayidx, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %next = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store ptr %arrayidx, ptr %next, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %class_count = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 2 For instruction:   store i32 1, ptr %class_count, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 19

-----------------Function that is being costed:'partition_new' from partition.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [1 x %struct.partition_elem], ptr %elements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 %0, ptr %arrayidx, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %next = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   store ptr %arrayidx, ptr %next, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %class_count = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 48 for VF 4 For instruction:   store i32 1, ptr %class_count, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 18

-----------------Function that is being costed:'partition_new' from partition.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [1 x %struct.partition_elem], ptr %elements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 %0, ptr %arrayidx, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %next = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arrayidx, ptr %next, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %class_count = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %class_count, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'partition_new' from partition.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [1 x %struct.partition_elem], ptr %elements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 %0, ptr %arrayidx, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %next = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %arrayidx, ptr %next, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %class_count = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store i32 1, ptr %class_count, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: partition_new at line: partition.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_elements to i64)
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    SCALAR-CAST vp<%6> = trunc vp<%4> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elements>, ir<0>, vp<%5>
    CLONE store vp<%7>, ir<%arrayidx>
    CLONE ir<%next> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE store ir<%arrayidx>, ir<%next>
    CLONE ir<%class_count> = getelementptr inbounds ir<%arrayidx>, ir<16>
    CLONE store ir<1>, ir<%class_count>
    EMIT vp<%8> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hex.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                hex.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lbasename.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                lbasename.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o getpwd.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                getpwd.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ucbqsort.o -DSPEC_CPU -DNDEBUG -I.   -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                ucbqsort.c
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    CLONE ir<%4> = load ir<%j.2102>
    CLONE ir<%5> = load ir<%i.0101>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    CLONE store ir<%5>, ir<%j.2102>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    CLONE store ir<%4>, ir<%i.0101>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 36
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 68
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 144
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 72
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 144
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %4 = load i8, ptr %j.2102, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %5 = load i8, ptr %i.0101, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %5, ptr %j.2102, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %4, ptr %i.0101, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 288
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 68
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: specqsort at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: specqsort at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%spec.select.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%base>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%7> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%8> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%8>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%7>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: specqsort at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%spec.select.lcssa>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%base>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%46> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%47> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%47>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%46>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 4
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    CLONE ir<%16> = load ir<%i.3>
    CLONE ir<%17> = load ir<%jj.1>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    CLONE store ir<%17>, ir<%i.3>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    CLONE store ir<%16>, ir<%jj.1>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %16 = load i8, ptr %i.3, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %17 = load i8, ptr %jj.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %17, ptr %i.3, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %16, ptr %jj.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: qst at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%i.2.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%jj.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%18> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%19> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%19>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%18>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%18> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%i.2.lcssa>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%jj.0>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%56> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%57> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%57>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%56>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%18>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    CLONE ir<%6> = load ir<%i.0>
    CLONE ir<%7> = load ir<%j.1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    CLONE store ir<%7>, ir<%i.0>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    CLONE store ir<%6>, ir<%j.1>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %6 = load i8, ptr %i.0, align 1, !tbaa !12 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %7 = load i8, ptr %j.1, align 1, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %7, ptr %i.0, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %6, ptr %j.1, align 1, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: qst at line: ucbqsort.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%add.ptr>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%j.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%9> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%10> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%10>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%9>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%add.ptr>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%j.0>, vp<%5>
    vp<%7> = vector-pointer vp<%4>
    WIDEN ir<%47> = load vp<%7>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%48> = load vp<%8>
    vp<%9> = vector-pointer vp<%4>
    WIDEN store vp<%9>, ir<%48>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%47>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions          alloca.o asprintf.o vasprintf.o c-parse.o c-lang.o attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o c-objc-common.o main.o cpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpphash.o cpperror.o cppinit.o cppdefault.o line-map.o mkdeps.o prefix.o version.o mbchar.o alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o debug.o dependence.o df.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o haifa-sched.o hash.o hashtable.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o integrate.o intl.o jump.o langhooks.o lcm.o lists.o local-alloc.o loop.o obstack.o optabs.o params.o predict.o print-rtl.o print-tree.o profile.o real.o recog.o reg-stack.o regclass.o regmove.o regrename.o reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o tree-inline.o unroll.o varasm.o varray.o vmsdbgout.o xcoffout.o ggc-page.o i386.o xmalloc.o xexit.o hashtab.o safe-ctype.o splay-tree.o xstrdup.o md5.o fibheap.o xstrerror.o concat.o partition.o hex.o lbasename.o getpwd.o ucbqsort.o             -lm        -o gcc
